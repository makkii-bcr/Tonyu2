(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PicoAudio = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


	var global_1 = // eslint-disable-next-line no-undef
	check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
	Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, {
	    get: function () {
	      return 7;
	    }
	  })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
	  1: 2
	}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;
	var objectPropertyIsEnumerable = {
	  f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string

	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () {
	      return 7;
	    }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) {
	    /* empty */
	  }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};
	var objectGetOwnPropertyDescriptor = {
	  f: f$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  }

	  return it;
	};

	var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty

	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) {
	    /* empty */
	  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var objectDefineProperty = {
	  f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  }

	  return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store;

	var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap = global_1.WeakMap;
	var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

	var shared = createCommonjsModule(function (module) {
	  (module.exports = function (key, value) {
	    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	  })('versions', []).push({
	    version: '3.6.5',
	    mode:  'global',
	    copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
	  });
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$1 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;

	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    }

	    return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$1();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;

	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };

	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;

	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };

	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	  var getInternalState = internalState.get;
	  var enforceInternalState = internalState.enforce;
	  var TEMPLATE = String(String).split('String');
	  (module.exports = function (O, key, value, options) {
	    var unsafe = options ? !!options.unsafe : false;
	    var simple = options ? !!options.enumerable : false;
	    var noTargetGet = options ? !!options.noTargetGet : false;

	    if (typeof value == 'function') {
	      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	    }

	    if (O === global_1) {
	      if (simple) O[key] = value;else setGlobal(key, value);
	      return;
	    } else if (!unsafe) {
	      delete O[key];
	    } else if (!noTargetGet && O[key]) {
	      simple = true;
	    }

	    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	  })(Function.prototype, 'toString', function toString() {
	    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	  });
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor; // `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger

	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min; // `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength

	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min; // Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value; // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare

	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++]; // eslint-disable-next-line no-self-compare

	      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    }
	    return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;

	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }

	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
	  f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;
	var objectGetOwnPropertySymbols = {
	  f: f$4
	};

	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/

	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }

	  if (target) for (key in source) {
	    sourceProperty = source[key];

	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];

	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    } // add a flag to not completely full polyfills


	    if (options.sham || targetProperty && targetProperty.sham) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    } // extend global


	    redefine(target, key, sourceProperty, options);
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  }

	  return it;
	};

	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;

	  switch (length) {
	    case 0:
	      return function () {
	        return fn.call(that);
	      };

	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };

	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };

	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }

	  return function ()
	  /* ...args */
	  {
	    return fn.apply(that, arguments);
	  };
	};

	// https://tc39.github.io/ecma262/#sec-toobject

	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// https://tc39.github.io/ecma262/#sec-isarray

	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
	&& !Symbol.sham // eslint-disable-next-line no-undef
	&& typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  }

	  return WellKnownSymbolsStore[name];
	};

	var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

	var arraySpeciesCreate = function (originalArray, length) {
	  var C;

	  if (isArray(originalArray)) {
	    C = originalArray.constructor; // cross-realm fallback

	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }

	  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;

	    for (; length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);

	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	            case 3:
	              return true;
	            // some

	            case 5:
	              return value;
	            // find

	            case 6:
	              return index;
	            // findIndex

	            case 2:
	              push.call(target, value);
	            // filter
	          } else if (IS_EVERY) return false; // every
	      }
	    }

	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () {
	      throw 1;
	    }, 1);
	  });
	};

	var defineProperty = Object.defineProperty;
	var cache = {};

	var thrower = function (it) {
	  throw it;
	};

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;
	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = {
	      length: -1
	    };
	    if (ACCESSORS) defineProperty(O, 1, {
	      enumerable: true,
	      get: thrower
	    });else O[1] = 1;
	    method.call(O, argument0, argument1);
	  });
	};

	var $forEach = arrayIteration.forEach;
	var STRICT_METHOD = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

	var arrayForEach = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn
	/* , thisArg */
	) {
	  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach


	_export({
	  target: 'Array',
	  proto: true,
	  forced: [].forEach != arrayForEach
	}, {
	  forEach: arrayForEach
	});

	var slice = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  }

	  return factories[argsLength](C, args);
	}; // `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind


	var functionBind = Function.bind || function bind(that
	/* , ...args */
	) {
	  var fn = aFunction$1(this);
	  var partArgs = slice.call(arguments, 1);

	  var boundFunction = function bound()
	  /* args... */
	  {
	    var args = partArgs.concat(slice.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };

	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// https://tc39.github.io/ecma262/#sec-function.prototype.bind

	_export({
	  target: 'Function',
	  proto: true
	}, {
	  bind: functionBind
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _newArrowCheck(innerThis, boundThis) {
	  if (innerThis !== boundThis) {
	    throw new TypeError("Cannot instantiate an arrow function");
	  }
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  return function () {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (_isNativeReflectConstruct()) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	// https://tc39.github.io/ecma262/#sec-date.now

	_export({
	  target: 'Date',
	  stat: true
	}, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var DatePrototype = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var nativeDateToString = DatePrototype[TO_STRING];
	var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DatePrototype, TO_STRING, function toString() {
	    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

	    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
	  });
	}

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  }

	  return it;
	};

	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.

	/* eslint-disable no-proto */

	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;

	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {
	    /* empty */
	  }

	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if ( // it can work only with native `setPrototypeOf`
	  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	// https://tc39.github.io/ecma262/#sec-object.keys

	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// https://tc39.github.io/ecma262/#sec-object.defineproperties

	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;

	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);

	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () {
	  /* empty */
	};

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak

	  return temp;
	}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	}; // Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug


	var activeXDocument;

	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) {
	    /* ignore */
	  }

	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;

	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];

	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true; // `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create

	var objectCreate = Object.create || function create(O, Properties) {
	  var result;

	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();

	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

	var createMethod$2 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$2(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$2(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$2(3)
	};

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$1 = objectDefineProperty.f;
	var trim = stringTrim.trim;
	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

	var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber

	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;

	  if (typeof it == 'string' && it.length > 2) {
	    it = trim(it);
	    first = it.charCodeAt(0);

	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:
	        case 98:
	          radix = 2;
	          maxCode = 49;
	          break;
	        // fast equal of /^0b[01]+$/i

	        case 79:
	        case 111:
	          radix = 8;
	          maxCode = 55;
	          break;
	        // fast equal of /^0o[0-7]+$/i

	        default:
	          return +it;
	      }

	      digits = it.slice(2);
	      length = digits.length;

	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols

	        if (code < 48 || code > maxCode) return NaN;
	      }

	      return parseInt(digits, radix);
	    }
	  }

	  return +it;
	}; // `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor


	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
	    && (BROKEN_CLASSOF ? fails(function () {
	      NumberPrototype.valueOf.call(dummy);
	    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };

	  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
	    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
	      defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
	    }
	  }

	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer

	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	function picoAudioConstructor(_audioContext, _picoAudio) {
	  var _this = this;

	  this.debug = true;
	  this.isStarted = false;
	  this.isPlayed = false;
	  this.isTonyu2 = true;
	  this.settings = {
	    masterVolume: 1,
	    generateVolume: 0.15,
	    tempo: 120,
	    basePitch: 440,
	    resolution: 480,
	    isWebMIDI: false,
	    WebMIDIPortOutputs: null,
	    WebMIDIPortOutput: null,
	    WebMIDIPort: -1,
	    // -1:auto
	    WebMIDIPortSysEx: true,
	    // MIDIデバイスのフルコントロールをするかどうか（SysExを使うかどうか）(httpsじゃないと使えない)
	    isReverb: true,
	    // リバーブONにするか
	    reverbVolume: 1.5,
	    isChorus: true,
	    chorusVolume: 0.5,
	    isCC111: true,
	    loop: false,
	    isSkipBeginning: this.isTonyu2,
	    // 冒頭の余白をスキップ(Tonyu2はtrue)
	    isSkipEnding: true,
	    // 末尾の空白をスキップ
	    holdOnValue: 64,
	    maxPoly: -1,
	    // 同時発音数 -1:infinity
	    maxPercPoly: -1,
	    // 同時発音数(パーカッション) -1:infinity
	    isOfflineRendering: false,
	    // TODO 演奏データを作成してから演奏する
	    isSameDrumSoundOverlap: false // 同じドラムの音が重なることを許容するか

	  };
	  this.events = [];
	  this.trigger = {
	    isNoteTrigger: true,
	    play: function play() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    stop: function stop() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    noteOn: function noteOn() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    noteOff: function noteOff() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    songEnd: function songEnd() {
	      _newArrowCheck(this, _this);
	    }.bind(this)
	  };
	  this.states = {
	    isPlaying: false,
	    startTime: 0,
	    stopTime: 0,
	    stopFuncs: [],
	    webMIDIWaitState: null,
	    webMIDIStopTime: 0,
	    playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	    updateBufTime: 100,
	    updateBufMaxTime: 350,
	    updateIntervalTime: 0,
	    latencyLimitTime: 0
	  };
	  this.hashedDataList = [];
	  this.hashedMessageList = [];
	  this.playData = null;
	  this.channels = [];
	  this.tempoTrack = [{
	    timing: 0,
	    value: 120
	  }, {
	    timing: 0,
	    value: 120
	  }];
	  this.cc111Time = -1;
	  this.onSongEndListener = null; // チャンネルの設定値（音色, 減衰, 音量） //

	  for (var i = 0; i < 17; i++) {
	    this.channels.push([0, 0, 1]);
	  } // AudioContextがある場合はそのまま初期化、なければAudioContextを用いる初期化をinit()で


	  if (_audioContext) {
	    this.init(_audioContext, _picoAudio);
	  } // Fallback
	  // Unsupport performance.now()


	  if (typeof performance === "undefined") {
	    window.performance = {};
	  }

	  if (!performance.now) {
	    performance.now = function () {
	      _newArrowCheck(this, _this);

	      return Date.now();
	    }.bind(this);
	  } // Unsupport Number.MAX_SAFE_INTEGER


	  if (!Number.MAX_SAFE_INTEGER) {
	    Number.MAX_SAFE_INTEGER = 9007199254740991;
	  }
	}

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	} // add a key to Array.prototype[@@unscopables]


	var addToUnscopables = function (key) {
	  ArrayPrototype[UNSCOPABLES][key] = true;
	};

	var iterators = {};

	var correctPrototypeGetter = !fails(function () {
	  function F() {
	    /* empty */
	  }

	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof

	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }

	  return O instanceof Object ? ObjectPrototype : null;
	};

	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () {
	  return this;
	}; // `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

	if ( !has(IteratorPrototype, ITERATOR)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var defineProperty$2 = objectDefineProperty.f;
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$2(it, TO_STRING_TAG, {
	      configurable: true,
	      value: TAG
	    });
	  }
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

	var returnThis$1 = function () {
	  return this;
	};

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
	    next: createPropertyDescriptor(1, next)
	  });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () {
	  return this;
	};

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

	    switch (KIND) {
	      case KEYS:
	        return function keys() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case VALUES:
	        return function values() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case ENTRIES:
	        return function entries() {
	          return new IteratorConstructor(this, KIND);
	        };
	    }

	    return function () {
	      return new IteratorConstructor(this);
	    };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY; // fix native

	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
	        }
	      } // Set @@toStringTag to native iterators


	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  } // fix Array#{values, @@iterator}.name in V8 / FF


	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;

	    defaultIterator = function values() {
	      return nativeIterator.call(this);
	    };
	  } // define iterator


	  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
	  }

	  iterators[NAME] = defaultIterator; // export additional methods

	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({
	      target: NAME,
	      proto: true,
	      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
	    }, methods);
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator

	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    // target
	    index: 0,
	    // next index
	    kind: kind // kind

	  }); // `%ArrayIteratorPrototype%.next` method
	  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;

	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return {
	      value: undefined,
	      done: true
	    };
	  }

	  if (kind == 'keys') return {
	    value: index,
	    done: false
	  };
	  if (kind == 'values') return {
	    value: target[index],
	    done: false
	  };
	  return {
	    value: [index, target[index]],
	    done: false
	  };
	}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

	iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);

	  return target;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  }

	  return it;
	};

	// https://tc39.github.io/ecma262/#sec-toindex

	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = 1 / 0;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor$1 = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = new Array(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs(number); // eslint-disable-next-line no-self-compare

	  if (number != number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$1(log(number) / LN2);

	    if (number * (c = pow(2, -exponent)) < 1) {
	      exponent--;
	      c *= 2;
	    }

	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow(2, 1 - eBias);
	    }

	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }

	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
	      exponent = 0;
	    }
	  }

	  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);

	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;

	  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);

	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;

	  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);

	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;

	  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);

	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity : Infinity;
	  } else {
	    mantissa = mantissa + pow(2, mantissaLength);
	    exponent = exponent - eBias;
	  }

	  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	// https://tc39.github.io/ecma262/#sec-array.prototype.fill


	var arrayFill = function fill(value
	/* , start = 0, end = @length */
	) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

	  while (endPos > index) O[index++] = value;

	  return O;
	};

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var defineProperty$3 = objectDefineProperty.f;
	var getInternalState$1 = internalState.get;
	var setInternalState$1 = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$1 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var $DataView = global_1[DATA_VIEW];
	var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$1];
	var ObjectPrototype$1 = Object.prototype;
	var RangeError$1 = global_1.RangeError;
	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$3(Constructor[PROTOTYPE$1], key, {
	    get: function () {
	      return getInternalState$1(this)[key];
	    }
	  });
	};

	var get$1 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$1(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$1(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = bytes.slice(start, start + count);
	  return isLittleEndian ? pack : pack.reverse();
	};

	var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$1(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$1(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);

	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    setInternalState$1(this, {
	      bytes: arrayFill.call(new Array(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = getInternalState$1(buffer).byteLength;
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState$1(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });

	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll($DataView[PROTOTYPE$1], {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new NativeArrayBuffer(); // eslint-disable-line no-new

	    new NativeArrayBuffer(1.5); // eslint-disable-line no-new

	    new NativeArrayBuffer(NaN); // eslint-disable-line no-new

	    return NativeArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new NativeArrayBuffer(toIndex(length));
	    };

	    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1] = NativeArrayBuffer[PROTOTYPE$1];

	    for (var keys$2 = getOwnPropertyNames$1(NativeArrayBuffer), j$1 = 0, key$1; keys$2.length > j$1;) {
	      if (!((key$1 = keys$2[j$1++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
	      }
	    }

	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  } // WebKit bug - the same parent prototype for typed arrays and data view


	  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$1) {
	    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$1);
	  } // iOS Safari 7.x bug


	  var testView = new $DataView(new $ArrayBuffer(2));
	  var nativeSetInt8 = $DataViewPrototype.setInt8;
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, {
	    unsafe: true
	  });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var SPECIES$1 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor

	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var ArrayBuffer$1 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var nativeArrayBufferSlice = ArrayBuffer$1.prototype.slice;
	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$1(2).slice(1, undefined).byteLength;
	}); // `ArrayBuffer.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

	_export({
	  target: 'ArrayBuffer',
	  proto: true,
	  unsafe: true,
	  forced: INCORRECT_SLICE
	}, {
	  slice: function slice(start, end) {
	    if (nativeArrayBufferSlice !== undefined && end === undefined) {
	      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
	    }

	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$1))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;

	    while (first < fin) {
	      viewTarget.setUint8(index++, viewSource.getUint8(first++));
	    }

	    return result;
	  }
	});

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG$1] = 'z';
	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag'); // ES3 wrong here

	var CORRECT_ARGUMENTS = classofRaw(function () {
	  return arguments;
	}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) {
	    /* empty */
	  }
	}; // getting tag from ES6+ `Object.prototype.toString`


	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
	  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
	  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, {
	    unsafe: true
	  });
	}

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return {
	        done: !!called++
	      };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };

	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  }; // eslint-disable-next-line no-throw-literal


	  Array.from(iteratorWithReturn, function () {
	    throw 2;
	  });
	} catch (error) {
	  /* empty */
	}

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;

	  try {
	    var object = {};

	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return {
	            done: ITERATION_SUPPORT = true
	          };
	        }
	      };
	    };

	    exec(object);
	  } catch (error) {
	    /* empty */
	  }

	  return ITERATION_SUPPORT;
	};

	var defineProperty$4 = objectDefineProperty.f;
	var Int8Array$1 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$2 = Object.prototype;
	var isPrototypeOf = ObjectPrototype$2.isPrototypeOf;
	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME;
	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var isView = function isView(it) {
	  var klass = classof(it);
	  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
	};

	var isTypedArray = function (it) {
	  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
	};

	var aTypedArray = function (it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError('Target is not a typed array');
	};

	var aTypedArrayConstructor = function (C) {
	  if (objectSetPrototypeOf) {
	    if (isPrototypeOf.call(TypedArray, C)) return C;
	  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
	    var TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
	      return C;
	    }
	  }

	  throw TypeError('Target is not a typed array constructor');
	};

	var exportTypedArrayMethod = function (KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
	      delete TypedArrayConstructor.prototype[KEY];
	    }
	  }

	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;

	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];

	      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
	        delete TypedArrayConstructor[KEY];
	      }
	    }

	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
	      } catch (error) {
	        /* empty */
	      }
	    } else return;
	  }

	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME in TypedArrayConstructorsList) {
	  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
	} // WebKit bug - typed arrays constructors prototype is Object.prototype


	if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow
	  TypedArray = function TypedArray() {
	    throw TypeError('Incorrect invocation');
	  };

	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
	  }
	} // WebKit bug - one more object in Uint8ClampedArray prototype chain


	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}

	if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$4(TypedArrayPrototype, TO_STRING_TAG$3, {
	    get: function () {
	      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
	    }
	  });

	  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
	    createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	/* eslint-disable no-new */

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var ArrayBuffer$2 = global_1.ArrayBuffer;
	var Int8Array$2 = global_1.Int8Array;
	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
	  Int8Array$2(1);
	}) || !fails(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$2(2), 1, undefined).length !== 1;
	});

	var toPositiveInteger = function (it) {
	  var result = toInteger(it);
	  if (result < 0) throw RangeError("The argument can't be less than 0");
	  return result;
	};

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError('Wrong offset');
	  return offset;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || iterators[classof(it)];
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$4] === it);
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source
	/* , mapfn, thisArg */
	) {
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;

	  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    O = [];

	    while (!(step = next.call(iterator)).done) {
	      O.push(step.value);
	    }
	  }

	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2], 2);
	  }

	  length = toLength(O.length);
	  result = new (aTypedArrayConstructor$1(this))(length);

	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }

	  return result;
	};

	var SPECIES$2 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$2]) {
	    defineProperty(Constructor, SPECIES$2, {
	      configurable: true,
	      get: function () {
	        return this;
	      }
	    });
	  }
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {

	  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	  var forEach = arrayIteration.forEach;
	  var getInternalState = internalState.get;
	  var setInternalState = internalState.set;
	  var nativeDefineProperty = objectDefineProperty.f;
	  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  var round = Math.round;
	  var RangeError = global_1.RangeError;
	  var ArrayBuffer = arrayBuffer.ArrayBuffer;
	  var DataView = arrayBuffer.DataView;
	  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	  var TypedArray = arrayBufferViewCore.TypedArray;
	  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	  var isTypedArray = arrayBufferViewCore.isTypedArray;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var WRONG_LENGTH = 'Wrong length';

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = new (aTypedArrayConstructor(C))(length);

	    while (length > index) result[index] = list[index++];

	    return result;
	  };

	  var addGetter = function (it, key) {
	    nativeDefineProperty(it, key, {
	      get: function () {
	        return getInternalState(this)[key];
	      }
	    });
	  };

	  var isArrayBuffer = function (it) {
	    var klass;
	    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	  };

	  var isTypedArrayIndex = function (target, key) {
	    return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
	  };

	  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
	  };

	  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
	      target[key] = descriptor.value;
	      return target;
	    }

	    return nativeDefineProperty(target, key, descriptor);
	  };

	  if (descriptors) {
	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	      objectDefineProperty.f = wrappedDefineProperty;
	      addGetter(TypedArrayPrototype, 'buffer');
	      addGetter(TypedArrayPrototype, 'byteOffset');
	      addGetter(TypedArrayPrototype, 'byteLength');
	      addGetter(TypedArrayPrototype, 'length');
	    }

	    _export({
	      target: 'Object',
	      stat: true,
	      forced: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, {
	      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	      defineProperty: wrappedDefineProperty
	    });

	    module.exports = function (TYPE, wrapper, CLAMPED) {
	      var BYTES = TYPE.match(/\d+$/)[0] / 8;
	      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	      var GETTER = 'get' + TYPE;
	      var SETTER = 'set' + TYPE;
	      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	      var TypedArrayConstructor = NativeTypedArrayConstructor;
	      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	      var exported = {};

	      var getter = function (that, index) {
	        var data = getInternalState(that);
	        return data.view[GETTER](index * BYTES + data.byteOffset, true);
	      };

	      var setter = function (that, index, value) {
	        var data = getInternalState(that);
	        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	      };

	      var addElement = function (that, index) {
	        nativeDefineProperty(that, index, {
	          get: function () {
	            return getter(this, index);
	          },
	          set: function (value) {
	            return setter(this, index, value);
	          },
	          enumerable: true
	        });
	      };

	      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
	          var index = 0;
	          var byteOffset = 0;
	          var buffer, byteLength, length;

	          if (!isObject(data)) {
	            length = toIndex(data);
	            byteLength = length * BYTES;
	            buffer = new ArrayBuffer(byteLength);
	          } else if (isArrayBuffer(data)) {
	            buffer = data;
	            byteOffset = toOffset(offset, BYTES);
	            var $len = data.byteLength;

	            if ($length === undefined) {
	              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	              byteLength = $len - byteOffset;
	              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	            } else {
	              byteLength = toLength($length) * BYTES;
	              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	            }

	            length = byteLength / BYTES;
	          } else if (isTypedArray(data)) {
	            return fromList(TypedArrayConstructor, data);
	          } else {
	            return typedArrayFrom.call(TypedArrayConstructor, data);
	          }

	          setInternalState(that, {
	            buffer: buffer,
	            byteOffset: byteOffset,
	            byteLength: byteLength,
	            length: length,
	            view: new DataView(buffer)
	          });

	          while (index < length) addElement(that, index++);
	        });
	        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	      } else if (typedArrayConstructorsRequireWrappers) {
	        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
	          return inheritIfRequired(function () {
	            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	            if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
	            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	            return typedArrayFrom.call(TypedArrayConstructor, data);
	          }(), dummy, TypedArrayConstructor);
	        });
	        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	          if (!(key in TypedArrayConstructor)) {
	            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	          }
	        });
	        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	      }

	      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	      }

	      if (TYPED_ARRAY_TAG) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	      }

	      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
	      _export({
	        global: true,
	        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
	        sham: !NATIVE_ARRAY_BUFFER_VIEWS
	      }, exported);

	      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	      }

	      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	      }

	      setSpecies(CONSTRUCTOR_NAME);
	    };
	  } else module.exports = function () {
	    /* empty */
	  };
	});

	// https://tc39.github.io/ecma262/#sec-typedarray-objects

	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var min$2 = Math.min; // `Array.prototype.copyWithin` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

	var arrayCopyWithin = [].copyWithin || function copyWithin(target
	/* = 0 */
	, start
	/* = 0, end = @length */
	) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;

	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }

	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }

	  return O;
	};

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

	exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start
	/* , end */
	) {
	  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every = arrayIteration.every;
	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

	exportTypedArrayMethod$2('every', function every(callbackfn
	/* , thisArg */
	) {
	  return $every(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$3('fill', function fill(value
	/* , start, end */
	) {
	  return arrayFill.apply(aTypedArray$3(this), arguments);
	});

	var $filter = arrayIteration.filter;
	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

	exportTypedArrayMethod$4('filter', function filter(callbackfn
	/* , thisArg */
	) {
	  var list = $filter(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$2(C))(length);

	  while (length > index) result[index] = list[index++];

	  return result;
	});

	var $find = arrayIteration.find;
	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

	exportTypedArrayMethod$5('find', function find(predicate
	/* , thisArg */
	) {
	  return $find(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex = arrayIteration.findIndex;
	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

	exportTypedArrayMethod$6('findIndex', function findIndex(predicate
	/* , thisArg */
	) {
	  return $findIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$1 = arrayIteration.forEach;
	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

	exportTypedArrayMethod$7('forEach', function forEach(callbackfn
	/* , thisArg */
	) {
	  $forEach$1(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $includes = arrayIncludes.includes;
	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

	exportTypedArrayMethod$8('includes', function includes(searchElement
	/* , fromIndex */
	) {
	  return $includes(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf = arrayIncludes.indexOf;
	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

	exportTypedArrayMethod$9('indexOf', function indexOf(searchElement
	/* , fromIndex */
	) {
	  return $indexOf(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var Uint8Array$1 = global_1.Uint8Array;
	var arrayValues = es_array_iterator.values;
	var arrayKeys = es_array_iterator.keys;
	var arrayEntries = es_array_iterator.entries;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
	var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$5];
	var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

	var typedArrayValues = function values() {
	  return arrayValues.call(aTypedArray$a(this));
	}; // `%TypedArray%.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


	exportTypedArrayMethod$a('entries', function entries() {
	  return arrayEntries.call(aTypedArray$a(this));
	}); // `%TypedArray%.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

	exportTypedArrayMethod$a('keys', function keys() {
	  return arrayKeys.call(aTypedArray$a(this));
	}); // `%TypedArray%.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

	exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

	exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = [].join; // `%TypedArray%.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$b('join', function join(separator) {
	  return $join.apply(aTypedArray$b(this), arguments);
	});

	var min$3 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$1 = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('indexOf', {
	  ACCESSORS: true,
	  1: 0
	});
	var FORCED = NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$1; // `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

	var arrayLastIndexOf = FORCED ? function lastIndexOf(searchElement
	/* , fromIndex = @[*-1] */
	) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
	  if (index < 0) index = length + index;

	  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;

	  return -1;
	} : nativeLastIndexOf;

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement
	/* , fromIndex */
	) {
	  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
	});

	var $map = arrayIteration.map;
	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

	exportTypedArrayMethod$d('map', function map(mapfn
	/* , thisArg */
	) {
	  return $map(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
	  });
	});

	var createMethod$3 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }

	      index += i;

	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }

	    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }

	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$3(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$3(true)
	};

	var $reduce = arrayReduce.left;
	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

	exportTypedArrayMethod$e('reduce', function reduce(callbackfn
	/* , initialValue */
	) {
	  return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight = arrayReduce.right;
	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

	exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn
	/* , initialValue */
	) {
	  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$2 = Math.floor; // `%TypedArray%.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

	exportTypedArrayMethod$g('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$2(length / 2);
	  var index = 0;
	  var value;

	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  }

	  return that;
	});

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
	var FORCED$1 = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).set({});
	}); // `%TypedArray%.prototype.set` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

	exportTypedArrayMethod$h('set', function set(arrayLike
	/* , offset */
	) {
	  aTypedArray$h(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var length = this.length;
	  var src = toObject(arrayLike);
	  var len = toLength(src.length);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');

	  while (index < len) this[offset + index] = src[index++];
	}, FORCED$1);

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
	var $slice = [].slice;
	var FORCED$2 = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).slice();
	}); // `%TypedArray%.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

	exportTypedArrayMethod$i('slice', function slice(start, end) {
	  var list = $slice.call(aTypedArray$i(this), start, end);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$4(C))(length);

	  while (length > index) result[index] = list[index++];

	  return result;
	}, FORCED$2);

	var $some = arrayIteration.some;
	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

	exportTypedArrayMethod$j('some', function some(callbackfn
	/* , thisArg */
	) {
	  return $some(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
	var $sort = [].sort; // `%TypedArray%.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

	exportTypedArrayMethod$k('sort', function sort(comparefn) {
	  return $sort.call(aTypedArray$k(this), comparefn);
	});

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

	exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
	  var O = aTypedArray$l(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
	});

	var Int8Array$3 = global_1.Int8Array;
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;
	var $slice$1 = [].slice; // iOS Safari 6.x fails here

	var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
	  $toLocaleString.call(new Int8Array$3(1));
	});
	var FORCED$3 = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$3.prototype.toLocaleString.call([1, 2]);
	}); // `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

	exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
	  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
	}, FORCED$3);

	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;
	var Uint8Array$2 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
	var arrayToString = [].toString;
	var arrayJoin = [].join;

	if (fails(function () {
	  arrayToString.call({});
	})) {
	  arrayToString = function toString() {
	    return arrayJoin.call(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring

	exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	/**
	 * 固定パターンの乱数を提供するクラス
	 */
	var RandomUtil = /*#__PURE__*/function () {
	  function RandomUtil() {
	    _classCallCheck(this, RandomUtil);
	  }

	  _createClass(RandomUtil, null, [{
	    key: "resetSeed",

	    /**
	     * 乱数のシード値をリセットする
	     */
	    value: function resetSeed() {
	      this.init = true;
	      this.x = 123456789;
	      this.y = 362436069;
	      this.z = 521288629;
	      this.w = 8867512;
	    }
	    /**
	     * 乱数を返す
	     * 
	     *     Math.random() と違い、毎回固定パターンで乱数が返される
	     * Xorshiftアルゴリズム
	     * @returns {number} 乱数
	     */

	  }, {
	    key: "random",
	    value: function random() {
	      if (!this.init) this.resetSeed();
	      var t = this.x ^ this.x << 11;
	      this.x = this.y;
	      this.y = this.z;
	      this.z = this.w;
	      var r = this.w = this.w ^ this.w >>> 19 ^ (t ^ t >>> 8);
	      r = Math.abs(r) / 2147483648 % 2;
	      return r;
	    }
	  }]);

	  return RandomUtil;
	}();

	var ceil$1 = Math.ceil;
	var floor$3 = Math.floor; // `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$3 : ceil$1)(it);
	  }
	});

	/**
	 * 補間を提供するクラス
	 */
	var InterpolationUtil = /*#__PURE__*/function () {
	  function InterpolationUtil() {
	    _classCallCheck(this, InterpolationUtil);
	  }

	  _createClass(InterpolationUtil, null, [{
	    key: "lerpWave",

	    /**
	     * 波形を線形補間する
	     * @param {AudioBuffer} buffer 補間結果を入れるAudioBuffer
	     * @param {Array} vtBufs 仮想音源の配列([Float32Array, Float32Array])
	     */
	    value: function lerpWave(buffer, vtBufs) {
	      // 仮想サンプルレート音源を本番音源に変換する //
	      var bufferSize = buffer.getChannelData(0).length;
	      var vtBufsSize = vtBufs[0].length;

	      if (bufferSize == vtBufsSize) {
	        // 線形補間の必要なし //
	        for (var ch = 0; ch < 2; ch++) {
	          var data = buffer.getChannelData(ch);
	          var vtBuf = vtBufs[ch];

	          for (var i = 0; i < bufferSize; i++) {
	            data[i] = vtBuf[i];
	          }
	        }
	      } else {
	        // 線形補間 //
	        var ratio = vtBufsSize / bufferSize;

	        for (var _ch = 0; _ch < 2; _ch++) {
	          var _data = buffer.getChannelData(_ch);

	          var _vtBuf = vtBufs[_ch];

	          for (var _i = 0; _i < bufferSize; _i++) {
	            // 線形補間しながら波形を作成 //
	            // TODO 音がまだ少し違和感あるので、スプライン補正に変更した方がいいかも //
	            var idxF = _i * ratio;
	            var idx1 = Math.trunc(idxF);
	            var idx2 = (idx1 + 1) % vtBufsSize;
	            var idxR = idxF - idx1;
	            var w = _vtBuf[idx1] * (1 - idxR) + _vtBuf[idx2] * idxR;
	            _data[_i] = w;
	          }
	        }
	      }
	    }
	  }]);

	  return InterpolationUtil;
	}();

	function init(_audioContext, _picoAudio) {
	  if (this.isStarted) return;
	  this.isStarted = true; // AudioContextを生成 //

	  var AudioContext = window.AudioContext || window.webkitAudioContext;
	  this.context = _audioContext ? _audioContext : new AudioContext(); // マスターボリューム //
	  // リアルタイムで音量変更するためにdestination前にgainNodeを一つ噛ませる

	  this.masterGainNode = this.context.createGain();
	  this.masterGainNode.gain.value = this.settings.masterVolume; // 仮想サンプルレート //

	  var sampleRate = this.context.sampleRate;
	  var sampleRateVT = sampleRate >= 48000 ? 48000 : sampleRate; // ホワイトノイズ //

	  if (_picoAudio && _picoAudio.whitenoise) {
	    // 使いまわし
	    this.whitenoise = _picoAudio.whitenoise;
	  } else {
	    RandomUtil.resetSeed(); // 乱数パターンを固定にする（Math.random()を使わない）
	    // 再生環境のサンプルレートによって音が変わってしまうので //
	    // 一旦仮想サンプルレートで音源を作成する //

	    var seLength = 1;
	    var sampleLength = sampleRate * seLength;
	    var sampleLengthVT = sampleRateVT * seLength;
	    var vtBufs = [];

	    for (var ch = 0; ch < 2; ch++) {
	      vtBufs.push(new Float32Array(sampleLengthVT));
	      var vtBuf = vtBufs[ch];

	      for (var i = 0; i < sampleLengthVT; i++) {
	        var r = RandomUtil.random();
	        vtBuf[i] = r * 2 - 1;
	      }
	    } // 仮想サンプルレート音源を本番音源に変換する //


	    this.whitenoise = this.context.createBuffer(2, sampleLength, sampleRate);
	    InterpolationUtil.lerpWave(this.whitenoise, vtBufs);
	  } // リバーブ用のインパルス応答音声データ作成（てきとう） //


	  if (_picoAudio && _picoAudio.impulseResponse) {
	    // 使いまわし
	    this.impulseResponse = _picoAudio.impulseResponse;
	  } else {
	    RandomUtil.resetSeed(); // 乱数パターンを固定にする（Math.random()を使わない）
	    // 再生環境のサンプルレートによって音が変わってしまうので //
	    // 一旦仮想サンプルレートで音源を作成する //

	    var _seLength = 3.5;

	    var _sampleLength = sampleRate * _seLength;

	    var _sampleLengthVT = sampleRateVT * _seLength;

	    var _vtBufs = [];

	    for (var _ch = 0; _ch < 2; _ch++) {
	      _vtBufs.push(new Float32Array(_sampleLengthVT));

	      var _vtBuf = _vtBufs[_ch];

	      for (var _i = 0; _i < _sampleLengthVT; _i++) {
	        var v = (_sampleLengthVT - _i) / _sampleLengthVT;
	        var s = _i / sampleRateVT;
	        var d = (s < 0.030 ? 0 : v) * (s >= 0.030 && s < 0.031 ? v * 2 : v) * (s >= 0.040 && s < 0.042 ? v * 1.5 : v) * (s >= 0.050 && s < 0.054 ? v * 1.25 : v) * RandomUtil.random() * 0.2 * Math.pow(v - 0.030, 4);
	        _vtBuf[_i] = d;
	      }
	    } // 仮想サンプルレート音源を本番音源に変換する //


	    this.impulseResponse = this.context.createBuffer(2, _sampleLength, this.context.sampleRate);
	    InterpolationUtil.lerpWave(this.impulseResponse, _vtBufs);
	  } // リバーブ用のAudioNode作成・接続 //


	  this.convolver = this.context.createConvolver();
	  this.convolver.buffer = this.impulseResponse;
	  this.convolver.normalize = true;
	  this.convolverGainNode = this.context.createGain();
	  this.convolverGainNode.gain.value = this.settings.reverbVolume;
	  this.convolver.connect(this.convolverGainNode);
	  this.convolverGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(this.context.destination); // コーラス用のAudioNode作成・接続 //

	  this.chorusDelayNode = this.context.createDelay();
	  this.chorusGainNode = this.context.createGain();
	  this.chorusOscillator = this.context.createOscillator();
	  this.chorusLfoGainNode = this.context.createGain();
	  this.chorusDelayNode.delayTime.value = 0.025;
	  this.chorusLfoGainNode.gain.value = 0.010;
	  this.chorusOscillator.frequency.value = 0.05;
	  this.chorusGainNode.gain.value = this.settings.chorusVolume;
	  this.chorusOscillator.connect(this.chorusLfoGainNode);
	  this.chorusLfoGainNode.connect(this.chorusDelayNode.delayTime);
	  this.chorusDelayNode.connect(this.chorusGainNode);
	  this.chorusGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(this.context.destination);
	  this.chorusOscillator.start(0); // リバーブON/OFF設定を引き継ぐ。未設定ならパフォーマンス計測する(Tonyu2用)

	  if (this.isTonyu2) {
	    if (_picoAudio) {
	      this.settings.isReverb = _picoAudio.settings.isReverb;
	    } else {
	      this.settings.isReverb = this.measurePerformanceReverb();
	    }
	  }
	}

	function setData(data) {
	  if (this.debug) {
	    var syoriTimeS = performance.now();
	  }

	  if (this.states.isPlaying) this.stop();
	  this.playData = data;
	  this.settings.resolution = data.header.resolution;
	  this.settings.tempo = data.tempo || 120;
	  this.tempoTrack = data.tempoTrack;
	  this.cc111Time = data.cc111Time;
	  this.firstNoteOnTiming = data.firstNoteOnTiming;
	  this.lastNoteOffTiming = data.lastNoteOffTiming;
	  this.firstNoteOnTime = data.firstNoteOnTime;
	  this.lastNoteOffTime = data.lastNoteOffTime;
	  this.initStatus();

	  if (this.debug) {
	    var syoriTimeE = performance.now();
	    console.log("setData time", syoriTimeE - syoriTimeS);
	  }

	  return this;
	}

	function initStatus(isSongLooping, isLight) {
	  // WebMIDI使用中の場合、initStatus()連打の対策 //
	  if (this.settings.isWebMIDI) {
	    if (this.states.webMIDIWaitState != null) return;
	  } // 演奏中の場合、停止する //


	  this.stop(isSongLooping); // statesを初期化 //

	  this.states = {
	    isPlaying: false,
	    startTime: 0,
	    stopTime: 0,
	    stopFuncs: [],
	    webMIDIWaitState: null,
	    webMIDIStopTime: this.states.webMIDIStopTime,
	    playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	    updateBufTime: this.states.updateBufTime,
	    updateBufMaxTime: this.states.updateBufMaxTime,
	    updateIntervalTime: this.states.updateIntervalTime,
	    latencyLimitTime: this.states.latencyLimitTime,
	    noteOnAry: [],
	    noteOffAry: []
	  }; // WebMIDIの初期化・リセットメッセージ送信 //

	  if (this.settings.isWebMIDI && !isLight) {
	    if (isSongLooping) return;

	    if (this.settings.WebMIDIPortOutput == null) {
	      this.startWebMIDI();
	      return;
	    }

	    if (this.settings.WebMIDIPortSysEx) {
	      // GM1システム・オン
	      this.settings.WebMIDIPortOutput.send([0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7]);
	    } else {
	      // SysExの使用が拒否されているので、できる限り設定値を初期値に戻す
	      for (var t = 0; t < 16; t++) {
	        this.settings.WebMIDIPortOutput.send([0xC0 + t, 0]);
	        this.settings.WebMIDIPortOutput.send([0xE0 + t, 0, 64]); // ピッチあたりのずれがひどくなる場合がある よくわからない

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 101, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 6, 2]); //pitchbend

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 1]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 96, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 97, 64]); //tuning?

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 7, 100]); // volume

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 10, 64]); // pan

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 11, 127]); // expression
	        //this.settings.WebMIDIPortOutput.send([0xB0+t, 91, 40]); // リバーブ以外のエフェクトに設定される場合がありそうなのでコメントアウト
	        //this.settings.WebMIDIPortOutput.send([0xB0+t, 93, 0]); // コーラス以外のエフェクトに設定されるのか音が出なくなる場合があるのでコメントアウト

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 98, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 99, 0]); //this.settings.WebMIDIPortOutput.send([0xB0+t, 121, 0]);

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 122, 0]);
	      }
	    }
	  }
	}

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var slice$1 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap = function (scheduler) {
	  return function (handler, timeout
	  /* , ...arguments */
	  ) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	}; // ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


	_export({
	  global: true,
	  bind: true,
	  forced: MSIE
	}, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	});

	// https://tc39.github.io/ecma262/#sec-typedarray-objects

	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
	};

	var process = global_1.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);

	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	var SPECIES$3 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};

	    constructor[SPECIES$3] = function () {
	      return {
	        foo: 1
	      };
	    };

	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$2 = arrayMethodUsesToLength('splice', {
	  ACCESSORS: true,
	  0: 0,
	  1: 2
	});
	var max$1 = Math.max;
	var min$4 = Math.min;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$2
	}, {
	  splice: function splice(start, deleteCount
	  /* , ...items */
	  ) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;

	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$4(max$1(toInteger(deleteCount), 0), len - actualStart);
	    }

	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }

	    A = arraySpeciesCreate(O, actualDeleteCount);

	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }

	    A.length = actualDeleteCount;

	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }

	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }
	    }

	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }

	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var ArrayUtil = /*#__PURE__*/function (_Array) {
	  _inherits(ArrayUtil, _Array);

	  var _super = _createSuper(ArrayUtil);

	  function ArrayUtil() {
	    _classCallCheck(this, ArrayUtil);

	    return _super.apply(this, arguments);
	  }

	  _createClass(ArrayUtil, null, [{
	    key: "delete",

	    /**
	     * 配列から要素１つを削除する
	     * 
	     *     Array.splice(index, 1); を高速化する
	     *     特に配列末尾、又は配列先頭を削除するときに高速処理が期待できる
	     * @param {Array} array 配列
	     * @param {number} index 添え字
	     */
	    value: function _delete(array, index) {
	      if (index == array.length - 1) array.pop(); // 配列末尾をArray.pop()で削除すると高速化する
	      else if (index == 0) array.shift(); // 配列先頭をArray.shift()で削除すると高速化する（あまり変わらない環境もある）
	        else array.splice(index, 1); // 配列先頭・末尾以外を削除する場合はArray.splice()で削除する
	    }
	  }]);

	  return ArrayUtil;
	}( /*#__PURE__*/_wrapNativeSuper(Array));

	var ParseUtil = /*#__PURE__*/function () {
	  function ParseUtil() {
	    _classCallCheck(this, ParseUtil);
	  }

	  _createClass(ParseUtil, null, [{
	    key: "getInt",

	    /**
	     * バイト配列内に含まれる"データ長"を数値に変換する
	     * @param {Uint8Array} arr バイト配列
	     * @param {number} startIdx データ長の始点の場所(index)
	     * @param {number} endIdx データ長の終点の場所(index) - 1
	     * @returns {number} データ長
	     */
	    value: function getInt(arr, startIdx, endIdx) {
	      var value = 0;

	      for (var i = startIdx; i < endIdx; i++) {
	        value = (value << 8) + arr[i];
	      }

	      return value;
	    }
	    /**
	     * バイト配列内に含まれる"可変長のデータ長"を数値に変換する
	     * @param {Uint8Array} arr バイト配列
	     * @param {number} startIdx データ長の始点の場所(index)
	     * @param {number} endIdx データ長の終点の場所(index) - 1 (終点の場所は多くてもかまわない)
	     * @returns {Array} [データ長, "可変長のデータ長"のバイト数]
	     */

	  }, {
	    key: "variableLengthToInt",
	    value: function variableLengthToInt(arr, startIdx, endIdx) {
	      var i = startIdx;
	      var value = 0;

	      while (i < endIdx - 1 && arr[i] >= 0x80) {
	        if (i < startIdx + 4) value = (value << 7) + (arr[i] - 0x80);
	        i++;
	      }

	      value = (value << 7) + arr[i];
	      i++;
	      return [value, i - startIdx];
	    }
	    /**
	     * デルタタイムの順番になるように配列に挿入
	     * @param {PicoAudio} that PicoAudioインスタンス
	     * @param {number} ch チャンネル番号
	     * @param {number} time デルタタイム
	     * @param {number} p 対象のMIDIイベントの場所(SMFデータ内の位置)
	     * @param {number} len MIDIイベントの長さ
	     */

	  }, {
	    key: "chIndicesInsert",
	    value: function chIndicesInsert(that, ch, time, p, len) {
	      var indices = ch.indices; // デルタタイムの順番になるようにリスト配列に挿入 //

	      if (ch.indicesLength >= 4 && time < indices[ch.indicesFoot]) {
	        // Insert //
	        while (ch.indicesCur != -1) {
	          if (time < indices[ch.indicesCur]) {
	            if (ch.indicesCur == ch.indicesHead) {
	              ch.indicesHead = ch.indicesLength;
	            } else {
	              indices[ch.indicesPre + 3] = ch.indicesLength;
	            }

	            indices[ch.indicesLength] = time;
	            indices[ch.indicesLength + 1] = len;
	            indices[ch.indicesLength + 2] = p;
	            indices[ch.indicesLength + 3] = ch.indicesCur;
	            ch.indicesPre = ch.indicesLength;
	            ch.indicesLength += 4;
	            break;
	          }

	          ch.indicesPre = ch.indicesCur;
	          ch.indicesCur = indices[ch.indicesCur + 3];
	        }
	      } else {
	        // Push //
	        if (ch.indicesLength >= 4) {
	          indices[ch.indicesFoot + 3] = ch.indicesLength;
	        } else {
	          ch.indicesHead = 0;
	        }

	        ch.indicesFoot = ch.indicesLength;
	        indices[ch.indicesLength] = time;
	        indices[ch.indicesLength + 1] = len;
	        indices[ch.indicesLength + 2] = p;
	        indices[ch.indicesLength + 3] = -1;
	        ch.indicesLength += 4;
	      }
	    }
	  }]);

	  return ParseUtil;
	}();

	var UpdateNote = /*#__PURE__*/function () {
	  function UpdateNote() {
	    _classCallCheck(this, UpdateNote);
	  }

	  _createClass(UpdateNote, null, [{
	    key: "init",

	    /**
	     * 1ms毎処理用の変数を初期化
	     */
	    value: function init(picoAudio, currentTime) {
	      this.updatePreTime = performance.now();
	      this.pPreTime = performance.now();
	      this.cPreTime = picoAudio.context.currentTime * 1000;
	      this.pTimeSum = 0;
	      this.cTimeSum = 0;
	      this.cnt = 0;
	      this.initCurrentTime = currentTime;
	    }
	    /**
	     * 再生中、1ms毎に呼ばれるコールバック
	     * （ブラウザの制限で実際は最短4ms毎に呼ばれる）
	     * @returns {number} 現在の時間
	     */

	  }, {
	    key: "update",
	    value: function update(picoAudio) {
	      var _this = this;

	      var context = picoAudio.context;
	      var settings = picoAudio.settings;
	      var states = picoAudio.states;
	      var updateNowTime = performance.now();
	      var updatePreTime = this.updatePreTime;
	      var pPreTime = this.pPreTime;
	      var cPreTime = this.cPreTime;
	      var pTimeSum = this.pTimeSum;
	      var cTimeSum = this.cTimeSum;
	      var cnt = this.cnt; // サウンドが重くないか監視（フリーズ対策） //
	      //   performance.now()とAudioContext.currentTimeの時間差を計算し
	      //   AudioContext.currentTimeが遅れていたら処理落ちしていると判断する

	      var updateBufTime = updateNowTime - updatePreTime;
	      var pTime = updateNowTime;
	      var cTime = context.currentTime * 1000;
	      pTimeSum += pTime - pPreTime;
	      cTimeSum += cTime - cPreTime;
	      pPreTime = pTime;
	      cPreTime = cTime;
	      var latencyTime = pTimeSum - cTimeSum;
	      states.latencyTime = latencyTime; // サウンドが重い場合、負荷軽減処理を発動するリミットを上げていく //

	      if (latencyTime >= 100) {
	        // currentTimeが遅い（サウンドが重い）
	        states.latencyLimitTime += latencyTime;
	        cTimeSum += 100;
	      } else if (latencyTime <= -100) {
	        // currentTimeが速い（誤差）
	        cTimeSum = pTimeSum;
	      } else {
	        if (states.latencyLimitTime > 0) {
	          // currentTimeが丁度いい
	          states.latencyLimitTime -= updateBufTime * 0.003;
	          if (states.latencyLimitTime < 0) states.latencyLimitTime = 0;
	        }
	      } // ノートを先読み度合いを自動調整（予約しすぎると重くなる） //


	      states.updateIntervalTime = updateBufTime;

	      if (states.updateBufTime < updateBufTime) {
	        // 先読み遅れている場合
	        states.updateBufTime = updateBufTime;
	      } else {
	        // 先読み量に余裕がある場合
	        // 先読み量を少しずつ減らす //
	        if (states.updateBufMaxTime > 350) {
	          states.updateBufMaxTime -= states.updateBufMaxTime * 0.002;
	        } // 先読み量を少しずつ増やす //


	        if (states.updateBufTime < 20) {
	          states.updateBufTime += states.updateBufTime * 0.0005;
	        }

	        if (states.updateBufMaxTime >= 10 && states.updateBufMaxTime < 340) {
	          states.updateBufMaxTime += states.updateBufMaxTime * 0.002;
	        }
	      } // 先読み量が足りなくなった場合


	      if (states.updateBufTime > states.updateBufMaxTime) {
	        if (updateBufTime >= 900 && states.latencyLimitTime <= 150) {
	          // バックグラウンドっぽくて重くない場合、バックグラウンド再生
	          states.updateBufMaxTime += updateBufTime;
	        } else {
	          // 通常
	          var tempTime = updateBufTime - states.updateBufMaxTime;
	          states.updateBufTime = states.updateBufMaxTime; // 先読み量が小さい場合大きくする

	          if (states.updateBufMaxTime < 10) {
	            states.updateBufTime = states.updateBufMaxTime;
	            states.updateBufMaxTime *= 1.25;
	          } else {
	            states.updateBufMaxTime += tempTime / 2;
	          }
	        }

	        if (states.updateBufMaxTime > 1100) states.updateBufMaxTime = 1100;
	      } // サウンドが重すぎる場合、先読み度合いを小さくして負荷軽減 //


	      if (states.latencyLimitTime > 150) {
	        cTimeSum = pTimeSum;
	        states.latencyLimitTime -= 5;
	        if (states.latencyLimitTime > 1000) states.latencyLimitTime = 1000; // ノート先読みをかなり小さくする（フリーズ対策）

	        states.updateBufMaxTime = 1;
	        states.updateBufTime = 1;
	        updateBufTime = 1;
	      } // 再生処理 //


	      for (var ch = 0; ch < 16; ch++) {
	        var notes = picoAudio.playData.channels[ch].notes;
	        var idx = states.playIndices[ch];

	        var _loop2 = function _loop2() {
	          var _this2 = this;

	          var note = notes[idx];
	          var curTime = cnt == 0 ? _this.initCurrentTime - states.startTime : context.currentTime - states.startTime; // 終わったノートは演奏せずにスキップ

	          if (curTime >= note.stopTime) return "continue"; // （シークバーで途中から再生時）startTimeが過ぎたものは鳴らさない

	          if (cnt == 0 && curTime > note.startTime + 0.05) return "continue"; // AudioParam.setValueAtTime()等でマイナスが入るとエラーになるので対策

	          if (curTime + note.startTime < 0) return "continue"; // 演奏開始時間 - 先読み時間(ノート予約) になると演奏予約or演奏開始

	          if (curTime < note.startTime - states.updateBufTime / 1000) return "break"; // PicoAudio音源の再生処理 //

	          if (!settings.isWebMIDI) {
	            // 予約ノート数が急激に増えそうな時、先読み量を小さくしておく //
	            if (states.stopFuncs.length >= 350 && states.updateBufTime < 1000) {
	              states.updateBufTime = 12;
	              states.updateBufMaxTime = states.updateBufTime;
	            } // レトロモード（和音制限モード） //


	            if (settings.maxPoly != -1 || settings.maxPercPoly != -1) {
	              var polyCnt = 0;
	              var percCnt = 0;
	              states.stopFuncs.forEach(function (tar) {
	                _newArrowCheck(this, _this2);

	                if (!tar.note) return;

	                if (tar.note.channel != 9) {
	                  if (note.start >= tar.note.start && note.start < tar.note.stop) {
	                    polyCnt++;
	                  }
	                } else {
	                  if (note.start == tar.note.start) {
	                    percCnt++;
	                  }
	                }
	              }.bind(this));

	              if (note.channel != 9 && polyCnt >= settings.maxPoly || note.channel == 9 && percCnt >= settings.maxPercPoly) {
	                return "continue";
	              }
	            } // １ノート分の再生処理（WebAudioで再生） //


	            var stopFunc = note.channel != 9 ? picoAudio.createNote(note) : picoAudio.createPercussionNote(note);
	            if (!stopFunc) return "continue"; // 無音の場合、処理しない

	            picoAudio.pushFunc({
	              note: note,
	              stopFunc: stopFunc
	            });
	          }

	          states.noteOnAry.push(note);
	        };

	        _loop: for (; idx < notes.length; idx++) {
	          var _ret = _loop2();

	          switch (_ret) {
	            case "continue":
	              continue;

	            case "break":
	              break _loop;
	          }
	        } // notesのどこまで再生したかを記憶して、次回コールバック時にそこから処理を始める


	        states.playIndices[ch] = idx;
	      } // noteOnの時間になったか監視 //


	      this.checkNoteOn(picoAudio); // noteOffの時間になったか監視 //

	      this.checkNoteOff(picoAudio); // WebMIDIの再生処理 //

	      if (settings.isWebMIDI && settings.WebMIDIPortOutput != null) {
	        var messages = picoAudio.playData.messages;
	        var smfData = picoAudio.playData.smfData;
	        var _idx = states.playIndices[16]; // 17chはWebMIDI用

	        for (; _idx < messages.length; _idx++) {
	          var message = messages[_idx];
	          var curTime = context.currentTime - states.startTime; // 終わったノートは演奏せずにスキップ

	          if (curTime > message.time + 1) continue; // 演奏開始時間 - 先読み時間(ノート予約) になると演奏予約or演奏開始

	          if (curTime < message.time - 1) break; // WebMIDIでMIDIメッセージを送信する処理 //

	          var pLen = message.smfPtrLen;
	          var p = message.smfPtr;
	          var time = message.time;
	          var state = smfData[p];

	          if (state != 0xff) {
	            try {
	              if (state == 0xF0 || state == 0xF7) {
	                // sysExのMIDIメッセージ
	                if (settings.WebMIDIPortSysEx) {
	                  // 長さ情報を取り除いて純粋なSysExメッセージにする
	                  var lengthAry = ParseUtil.variableLengthToInt(smfData, p + 1, p + 1 + 4);
	                  var sysExStartP = p + 1 + lengthAry[1];
	                  var sysExEndP = sysExStartP + lengthAry[0];
	                  var webMIDIMes = new Uint8Array(1 + lengthAry[0]);
	                  webMIDIMes[0] = state;
	                  var size = sysExEndP - sysExStartP;

	                  for (var i = 0; i < size; i++) {
	                    webMIDIMes[i + 1] = smfData[sysExStartP + i];
	                  }

	                  settings.WebMIDIPortOutput.send(webMIDIMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);
	                }
	              } else {
	                // sysEx以外のMIDIメッセージ
	                var sendMes = [];

	                for (var _i = 0; _i < pLen; _i++) {
	                  sendMes.push(smfData[p + _i]);
	                }

	                settings.WebMIDIPortOutput.send(sendMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);
	              }
	            } catch (e) {
	              console.log(e, p, pLen, time, state);
	            }
	          }
	        } // messagesのどこまで送信したかを記憶して、次回コールバック時にそこから処理を始める


	        states.playIndices[16] = _idx;
	      } // 1msコールバックが呼ばれた回数をカウント


	      cnt++; // 変数を反映 //

	      this.updatePreTime = updateNowTime;
	      this.pPreTime = pPreTime;
	      this.cPreTime = cPreTime;
	      this.pTimeSum = pTimeSum;
	      this.cTimeSum = cTimeSum;
	      this.cnt = cnt;
	    }
	    /**
	     * noteOnの時間になったか監視
	     * @param {PicoAudio} picoAudio PicoAudioインスタンス
	     */

	  }, {
	    key: "checkNoteOn",
	    value: function checkNoteOn(picoAudio) {
	      var context = picoAudio.context;
	      var trigger = picoAudio.trigger;
	      var states = picoAudio.states;
	      var noteOnAry = picoAudio.states.noteOnAry;
	      var noteOffAry = picoAudio.states.noteOffAry;

	      for (var i = 0; i < noteOnAry.length; i++) {
	        var tempNote = noteOnAry[i];
	        var nowTime = context.currentTime - states.startTime;

	        if (tempNote.startTime - nowTime <= 0) {
	          ArrayUtil["delete"](noteOnAry, i); // noteOnAry.splice(i, 1); の高速化

	          noteOffAry.push(tempNote); // イベント発火

	          if (trigger.isNoteTrigger) trigger.noteOn(tempNote);
	          picoAudio.fireEvent('noteOn', tempNote);
	          i--;
	        }
	      }
	    }
	    /**
	     * noteOffの時間になったか監視
	     * @param {PicoAudio} picoAudio PicoAudioインスタンス
	     */

	  }, {
	    key: "checkNoteOff",
	    value: function checkNoteOff(picoAudio) {
	      var context = picoAudio.context;
	      var trigger = picoAudio.trigger;
	      var states = picoAudio.states;
	      var noteOffAry = picoAudio.states.noteOffAry;

	      for (var i = 0; i < noteOffAry.length; i++) {
	        var tempNote = noteOffAry[i];
	        var nowTime = context.currentTime - states.startTime;

	        if (tempNote.channel != 9 && tempNote.stopTime - nowTime <= 0 || tempNote.channel == 9 && tempNote.drumStopTime - nowTime <= 0) {
	          ArrayUtil["delete"](noteOffAry, i); // noteOffAry.splice(i, 1); の高速化

	          picoAudio.clearFunc("note", tempNote); // イベント発火

	          if (trigger.isNoteTrigger) trigger.noteOff(tempNote);
	          picoAudio.fireEvent('noteOff', tempNote);
	          i--;
	        }
	      }
	    }
	  }]);

	  return UpdateNote;
	}();

	function play(isSongLooping) {
	  var _this = this;

	  var context = this.context;
	  var settings = this.settings;
	  var trigger = this.trigger;
	  var states = this.states; // 再生中の場合、処理しない //

	  if (states.isPlaying) return; // WebMIDIの場合、少し待ってから再生する //

	  if (settings.isWebMIDI && !isSongLooping) {
	    // Web MIDI API使用時はstop()から800ms程待機すると音がバグりにくい
	    if (states.webMIDIWaitState != "completed") {
	      if (states.webMIDIWaitState != "waiting") {
	        // play()連打の対策
	        // stop()から1000ms後にplay()を実行
	        states.webMIDIWaitState = "waiting";
	        var waitTime = 1000 - (context.currentTime - states.webMIDIStopTime) * 1000;
	        if (states.webMIDIStopTime == 0) waitTime = 1000; // MIDI Portをopenして最初に呼び出すときも少し待つ

	        setTimeout(function () {
	          _newArrowCheck(this, _this);

	          states.webMIDIWaitState = "completed";
	          states.isPlaying = false;
	          this.play();
	        }.bind(this), waitTime);
	      }

	      return;
	    } else {
	      states.webMIDIWaitState = null;
	    }
	  } // 変数を用意 //


	  var currentTime = context.currentTime;
	  this.isPlayed = true;
	  states.isPlaying = true;
	  states.startTime = !states.startTime && !states.stopTime ? currentTime : states.startTime + currentTime - states.stopTime;
	  states.stopFuncs = []; // 冒頭の余白をスキップ //

	  if (settings.isSkipBeginning) {
	    var firstNoteOnTime = this.firstNoteOnTime;

	    if (-states.startTime + currentTime < firstNoteOnTime) {
	      this.setStartTime(firstNoteOnTime + states.startTime - currentTime);
	    }
	  } // 曲終了コールバックを予約 //


	  var reserveSongEnd;

	  var _reserveSongEndFunc = function reserveSongEndFunc() {
	    var _this2 = this;

	    _newArrowCheck(this, _this);

	    this.clearFunc("rootTimeout", reserveSongEnd);
	    var finishTime = settings.isCC111 && this.cc111Time != -1 ? this.lastNoteOffTime : this.getTime(Number.MAX_SAFE_INTEGER);

	    if (finishTime - context.currentTime + states.startTime <= 0) {
	      // 予定の時間以降に曲終了
	      trigger.songEnd();
	      this.onSongEnd();
	      this.fireEvent('songEnd');
	    } else {
	      // 処理落ちしたりしてまだ演奏中の場合、1ms後に曲終了コールバックを呼び出すよう予約
	      reserveSongEnd = setTimeout(_reserveSongEndFunc, 1);
	      this.pushFunc({
	        rootTimeout: reserveSongEnd,
	        stopFunc: function stopFunc() {
	          _newArrowCheck(this, _this2);

	          clearTimeout(reserveSongEnd);
	        }.bind(this)
	      });
	    }
	  }.bind(this);

	  var finishTime = settings.isCC111 && this.cc111Time != -1 ? this.lastNoteOffTime : this.getTime(Number.MAX_SAFE_INTEGER);
	  var reserveSongEndTime = (finishTime - context.currentTime + states.startTime) * 1000;
	  reserveSongEnd = setTimeout(_reserveSongEndFunc, reserveSongEndTime);
	  this.pushFunc({
	    rootTimeout: reserveSongEnd,
	    stopFunc: function stopFunc() {
	      _newArrowCheck(this, _this);

	      clearTimeout(reserveSongEnd);
	    }.bind(this)
	  }); // 再生開始をコールバックに通知 //

	  trigger.play();
	  this.fireEvent('play'); // 1ms毎コールバックの準備 //

	  UpdateNote.init(this, currentTime); // 1ms毎コールバックを開始 //

	  var reserve = setInterval(function () {
	    _newArrowCheck(this, _this);

	    UpdateNote.update(this);
	  }.bind(this), 1);
	  this.pushFunc({
	    rootTimeout: reserve,
	    stopFunc: function stopFunc() {
	      _newArrowCheck(this, _this);

	      clearInterval(reserve);
	    }.bind(this)
	  });
	}

	function stop(isSongLooping) {
	  var _this = this;

	  var states = this.states; // 再生していない場合、何もしない //

	  if (states.isPlaying == false) return; // ステータスを停止状態にする・終了処理を呼ぶ //

	  states.isPlaying = false;
	  states.stopTime = this.context.currentTime;
	  states.stopFuncs.forEach(function (n) {
	    _newArrowCheck(this, _this);

	    // 再生中の音の停止関数を呼ぶ
	    n.stopFunc();
	  }.bind(this));
	  states.stopFuncs = [];
	  states.playIndices.forEach(function (n, i, ary) {
	    _newArrowCheck(this, _this);

	    ary[i] = 0;
	  }.bind(this));
	  states.noteOnAry = [];
	  states.noteOffAry = []; // WebMIDIで再生中の場合、停止メッセージを送信 //

	  if (this.settings.isWebMIDI) {
	    if (isSongLooping) return;
	    if (this.settings.WebMIDIPortOutput == null) return;
	    states.webMIDIStopTime = this.context.currentTime;
	    setTimeout(function () {
	      _newArrowCheck(this, _this);

	      for (var t = 0; t < 16; t++) {
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);
	      }
	    }.bind(this), 1000);
	  } // 停止をコールバックに通知 //


	  this.trigger.stop();
	  this.fireEvent('stop');
	}

	function createBaseNote(option, isDrum, isExpression, nonChannel, nonStop) {
	  var _this = this;

	  // 最低限の変数を準備（無音の場合は処理終了するため） //
	  var settings = this.settings;
	  var context = this.context;
	  var songStartTime = this.states.startTime;
	  var channel = nonChannel ? 0 : option.channel || 0;
	  var velocity = option.velocity * Number(nonChannel ? 1 : this.channels[channel][2] != null ? this.channels[channel][2] : 1) * settings.generateVolume;
	  var isGainValueZero = true; // 無音の場合は処理終了 //

	  if (velocity <= 0) return {
	    isGainValueZero: true
	  }; // 音量の変化を設定 //

	  var expGainValue = velocity * ((option.expression ? option.expression[0].value : 100) / 127);
	  var expGainNode = context.createGain();
	  expGainNode.gain.value = expGainValue;

	  if (isExpression) {
	    option.expression ? option.expression.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      var v = velocity * (p.value / 127);
	      if (v > 0) isGainValueZero = false;
	      expGainNode.gain.setValueAtTime(v, p.time + songStartTime);
	    }.bind(this)) : false;
	  } else {
	    if (expGainValue > 0) {
	      isGainValueZero = false;
	    }
	  } // 無音の場合は処理終了 //


	  if (isGainValueZero) {
	    // 音量が常に0なら音を鳴らさない
	    return {
	      isGainValueZero: true
	    };
	  } // 全ての変数を準備 //


	  var start = option.startTime + songStartTime;
	  var stop = option.stopTime + songStartTime;
	  var pitch = settings.basePitch * Math.pow(Math.pow(2, 1 / 12), (option.pitch || 69) - 69);
	  var oscillator = !isDrum ? context.createOscillator() : context.createBufferSource();
	  var panNode = context.createStereoPanner ? context.createStereoPanner() : context.createPanner ? context.createPanner() : {
	    pan: {
	      setValueAtTime: function setValueAtTime() {
	        _newArrowCheck(this, _this);
	      }.bind(this)
	    }
	  };
	  var gainNode = context.createGain();
	  var stopGainNode = context.createGain(); // ドラムはホワイトノイズ、ドラム以外はoscillatorを設定 //
	  // oscillatorはピッチ変動も設定 //

	  if (!isDrum) {
	    oscillator.type = option.type || "sine";
	    oscillator.detune.value = 0;
	    oscillator.frequency.value = pitch;
	    option.pitchBend ? option.pitchBend.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      oscillator.frequency.setValueAtTime(settings.basePitch * Math.pow(Math.pow(2, 1 / 12), option.pitch - 69 + p.value), p.time + songStartTime);
	    }.bind(this)) : false;
	  } else {
	    oscillator.loop = true;
	    oscillator.buffer = this.whitenoise;
	  } // パンの初期値を設定 //


	  var panValue = option.pan && option.pan[0].value != 64 ? option.pan[0].value / 127 * 2 - 1 : 0;
	  initPanValue(context, panNode, panValue); // パンの変動を設定 //

	  if (context.createStereoPanner || context.createPanner) {
	    // StereoPannerNode or PannerNode がどちらかでも使える
	    var firstNode = true;

	    if (context.createStereoPanner) {
	      // StereoPannerNode が使える
	      option.pan ? option.pan.forEach(function (p) {
	        _newArrowCheck(this, _this);

	        if (firstNode) {
	          firstNode = false;
	          return;
	        }

	        var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	        if (v > 1.0) v = 1.0;
	        panNode.pan.setValueAtTime(v, p.time + songStartTime);
	      }.bind(this)) : false;
	    } else if (context.createPanner) {
	      // StereoPannerNode が未サポート、PannerNode が使える
	      if (panNode.positionX) {
	        // setValueAtTimeが使える
	        // Old Browser
	        option.pan ? option.pan.forEach(function (p) {
	          _newArrowCheck(this, _this);

	          if (firstPan) {
	            firstPan = false;
	            return;
	          }

	          var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	          var posObj = convPosition(v);
	          panNode.positionX.setValueAtTime(posObj.x, p.time + songStartTime);
	          panNode.positionY.setValueAtTime(posObj.y, p.time + songStartTime);
	          panNode.positionZ.setValueAtTime(posObj.z, p.time + songStartTime);
	        }.bind(this)) : false;
	      } else {
	        // iOS
	        // setValueAtTimeが使えないためsetTimeoutでパンの動的変更
	        option.pan ? option.pan.forEach(function (p) {
	          var _this2 = this;

	          _newArrowCheck(this, _this);

	          if (firstNode) {
	            firstNode = false;
	            return;
	          }

	          var reservePan = setTimeout(function () {
	            _newArrowCheck(this, _this2);

	            this.clearFunc("pan", reservePan);
	            var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	            if (v > 1.0) v = 1.0;
	            var posObj = convPosition(v);
	            panNode.setPosition(posObj.x, posObj.y, posObj.z);
	          }.bind(this), (p.time + songStartTime - context.currentTime) * 1000);
	          this.pushFunc({
	            pan: reservePan,
	            stopFunc: function stopFunc() {
	              _newArrowCheck(this, _this2);

	              clearTimeout(reservePan);
	            }.bind(this)
	          });
	        }.bind(this)) : false;
	      }
	    }

	    oscillator.connect(panNode);
	    panNode.connect(expGainNode);
	  } else {
	    // StereoPannerNode、PannerNode が未サポート
	    oscillator.connect(expGainNode);
	  } // AudioNodeを接続 //


	  expGainNode.connect(gainNode);
	  gainNode.connect(stopGainNode);
	  stopGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(context.destination); // モジュレーションの変動を設定 //

	  var modulationOscillator;
	  var modulationGainNode;

	  if (!isDrum && option.modulation && (option.modulation.length >= 2 || option.modulation[0].value > 0)) {
	    modulationOscillator = context.createOscillator();
	    modulationGainNode = context.createGain();
	    var _firstNode = true;
	    option.modulation ? option.modulation.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode) {
	        _firstNode = false;
	        return;
	      }

	      var m = p.value / 127;
	      if (m > 1.0) m = 1.0;
	      modulationGainNode.gain.setValueAtTime(pitch * 10 / 440 * m, p.time + songStartTime);
	    }.bind(this)) : false;
	    var m = option.modulation ? option.modulation[0].value / 127 : 0;
	    if (m > 1.0) m = 1.0;
	    modulationGainNode.gain.value = pitch * 10 / 440 * m;
	    modulationOscillator.frequency.value = 6;
	    modulationOscillator.connect(modulationGainNode);
	    modulationGainNode.connect(oscillator.frequency);
	  } // リバーブの変動を設定 //


	  if (this.settings.isReverb && option.reverb && (option.reverb.length >= 2 || option.reverb[0].value > 0)) {
	    var convolver = this.convolver;
	    var convolverGainNode = context.createGain();
	    var _firstNode2 = true;
	    option.reverb ? option.reverb.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode2) {
	        _firstNode2 = false;
	        return;
	      }

	      var r = p.value / 127;
	      if (r > 1.0) r = 1.0;
	      convolverGainNode.gain.setValueAtTime(r, p.time + songStartTime);
	    }.bind(this)) : false;
	    var r = option.reverb ? option.reverb[0].value / 127 : 0;
	    if (r > 1.0) r = 1.0;
	    convolverGainNode.gain.value = r;
	    gainNode.connect(stopGainNode);
	    stopGainNode.connect(convolverGainNode);
	    convolverGainNode.connect(convolver);
	  } // コーラスの変動を設定 //


	  if (this.settings.isChorus && option.chorus && (option.chorus.length >= 2 || option.chorus[0].value > 0)) {
	    var chorusDelayNode = this.chorusDelayNode;
	    var chorusGainNode = context.createGain();
	    var _firstNode3 = true;
	    option.chorus ? option.chorus.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode3) {
	        _firstNode3 = false;
	        return;
	      }

	      var c = p.value / 127;
	      if (c > 1.0) c = 1.0;
	      chorusGainNode.gain.setValueAtTime(c, p.time + songStartTime);
	    }.bind(this)) : false;
	    var c = option.chorus ? option.chorus[0].value / 127 : 0;
	    if (c > 1.0) c = 1.0;
	    chorusGainNode.gain.value = c;
	    gainNode.connect(stopGainNode);
	    stopGainNode.connect(chorusGainNode);
	    chorusGainNode.connect(chorusDelayNode);
	  } // モジュレーションをスタート //


	  if (modulationOscillator) {
	    modulationOscillator.start(start);
	    this.stopAudioNode(modulationOscillator, stop, modulationGainNode);
	  } // oscillator又はホワイトノイズをスタート //


	  oscillator.start(start);

	  if (!isDrum && !nonChannel && !nonStop) {
	    this.stopAudioNode(oscillator, stop, stopGainNode);
	  } // AudioNodeやパラメータを返す //


	  return {
	    start: start,
	    stop: stop,
	    pitch: pitch,
	    channel: channel,
	    velocity: velocity,
	    oscillator: oscillator,
	    panNode: panNode,
	    gainNode: gainNode,
	    stopGainNode: stopGainNode,
	    isGainValueZero: false
	  };
	}
	/**
	 * パンの初期値を設定
	 * @param {PannerNode | StereoPannerNode} panNode 
	 * @param {number} panValue 
	 */

	function initPanValue(context, panNode, panValue) {
	  if (context.createStereoPanner) {
	    if (panValue > 1.0) panValue = 1.0;
	    panNode.pan.value = panValue;
	  } else if (context.createPanner) {
	    // iOS, Old Browser
	    var posObj = convPosition(panValue);
	    panNode.panningModel = "equalpower";
	    panNode.setPosition(posObj.x, posObj.y, posObj.z);
	  }
	}
	/**
	 * pan値を基に、PannerNode用の値を{x, y, z}で返す
	 * @param {number} panValue panの値
	 * @returns Object{x, y, z}
	 */


	function convPosition(panValue) {
	  if (panValue > 1.0) panValue = 1.0;
	  var obj = {};
	  var panAngle = panValue * 90;
	  obj.x = Math.sin(panAngle * (Math.PI / 180));
	  obj.y = 0;
	  obj.z = -Math.cos(panAngle * (Math.PI / 180));
	  return obj;
	}

	function createNote(option) {
	  var _this = this;

	  var note = this.createBaseNote(option, false, true, false, true); // oscillatorのstopはこちらで実行するよう指定

	  if (note.isGainValueZero) return null;
	  var oscillator = note.oscillator;
	  var gainNode = note.gainNode;
	  var stopGainNode = note.stopGainNode;
	  var isPizzicato = false;
	  var isNoiseCut = false;
	  var note2; // 音色の設定 //

	  switch (this.channels[note.channel][0] * 1000 || option.instrument) {
	    // Sine
	    case 1000:
	    case 6:
	    case 15:
	    case 24:
	    case 26:
	    case 46:
	    case 50:
	    case 51:
	    case 52:
	    case 53:
	    case 54:
	    case 82:
	    case 85:
	    case 86:
	      {
	        oscillator.type = "sine";
	        gainNode.gain.value *= 1.5;
	        break;
	      }
	    // Square

	    case 2000:
	    case 4:
	    case 12:
	    case 13:
	    case 16:
	    case 19:
	    case 20:
	    case 32:
	    case 34:
	    case 45:
	    case 48:
	    case 49:
	    case 55:
	    case 56:
	    case 57:
	    case 61:
	    case 62:
	    case 63:
	    case 71:
	    case 72:
	    case 73:
	    case 74:
	    case 75:
	    case 76:
	    case 77:
	    case 78:
	    case 79:
	    case 80:
	    case 84:
	      {
	        oscillator.type = "square";
	        gainNode.gain.value *= 0.8;
	        break;
	      }
	    // Sawtooth

	    case 3000:
	    case 0:
	    case 1:
	    case 2:
	    case 3:
	    case 6:
	    case 7:
	    case 17:
	    case 18:
	    case 21:
	    case 22:
	    case 23:
	    case 27:
	    case 28:
	    case 29:
	    case 30:
	    case 36:
	    case 37:
	    case 38:
	    case 39:
	    case 40:
	    case 41:
	    case 42:
	    case 43:
	    case 44:
	    case 47:
	    case 59:
	    case 64:
	    case 65:
	    case 66:
	    case 67:
	    case 68:
	    case 69:
	    case 70:
	    case 71:
	    case 82:
	    case 87:
	      {
	        oscillator.type = "sawtooth";
	        break;
	      }
	    // Triangle

	    case 4000:
	    case 8:
	    case 9:
	    case 10:
	    case 11:
	    case 14:
	    case 25:
	    case 31:
	    case 33:
	    case 35:
	    case 58:
	    case 60:
	    case 83:
	    case 88:
	    case 89:
	    case 90:
	    case 91:
	    case 92:
	    case 93:
	    case 94:
	    case 95:
	      {
	        oscillator.type = "triangle";
	        gainNode.gain.value *= 1.5;
	        break;
	      }
	    // Other - Square

	    default:
	      {
	        oscillator.type = "square";
	      }
	  } // 音の終わりのプチプチノイズが気になるので、音の終わりに5ms減衰してノイズ軽減 //


	  if ((oscillator.type == "sine" || oscillator.type == "triangle") && !isPizzicato && note.stop - note.start > 0.01) {
	    isNoiseCut = true;
	  } // 減衰の設定 //


	  switch (this.channels[note.channel][1] / 10 || option.instrument) {
	    // ピッチカート系減衰
	    case 0.2:
	    case 12:
	    case 13:
	    case 45:
	    case 55:
	      {
	        isPizzicato = true;
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 0.2);
	        this.stopAudioNode(oscillator, note.start + 0.2, stopGainNode);
	        break;
	      }
	    // ピアノ程度に伸ばす系

	    case 0.3:
	    case 0:
	    case 1:
	    case 2:
	    case 3:
	    case 6:
	    case 9:
	    case 11:
	    case 14:
	    case 15:
	    case 32:
	    case 36:
	    case 37:
	    case 46:
	    case 47:
	      {
	        gainNode.gain.value *= 1.1;
	        var decay = (128 - option.pitch) / 128;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.85, note.start + decay * decay / 8);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.8, note.start + decay * decay / 4);
	        gainNode.gain.setTargetAtTime(0, note.start + decay * decay / 4, 5 * decay * decay);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }
	    // ギター系

	    case 0.4:
	    case 24:
	    case 25:
	    case 26:
	    case 27:
	    case 28:
	    case 29:
	    case 30:
	    case 31:
	    case 34:
	      {
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 1.0 + note.velocity * 4);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }
	    // 減衰していくけど終わらない系

	    case 0.5:
	    case 4:
	    case 5:
	    case 7:
	    case 8:
	    case 10:
	    case 33:
	    case 35:
	      {
	        gainNode.gain.value *= 1.0;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);
	        gainNode.gain.setValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 2.0 + note.velocity * 10);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }

	    case 119:
	      // Reverse Cymbal
	      {
	        gainNode.gain.value = 0;
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        note2 = this.createBaseNote(option, true, true);
	        if (note2.isGainValueZero) break;
	        note2.oscillator.playbackRate.setValueAtTime((option.pitch + 1) / 128, note.start);
	        note2.gainNode.gain.setValueAtTime(0, note.start);
	        note2.gainNode.gain.linearRampToValueAtTime(1.3, note.start + 2);
	        this.stopAudioNode(note2.oscillator, note.stop, note2.stopGainNode);
	        break;
	      }

	    default:
	      {
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	      }
	  } // 音をストップさせる関数を返す //


	  return function () {
	    _newArrowCheck(this, _this);

	    this.stopAudioNode(oscillator, 0, stopGainNode, true);
	    if (note2 && note2.oscillator) this.stopAudioNode(note2.oscillator, 0, note2.stopGainNode, true);
	  }.bind(this);
	}

	function createPercussionNote(option) {
	  var _this = this;

	  var note = this.createBaseNote(option, true, false);
	  if (note.isGainValueZero) return null;
	  var source = note.oscillator;
	  var gainNode = note.gainNode;
	  var stopGainNode = note.stopGainNode;
	  var start = note.start;
	  var velocity = 1; // ドラム全体の音量調整用

	  var note2 = this.createBaseNote(option, false, false, true);
	  var oscillator = note2.oscillator;
	  var gainNode2 = note2.gainNode;
	  var stopGainNode2 = note2.stopGainNode;
	  var nextSameNoteOnInterval = option.nextSameNoteOnInterval; // oscillator.frequency.setValueAtTime()がcurrentTimeより遅れると周波数設定がされないので対策

	  if (start < this.context.currentTime) start = this.context.currentTime;
	  var stopAudioTime = 0;
	  var stopAudioTime2 = 0;

	  switch (option.pitch) {
	    // 元々のパーカッション音源 //
	    // Bass drum
	    case 35:
	    case 36:
	      // w
	      gainNode.gain.value = velocity * 0.6;
	      source.playbackRate.value = 0.02;
	      stopAudioTime = 0.07; // s

	      gainNode2.gain.value = velocity * 1.1;
	      oscillator.frequency.setValueAtTime(120, start);
	      oscillator.frequency.linearRampToValueAtTime(50, start + 0.07);
	      stopAudioTime2 = 0.07;
	      break;
	    // Snare

	    case 38:
	    case 40:
	      // w
	      source.playbackRate.value = 0.7;
	      stopAudioTime = 0.05; // s

	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.05);
	      oscillator.frequency.setValueAtTime(300, start);
	      oscillator.frequency.linearRampToValueAtTime(200, start + 0.05);
	      stopAudioTime2 = 0.05;
	      break;
	    // Toms

	    case 41:
	    case 43:
	    case 45:
	    case 47:
	    case 48:
	    case 50:
	      // w
	      source.playbackRate.value = 0.01;
	      stopAudioTime = 0.1; // s

	      oscillator.type = "square";
	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.01, start + 0.1);
	      oscillator.frequency.setValueAtTime(150 + 20 * (option.pitch - 40), start);
	      oscillator.frequency.linearRampToValueAtTime(50 + 20 * (option.pitch - 40), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // Close Hihat

	    case 42:
	    case 44:
	      source.playbackRate.value = 1.5;
	      stopAudioTime = 0.02;
	      stopAudioTime2 = 0;
	      break;
	    // Open Hihat

	    case 46:
	      source.playbackRate.value = 1.5;
	      stopAudioTime = 0.3;
	      gainNode.gain.setValueAtTime(velocity * 0.9, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal

	    case 49:
	    case 51:
	    case 52:
	    case 53:
	    case 55:
	    case 57:
	      source.playbackRate.value = 1.2;
	      stopAudioTime = 0.5;
	      gainNode.gain.setValueAtTime(velocity * 1, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.5);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal2

	    case 51:
	      source.playbackRate.value = 1.1;
	      stopAudioTime = 0.4;
	      gainNode.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.4);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal3

	    case 59:
	      source.playbackRate.value = 1.8;
	      stopAudioTime = 0.3;
	      gainNode.gain.setValueAtTime(velocity * 0.5, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      stopAudioTime2 = 0;
	      break;
	    // Bongo

	    case 60:
	    case 61:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(400 - 40 * (option.pitch - 60), start);
	      oscillator.frequency.linearRampToValueAtTime(450 - 40 * (option.pitch - 60), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // mute Conga

	    case 62:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.03);
	      oscillator.frequency.setValueAtTime(200, start);
	      oscillator.frequency.linearRampToValueAtTime(250, start + 0.03);
	      stopAudioTime2 = 0.03;
	      break;
	    // open Conga

	    case 63:
	    case 64:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(200 - 30 * (option.pitch - 63), start);
	      oscillator.frequency.linearRampToValueAtTime(250 - 30 * (option.pitch - 63), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // Cowbell, Claves

	    case 56:
	    case 75:
	      // w
	      source.playbackRate.value = 0.01;
	      stopAudioTime = 0.1; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(1000 + 48 * (option.pitch - 56), start);
	      stopAudioTime2 = 0.1;
	      break;
	    // mute triangle

	    case 80:
	      // w
	      source.playbackRate.value = 5;
	      gainNode.gain.setValueAtTime(velocity * 0.5, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.2);
	      stopAudioTime = 0.05; // s

	      oscillator.type = "triangle";
	      gainNode2.gain.setValueAtTime(velocity * 0.7, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.2);
	      oscillator.frequency.setValueAtTime(6000, start);
	      stopAudioTime2 = 0.05;
	      break;
	    // open triangle

	    case 81:
	      // w
	      source.playbackRate.value = 5;
	      gainNode.gain.setValueAtTime(velocity * 0.9, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.5);
	      stopAudioTime = 0.5; // s

	      oscillator.type = "triangle";
	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      oscillator.frequency.setValueAtTime(6000, start);
	      stopAudioTime2 = 0.3;
	      break;
	    // 新しいパーカッション音源 //
	    //     旧音源が優先で鳴る。上のソース
	    //     旧音源で定義されていない場合は、新音源で鳴る。下のソース //
	    // Bass Drum

	    case 35: // Acoustic Bass Drum

	    case 36:
	      // Bass Drum
	      {
	        // w
	        source.playbackRate.value = 0.25;
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.004);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.008);
	        stopAudioTime = 0.008; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 35 ? 90 : 160, start);
	        oscillator.frequency.linearRampToValueAtTime(40, start + 0.08);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.02);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime2 = 0.08;
	        break;
	      }
	    // Snare Drum

	    case 37:
	      // Side Stick
	      {
	        // w
	        source.playbackRate.value = 0.26;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.041);
	        stopAudioTime = 0.041; // s

	        oscillator.frequency.setValueAtTime(330, start);
	        oscillator.frequency.linearRampToValueAtTime(120, start + 0.02);
	        gainNode2.gain.setValueAtTime(velocity, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.02);
	        stopAudioTime2 = 0.02;
	        break;
	      }

	    case 38: // Acoustic Snare

	    case 40:
	      // Electric Snare
	      {
	        var len = option.pitch == 38 ? 0.25 : 0.2; // w

	        source.playbackRate.value = 0.7;
	        gainNode.gain.setValueAtTime(velocity, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + len);
	        stopAudioTime = len; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 38 ? 140 : 200, start);
	        oscillator.frequency.linearRampToValueAtTime(option.pitch == 38 ? 100 : 160, start + 0.1);
	        gainNode2.gain.setValueAtTime(velocity * 2, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.1);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 39:
	      // Hand Clap
	      {
	        // w
	        source.playbackRate.value = 0.5;
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0101);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0201);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.09);
	        stopAudioTime = 0.09; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(180, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0101);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0201);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.030);
	        stopAudioTime2 = 0.11;
	        break;
	      }
	    // Toms

	    case 41: // Low Floor Tom

	    case 43: // High Floor Tom

	    case 45: // Low Tom

	    case 47: // Low-Mid Tom

	    case 48: // High-Mid Tom

	    case 50:
	      // High Tom
	      {
	        var _len = option.pitch - 41 + (option.pitch >= 48 ? 1 : 0); // w


	        source.playbackRate.value = 0.3 + _len / 45;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.02);
	        stopAudioTime = 0.02; // s

	        oscillator.frequency.setValueAtTime(90 + 15 * _len, start);
	        oscillator.frequency.linearRampToValueAtTime(30 + 7.5 * _len, start + 0.5 - _len / 35);
	        gainNode2.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.5 - _len / 35);
	        stopAudioTime2 = 0.5 - _len / 35;
	        break;
	      }
	    // Hi-hat

	    case 42: // Closed High-Hat

	    case 44:
	      // Pedal High-Hat
	      {
	        // w
	        source.playbackRate.value = 1;

	        if (option.pitch == 42) {
	          gainNode.gain.setValueAtTime(velocity * 0.8, start);
	        } else {
	          gainNode.gain.setValueAtTime(0, start);
	          gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.014);
	        }

	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 46:
	      // Open Hihat
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.35, start);
	        source.playbackRate.linearRampToValueAtTime(0.6, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.3);
	        gainNode.gain.setValueAtTime(velocity * 1.1, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 1.5; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }
	    // Cymbal

	    case 49: // Crash Cymbal 1

	    case 57:
	      // Crash Cymbal 2
	      {
	        // w
	        var r = option.pitch == 49 ? 0.3 : 0.5;
	        var r2 = option.pitch == 49 ? 0.4 : 0.7;
	        source.playbackRate.setValueAtTime(r, start);
	        source.playbackRate.linearRampToValueAtTime(r2, start + 0.15);
	        source.playbackRate.linearRampToValueAtTime(0.9, start + 0.4);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 51: // Ride Cymbal 1

	    case 59:
	      // Ride Cymbal 2
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.9, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        var f = option.pitch == 51 ? 372 : 400;
	        oscillator.frequency.setValueAtTime(f, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.4, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 52:
	      // Chinese Cymbal
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.17, start);
	        source.playbackRate.linearRampToValueAtTime(0.25, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.6);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(382, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 53:
	      // Ride Bell
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.6, start);
	        gainNode.gain.setValueAtTime(velocity, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(377, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 55:
	      // Splash Cymbal
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.5, start);
	        source.playbackRate.linearRampToValueAtTime(0.8, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.6);
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 1.75; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }
	    // Bell

	    case 54: // Tambourine

	    case 56:
	      // Cowbell
	      {
	        // w
	        source.playbackRate.setValueAtTime(1, start);
	        var v = option.pitch == 54 ? 1 : 0.4;

	        var _len2 = option.pitch == 54 ? 0.01 : 0;

	        gainNode.gain.setValueAtTime(velocity * v / 2, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * v, start + _len2);
	        gainNode.gain.setTargetAtTime(0, start + _len2, 0.05);
	        stopAudioTime = 0.3; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 54 ? 6000 : 495, start);
	        v = option.pitch == 54 ? 1 : 2;
	        gainNode2.gain.setValueAtTime(velocity * v / 2, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * v, start + _len2);
	        gainNode2.gain.setTargetAtTime(0, start + _len2, 0.05);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 58:
	      // Vibraslap
	      {
	        // w s
	        source.playbackRate.setValueAtTime(0.6, start);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.8);
	        var _len3 = 40;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);

	        for (var i = 0; i < _len3; i++) {
	          gainNode.gain.linearRampToValueAtTime(velocity * 0.1 * (_len3 - i) / _len3, start + i / _len3 * 0.8);
	          gainNode.gain.linearRampToValueAtTime(velocity * 1.5 * (_len3 - (i + 1)) / _len3, start + (i + 0.99) / _len3 * 0.8);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.025 * (_len3 - i) / _len3, start + i / _len3 * 0.8);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.25 * (_len3 - (i + 1)) / _len3, start + (i + 0.99) / _len3 * 0.8);
	        }

	        gainNode.gain.linearRampToValueAtTime(0, start + 0.8);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.8);
	        stopAudioTime = 0.8; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(1000, start);
	        stopAudioTime2 = 0.8;
	        break;
	      }

	    case 80:
	      // Mute Triangle
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.015);
	        stopAudioTime = 0.2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(6000, start);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.02);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 81:
	      // Open Triangle
	      {
	        // w
	        source.playbackRate.value = 5;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.08);
	        stopAudioTime = 0.75; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(6000, start);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.18);
	        stopAudioTime2 = 1;
	        break;
	      }
	    // Other Percussion

	    case 60: // High Bongo

	    case 61: // Low Bongo

	    case 62: // Mute High Conga

	    case 63: // Open High Conga

	    case 64:
	      // Low Conga
	      {
	        var p = option.pitch;

	        var _r = p == 60 ? 700 : p == 61 ? 282 : p == 62 ? 385 : p == 63 ? 295 : 210;

	        var _len4 = p == 60 ? 0.08 : p == 61 ? 0.1 : p == 62 ? 0.03 : p == 63 ? 0.12 : 0.15; // w


	        source.playbackRate.value = 0.03;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        stopAudioTime = 0.03; // s

	        oscillator.frequency.setValueAtTime(_r * 0.97, start);
	        oscillator.frequency.linearRampToValueAtTime(_r, start + _len4);
	        gainNode2.gain.setValueAtTime(velocity * 1.8, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + _len4);
	        stopAudioTime2 = _len4;
	        break;
	      }

	    case 65: // High Timbale

	    case 66:
	      // Low Timbale
	      {
	        var _len5 = option.pitch == 65 ? 0.22 : 0.25; // w


	        source.playbackRate.setValueAtTime(option.pitch == 65 ? 0.25 : 0.22, start);
	        source.playbackRate.linearRampToValueAtTime(option.pitch == 65 ? 0.2 : 0.18, start + _len5);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.2, start + _len5 / 3.5);
	        gainNode.gain.linearRampToValueAtTime(0, start + _len5);
	        stopAudioTime = _len5; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 65 ? 190 * 1.07 : 136 * 1.07, start);
	        oscillator.frequency.linearRampToValueAtTime(option.pitch == 65 ? 190 : 136, start + 0.1);
	        gainNode2.gain.setValueAtTime(velocity * 3.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.08);
	        stopAudioTime2 = 1;
	        break;
	      }

	    case 67: // High Agogo

	    case 68:
	      // Low Agogo
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + 0.02);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 67 ? 1430 : 1055, start);
	        gainNode2.gain.setValueAtTime(velocity * 2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.06);
	        stopAudioTime2 = 0.75;
	        break;
	      }

	    case 69:
	      // Cabasa
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.3, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.03);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 70:
	      // Maracas
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.06);
	        stopAudioTime = 0.06; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 71: // Short Whistle

	    case 72:
	      // Long Whistle
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        var _len6 = option.pitch == 71 ? 0.07 : 0.4;

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 71 ? 2408 : 2105, start);
	        gainNode2.gain.setValueAtTime(0, start);

	        for (var _i = 0; _i < _len6 * 74; _i++) {
	          gainNode2.gain.linearRampToValueAtTime(velocity * 2.5, start + (_i + 0.2) / 75);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + (_i + 0.9) / 75);
	        }

	        gainNode2.gain.linearRampToValueAtTime(0, start + _len6);
	        stopAudioTime2 = _len6;
	        break;
	      }

	    case 73: // Short Guiro

	    case 74:
	      // Long Guiro
	      {
	        // w
	        var _len7 = option.pitch == 73 ? 0.05 : 0.35;

	        source.playbackRate.setValueAtTime(option.pitch == 73 ? 0.2 : 0.2, start);
	        source.playbackRate.linearRampToValueAtTime(option.pitch == 73 ? 0.7 : 0.5, start + _len7);
	        gainNode.gain.value = velocity * 0.2;

	        for (var _i2 = 0; _i2 < _len7 * 100; _i2++) {
	          gainNode.gain.setValueAtTime(velocity * 0.4, start + _i2 / 100);
	          gainNode.gain.setValueAtTime(velocity * 0.9, start + (_i2 + 0.7) / 100);
	        }

	        stopAudioTime = _len7; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 75:
	      // Claves
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        oscillator.frequency.setValueAtTime(2181, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.setValueAtTime(velocity * 2, start + 0.005);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1, start + 0.015);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.025);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 76: // High Wood Block

	    case 77:
	      // Low Wood Block
	      {
	        // w
	        source.playbackRate.value = 0.1;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.015);
	        stopAudioTime = 0.015; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 76 ? 800 : 600, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.005);
	        gainNode2.gain.setTargetAtTime(0, start + 0.005, 0.02);
	        stopAudioTime2 = 0.2;
	        break;
	      }

	    case 78: // Close Cuica

	    case 79:
	      // Open Cuica
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        var _len8 = 0.18;

	        var _f = option.pitch == 78 ? 750 : 270;

	        oscillator.frequency.setValueAtTime(_f, start);
	        oscillator.frequency.linearRampToValueAtTime(_f, start + _len8 / 3);
	        if (option.pitch == 78) oscillator.frequency.linearRampToValueAtTime(_f * 0.9, start + _len8);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.005);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + 0.02);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.04);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 2, start + _len8 / 4 * 3);
	        gainNode2.gain.linearRampToValueAtTime(0, start + _len8);
	        stopAudioTime2 = _len8;
	        break;
	      }
	    // GS, GM2

	    case 27:
	      // High Q
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.002);
	        stopAudioTime = 0.002; // s

	        oscillator.frequency.setValueAtTime(1500, start);
	        oscillator.frequency.linearRampToValueAtTime(280, start + 0.015);
	        oscillator.frequency.linearRampToValueAtTime(0, start + 0.07);
	        gainNode2.gain.setValueAtTime(velocity * 1.9, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.07);
	        stopAudioTime2 = 0.07;
	        break;
	      }

	    case 28:
	      // Slap
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode.gain.setValueAtTime(velocity * 1.1, start + 0.0101);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode.gain.setValueAtTime(velocity * 0.9, start + 0.0201);
	        gainNode.gain.setTargetAtTime(0, start + 0.0201, 0.03);
	        stopAudioTime = 0.2; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 29: // Scratch Push

	    case 30:
	      // Scratch Pull
	      {
	        var t1 = option.pitch == 29 ? 0.05 : 0.07;
	        var t2 = option.pitch == 29 ? 0.06 : 0.09;
	        var t3 = option.pitch == 29 ? 0.07 : 0.11;
	        var t4 = option.pitch == 29 ? 0.1 : 0.15;
	        var t5 = option.pitch == 29 ? 0.25 : 0.4; // w

	        var r1 = option.pitch == 29 ? 0.1 : 0.06;

	        var _r2 = option.pitch == 29 ? 0.3 : 0.2;

	        var r3 = option.pitch == 29 ? 0.18 : 0.12;
	        source.playbackRate.setValueAtTime(r1, start);
	        source.playbackRate.linearRampToValueAtTime(_r2, start + t1);
	        source.playbackRate.linearRampToValueAtTime(0, start + t2);
	        source.playbackRate.linearRampToValueAtTime(_r2, start + t3);
	        source.playbackRate.linearRampToValueAtTime(r3, start + t4);
	        source.playbackRate.linearRampToValueAtTime(0, start + t5);
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.4, start + t1);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + t3);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.3, start + t4);
	        gainNode.gain.linearRampToValueAtTime(0, start + t5);
	        stopAudioTime = t5; // s

	        var r4 = option.pitch == 29 ? 500 : 400;
	        var r5 = option.pitch == 29 ? 1950 : 1200;
	        var r6 = option.pitch == 29 ? 430 : 250;
	        oscillator.frequency.setValueAtTime(r4, start);
	        oscillator.frequency.linearRampToValueAtTime(r5, start + t1);
	        oscillator.frequency.linearRampToValueAtTime(0, start + t2);
	        oscillator.frequency.linearRampToValueAtTime(r5, start + t3);
	        oscillator.frequency.linearRampToValueAtTime(r6, start + t4);
	        oscillator.frequency.linearRampToValueAtTime(0, start + t5);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + t1);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.2, start + t3);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.6, start + t4);
	        gainNode2.gain.linearRampToValueAtTime(0, start + t5);
	        stopAudioTime2 = t5;
	        break;
	      }

	    case 31:
	      // Sticks
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.4, start);
	        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.015);
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.035);
	        stopAudioTime = 0.3; // s

	        oscillator.frequency.setValueAtTime(3140, start);
	        gainNode2.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.012);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 32:
	      // Square Click
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        oscillator.type = "square";
	        oscillator.frequency.setValueAtTime(333, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 4, start + 0.0016);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.0032);
	        stopAudioTime2 = 0.0032;
	        break;
	      }

	    case 33: // Metronome Click

	    case 34:
	      // Metronome Bell
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.17, start);
	        source.playbackRate.linearRampToValueAtTime(0.22, start + 0.01);
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.015);
	        stopAudioTime = 0.3; // s

	        if (option.pitch == 34) {
	          oscillator.frequency.setValueAtTime(2040, start);
	          gainNode2.gain.setValueAtTime(velocity * 1, start);
	          gainNode2.gain.setTargetAtTime(0, start, 0.12);
	          stopAudioTime2 = 1.1;
	        } else {
	          gainNode2.gain.value = 0;
	          stopAudioTime2 = 0;
	        }

	        break;
	      }

	    case 82:
	      // Shaker
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.linearRampToValueAtTime(velocity, start + 0.02);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.07);
	        stopAudioTime = 0.07; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 83:
	      // Jingle Bell
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 1.2, start + 0.015);
	        gainNode.gain.setTargetAtTime(0, start + 0.015, 0.06);
	        stopAudioTime = 0.5; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(2709, start);
	        oscillator.frequency.linearRampToValueAtTime(2657, start + 0.3);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.025);
	        gainNode2.gain.setTargetAtTime(0, start + 0.025, 0.07);
	        stopAudioTime2 = 0.5;
	        break;
	      }

	    case 84:
	      // Bell Tree
	      {
	        // w s
	        var invert = false;
	        source.playbackRate.value = 1;

	        for (var _i3 = 0; _i3 < 28; _i3++) {
	          gainNode.gain.setValueAtTime(velocity * 0.1, start + _i3 / 24 * 0.45);
	          gainNode.gain.setTargetAtTime(0, start + _i3 / 24 * 0.45, 0.01);
	          oscillator.frequency.setValueAtTime(1380 * (1 + (invert ? (24 - _i3) / 24 : _i3 / 24)), start + _i3 / 24 * 0.45);
	          gainNode2.gain.setValueAtTime(velocity * (0.2 + _i3 / 24), start + _i3 / 24 * 0.45);
	          gainNode2.gain.setTargetAtTime(0, start + _i3 / 24 * 0.45, _i3 == 27 ? 0.2 : 0.01);
	        }

	        stopAudioTime = 0.5;
	        stopAudioTime2 = 1.5;
	        break;
	      }

	    case 85:
	      // Castanets
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.35, start);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.01);
	        stopAudioTime = 0.1; // s

	        oscillator.frequency.setValueAtTime(1730, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.01);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 86: // Mute Surdo

	    case 87:
	      // Open Surdo
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.020, start);
	        source.playbackRate.linearRampToValueAtTime(0.015, start + 0.5);
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 2, start + 0.005);
	        gainNode.gain.setTargetAtTime(0, start + 0.005, option.pitch == 86 ? 0.03 : 0.06);
	        stopAudioTime = 0.5; // s

	        oscillator.frequency.setValueAtTime(88, start);
	        oscillator.frequency.linearRampToValueAtTime(86, start + 0.3);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, option.pitch == 86 ? 0.1 : 0.3);
	        stopAudioTime2 = option.pitch == 86 ? 0.5 : 1.5;
	        break;
	      }

	    default:
	      {
	        source.playbackRate.value = option.pitch / 69 * 2;
	        stopAudioTime = 0.05;
	        stopAudioTime2 = 0;
	        break;
	      }
	  } // 同じドラムの音が重ならないようにする機能
	  // ドラム再生中に次の同じドラムがすぐ鳴る場合、次が鳴る前に止めて音が重ならないようにする（同時発音数の増加を軽減する）


	  if (!this.settings.isSameDrumSoundOverlap && nextSameNoteOnInterval != -1) {
	    if (stopAudioTime > nextSameNoteOnInterval) {
	      stopAudioTime = nextSameNoteOnInterval;
	    }

	    if (stopAudioTime2 > nextSameNoteOnInterval) {
	      stopAudioTime2 = nextSameNoteOnInterval;
	    }
	  } // ドラム音停止時間を設定


	  this.stopAudioNode(source, start + stopAudioTime, stopGainNode);
	  this.stopAudioNode(oscillator, start + stopAudioTime2, stopGainNode2); // ドラム停止時間を設定

	  option.drumStopTime = option.startTime + (stopAudioTime >= stopAudioTime2 ? stopAudioTime : stopAudioTime2); // 音をストップさせる関数を返す //

	  return function () {
	    _newArrowCheck(this, _this);

	    this.stopAudioNode(source, 0, stopGainNode, true);
	    this.stopAudioNode(oscillator, 0, stopGainNode2, true);
	  }.bind(this);
	}

	function stopAudioNode(tar, time, stopGainNode, isNoiseCut) {
	  var isImmed = time <= this.context.currentTime; // 即時ストップか？
	  // 予約ストップ //

	  var vol1Time = time - 0.005;
	  var stopTime = time; // 時間設定 //

	  if (isImmed) {
	    // 即時ストップ
	    if (!isNoiseCut) {
	      stopTime = this.context.currentTime;
	    } else {
	      // ノイズカット
	      vol1Time = this.context.currentTime;
	      stopTime = this.context.currentTime + 0.005;
	    }
	  } // 音の停止 //


	  try {
	    // 通常の音停止処理
	    if (!isNoiseCut) {
	      tar.stop(stopTime);
	    } else {
	      // ノイズカット（音の終わりに短いフェードアウトを入れる）
	      tar.stop(stopTime);
	      stopGainNode.gain.cancelScheduledValues(0);
	      stopGainNode.gain.setValueAtTime(1, vol1Time);
	      stopGainNode.gain.linearRampToValueAtTime(0, stopTime);
	    }
	  } catch (e) {
	    // iOS用 (stopが２回以上使えないので、代わりにstopGainNodeでミュートにする)
	    stopGainNode.gain.cancelScheduledValues(0);

	    if (!isNoiseCut) {
	      stopGainNode.gain.setValueAtTime(0, stopTime);
	    } else {
	      // ノイズカット（音の終わりに短いフェードアウトを入れる）
	      stopGainNode.gain.setValueAtTime(1, vol1Time);
	      stopGainNode.gain.linearRampToValueAtTime(0, stopTime);
	    }
	  }
	}

	function pushFunc(tar) {
	  if (!tar.note && !tar.rootTimeout && !tar.pan && !this.trigger.isNoteTrigger) {
	    return;
	  }

	  this.states.stopFuncs.push(tar);
	}

	var $some$1 = arrayIteration.some;
	var STRICT_METHOD$2 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$3 = arrayMethodUsesToLength('some'); // `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$3
	}, {
	  some: function some(callbackfn
	  /* , thisArg */
	  ) {
	    return $some$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	function clearFunc(tar1, tar2) {
	  var _this = this;

	  if (tar1 != "note" && tar1 != "rootTimeout" && tar1 != "pan" && !this.trigger.isNoteTrigger) {
	    return;
	  }

	  this.states.stopFuncs.some(function (n, i, ary) {
	    _newArrowCheck(this, _this);

	    if (n[tar1] == tar2) {
	      ArrayUtil["delete"](ary, i); // ary.splice(i, 1); を高速化

	      return true;
	    }
	  }.bind(this));
	}

	/**
	 * tickからtime(秒)を求める
	 * @param {number} tick
	 * @returns {number} time(秒)
	 */
	function getTime$1(tick) {
	  var imid = -1; // tempo変更がある場合、tickを検索する //

	  if (this.tempoTrack && this.tempoTrack.length >= 1) {
	    // 最後のtickを超える場合、最後のtimeを返す //
	    if (tick >= this.tempoTrack[this.tempoTrack.length - 1].timing) {
	      return this.tempoTrack[this.tempoTrack.length - 1].time;
	    } // 二分探索でtickを探す //


	    var imin = 0;
	    var imax = this.tempoTrack.length - 1;

	    while (true) {
	      imid = Math.floor(imin + (imax - imin) / 2);
	      var tempTiming = this.tempoTrack[imid].timing;

	      if (tick < tempTiming) {
	        imax = imid - 1;
	      } else if (tick > tempTiming) {
	        imin = imid + 1;
	      } else {
	        break;
	      }

	      if (imin > imax) {
	        if (tick < tempTiming) imid--;
	        break;
	      }
	    }
	  }

	  var time = 0;
	  var baseTiming = 0;
	  var tempo = 120;

	  if (imid >= 0) {
	    // tickを探索して見つかった場合
	    // 引数tickに一番近いtickを取得
	    var tempoObj = this.tempoTrack[imid];
	    time = tempoObj.time;
	    baseTiming = tempoObj.timing;
	    tempo = tempoObj.value;
	  } // tickからtimeを算出する
	  // 引数tickに一番近いtickのtime ＋ 引数tickから残りのtimeを算出 ＝ 現在のtime


	  time += 60 / tempo / this.settings.resolution * (tick - baseTiming);
	  return time;
	}

	/**
	 * time(秒)からtickを求める
	 * @param {number} time
	 * @returns {number} tick
	 */
	function getTiming(time) {
	  var imid = -1; // tempo変更がある場合、timeを検索する //

	  if (this.tempoTrack && this.tempoTrack.length >= 1) {
	    // 最後のtimeを超える場合、最後のtickを返す
	    if (time >= this.tempoTrack[this.tempoTrack.length - 1].time) {
	      return this.tempoTrack[this.tempoTrack.length - 1].timing;
	    } // 二分探索でtimeを探す


	    var imin = 0;
	    var imax = this.tempoTrack.length - 1;

	    while (true) {
	      imid = Math.floor(imin + (imax - imin) / 2);
	      var tempTime = this.tempoTrack[imid].time;

	      if (time < tempTime) {
	        imax = imid - 1;
	      } else if (time > tempTime) {
	        imin = imid + 1;
	      } else {
	        break;
	      }

	      if (imin > imax) {
	        if (time < tempTime) imid--;
	        break;
	      }
	    }
	  }

	  var baseTime = 0;
	  var tick = 0;
	  var tempo = 120;

	  if (imid >= 0) {
	    // timeを探索して見つかった場合
	    // 引数timeに一番近いtimeを取得
	    var tempoObj = this.tempoTrack[imid];
	    baseTime = tempoObj.time;
	    tick = tempoObj.timing;
	    tempo = tempoObj.value;
	  } // timeからtickを算出する
	  // 引数timeに一番近いtimeのtick ＋ 現在timeから残りのtickを算出 ＝ 現在のtick


	  tick += (time - baseTime) / (60 / tempo / this.settings.resolution);
	  return tick;
	}

	var PerformanceUtil = /*#__PURE__*/function () {
	  function PerformanceUtil() {
	    _classCallCheck(this, PerformanceUtil);
	  }

	  _createClass(PerformanceUtil, null, [{
	    key: "measureReverb",

	    /**
	     * 0.5秒パフォーマンス計測して、リバーブONで良さそうか判断する
	     * @returns {boolean} リバーブONで良さそう
	     */
	    value: function measureReverb() {
	      var max = 500000; // 0.5秒以内にここまで計算できればリバーブON

	      var startTime = performance.now();
	      var i = 0;

	      for (; i < max; i++) {
	        if (performance.now() - startTime >= 500) break;
	      }

	      if (this.debug) {
	        console.log("measureReverb", i, performance.now() - startTime);
	      }

	      if (i < max) return false;
	      return true;
	    }
	  }]);

	  return PerformanceUtil;
	}();

	function parseHeader(info) {
	  // 関数呼び出し元からデータをもらう //
	  var smf = info.smf; // SMFのヘッダチャンクを解析 //

	  var p = 4;
	  var header = {};
	  header.size = ParseUtil.getInt(smf, 4, 8);
	  header.format = smf[9];
	  header.trackcount = ParseUtil.getInt(smf, 10, 12);
	  header.timemanage = smf[12];
	  header.resolution = ParseUtil.getInt(smf, 12, 14); // TODO 0除算防止。15bit目1のとき、https://sites.google.com/site/yyagisite/material/smfspec#ConductorTrack

	  p += 4 + header.size; // 変数を用意 //

	  var channels = [];
	  var chSize = this.settings.isWebMIDI ? 17 : 16; // WebMIDI用に17chに全てのイベントを入れるため17ch分作る

	  for (var i = 0; i < chSize; i++) {
	    var channel = {};
	    channels.push(channel); // smfを読む順番を記録した索引配列を作る //
	    // 型付き配列をリスト構造の配列のように使う（リスト構造にすることで挿入処理を高速化する）
	    // [tick, smfMesLength, smfPtr, nextIndicesPtr, ...]

	    channel.indices = [];
	    channel.indicesLength = 0;
	    channel.indicesHead = -1; // 先頭のポインタ

	    channel.indicesFoot = 0; // 末尾のポインタ

	    channel.indicesCur = 0; // 現在のinsert用ポインタ

	    channel.indicesPre = 0; // 前回のinsert用ポインタ

	    channel.notes = [];
	  } // 関数呼び出し元にデータを返す //


	  info.p = p;
	  info.header = header;
	  info.channels = channels;
	  return info;
	}

	function parseTrack(info) {
	  // 関数呼び出し元からデータをもらう //
	  var smf = info.smf;
	  var p = info.p;
	  var header = info.header;
	  var channels = info.channels; // SMFのトラックチャンクの解析・"SMF読み込み順序配列"を作成 //
	  //   全トラックを解析しながら、SMFを読む順番を記録した配列を作成する
	  //   読み込む順番は、この解析でデルタタイム順になるようソートしておく
	  //   SMFのMIDIイベント解析時は、上記配列から「次はMIDIファイルの何バイト目を見るか」を取得して解析する
	  //   上記配列はリスト構造の配列のように使う（リスト構造にすることで配列のinsert処理を高速化する）
	  // 
	  // ■配列イメージ（json風）■
	  // [
	  //     {
	  //         tick : このMIDIイベントのTick,
	  //         smfMesLength : １つのMIDIイベントの長さ,
	  //         smfPtr : このMIDIイベントはMIDIファイルの何バイト目にあるか,
	  //         nextIndicesPtr : 次のオブジェクトはリスト配列の何番目にあるか
	  //     },
	  //     ...
	  // ]
	  // 
	  // ■実際の配列イメージ■
	  // [tick, smfMesLength, smfPtr, nextIndicesPtr, ...]

	  var tempoTrack = [];
	  var beatTrack = [];
	  var songLength = 0;

	  for (var t = 0; t < header.trackcount; t++) {
	    // "MTrk"
	    if (smf[p] != 77 || smf[p + 1] != 84 || smf[p + 2] != 114 || smf[p + 3] != 107) return "Irregular SMF.";
	    p += 4;
	    var endPoint = p + 4 + ParseUtil.getInt(smf, p, p + 4);
	    p += 4;
	    var tick = 0;
	    var tempo = 120;
	    var tempoCurTick = 0;
	    var tempoCurTime = 0;
	    var lastState = 1;
	    var dt = void 0;

	    while (p < endPoint) {
	      // DeltaTime
	      if (lastState != null) {
	        var lengthAry = ParseUtil.variableLengthToInt(smf, p, p + 5);
	        dt = lengthAry[0];
	        tick += dt;
	        p += lengthAry[1];
	      }

	      var cashP = p; // WebMIDI用
	      // Events

	      var mes0 = smf[p] >> 4; // Math.floor(smf[p] / 0x10)

	      switch (mes0) {
	        case 0x8: // Note OFF - 8[ch], Pitch, Velocity

	        case 0x9: // Note ON - 9[ch], Pitch, Velocity

	        case 0xA: // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?

	        case 0xB: // Control Change - B[ch],,

	        case 0xE:
	          // PitchBend Change - E[ch],,
	          {
	            // チャンネル毎に仕分けた後に解析する
	            lastState = smf[p];
	            var ch = channels[lastState & 0x0F];
	            ParseUtil.chIndicesInsert(this, ch, tick, p, 3);
	            p += 3;
	            break;
	          }

	        case 0xC: // Program Change - C[ch],

	        case 0xD:
	          // Channel Pre - D[ch],
	          {
	            // チャンネル毎に仕分けた後に解析する
	            lastState = smf[p];
	            var _ch = channels[lastState & 0x0F];
	            ParseUtil.chIndicesInsert(this, _ch, tick, p, 2);
	            p += 2;
	            break;
	          }
	        // SysEx Events or Meta Events - F[ch], ...

	        case 0xF:
	          {
	            //lastState = smf[p]; <- ランニングステートは無い
	            switch (smf[p]) {
	              case 0xF0:
	              case 0xF7:
	                {
	                  // SysEx Events
	                  var _lengthAry = ParseUtil.variableLengthToInt(smf, p + 1, p + 1 + 4); // Master Volume
	                  // 0xF0, size, 0x7f, 0x7f, 0x04, 0x01, 0xNN, volume, 0xF7


	                  if (_lengthAry[0] >= 7 && smf[p + 2] == 0x7f && smf[p + 3] == 0x7f && smf[p + 4] == 0x04 && smf[p + 5] == 0x01) {
	                    // 全チャンネルにMasterVolumeイベントを挿入する
	                    for (var i = 0; i < 16; i++) {
	                      var _ch2 = channels[i];
	                      ParseUtil.chIndicesInsert(this, _ch2, tick, p, _lengthAry[0]);
	                    }
	                  }

	                  p += 1 + _lengthAry[1] + _lengthAry[0];
	                  break;
	                }

	              case 0xF1:
	                p += 2;
	                break;

	              case 0xF2:
	                p += 3;
	                break;

	              case 0xF3:
	                p += 2;
	                break;

	              case 0xF6:
	              case 0xF8:
	              case 0xFA:
	              case 0xFB:
	              case 0xFC:
	              case 0xFE:
	                p += 1;
	                break;

	              case 0xFF:
	                {
	                  // Meta Events
	                  switch (smf[p + 1]) {
	                    case 0x00:
	                    case 0x01:
	                    case 0x02:
	                    case 0x03:
	                    case 0x04:
	                    case 0x05:
	                    case 0x06:
	                    case 0x07:
	                    case 0x20:
	                      break;

	                    case 0x2F:
	                      tick += (this.settings.isSkipEnding ? 0 : header.resolution) - dt;
	                      break;

	                    case 0x51:
	                      // Tempo
	                      // 全チャンネルにTempoイベントを挿入する
	                      for (var _i = 0; _i < 16; _i++) {
	                        var _ch3 = channels[_i];
	                        ParseUtil.chIndicesInsert(this, _ch3, tick, p, 6);
	                      }

	                      tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);
	                      tempoCurTick = tick;
	                      tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	                      tempoTrack.push({
	                        timing: tick,
	                        time: tempoCurTime,
	                        value: tempo
	                      });
	                      break;

	                    case 0x54:
	                      break;

	                    case 0x58:
	                      // Beat
	                      beatTrack.push({
	                        timing: tick,
	                        value: [smf[p + 3], Math.pow(2, smf[p + 4])]
	                      });
	                      break;
	                  }

	                  var _lengthAry2 = ParseUtil.variableLengthToInt(smf, p + 2, p + 2 + 4);

	                  p += 2 + _lengthAry2[1] + _lengthAry2[0];
	                  break;
	                }
	            }

	            break;
	          }

	        default:
	          {
	            if (lastState == null) return "Irregular SMF. (" + p + " byte addr)";
	            p--;
	            smf[p] = lastState; // 上書き

	            lastState = null;
	          }
	      } // WebMIDIAPI


	      if (this.settings.isWebMIDI) {
	        if (lastState != null) {
	          // WebMIDI用に17chに全てのMIDIイベントを入れる
	          ParseUtil.chIndicesInsert(this, channels[16], tick, cashP, p - cashP);
	        }
	      }
	    }

	    if (!this.settings.isSkipEnding && songLength < tick) songLength = tick; // リスト配列のポインタを初期化

	    for (var _i2 = 0; _i2 < channels.length; _i2++) {
	      channels[_i2].indicesCur = channels[_i2].indicesHead;
	      channels[_i2].indicesPre = channels[_i2].indicesHead;
	    }
	  } // 関数呼び出し元にデータを返す //


	  info.p = p;
	  info.tempoTrack = tempoTrack;
	  info.beatTrack = beatTrack;
	  info.songLength = songLength;
	  return info;
	}

	function parseEvent(info) {
	  var _this = this;

	  // 関数呼び出し元からデータをもらう //
	  var smf = info.smf;
	  var header = info.header;
	  var channels = info.channels;
	  var tempoTrack = info.tempoTrack;
	  var songLength = info.songLength; // SMFのMIDIイベント解析 //

	  var tempo;
	  var tempoCurTick;
	  var tempoCurTime;
	  var cc111Tick = -1;
	  var cc111Time = -1;
	  var firstNoteOnTiming = Number.MAX_SAFE_INTEGER; // 最初のノートオンのTick

	  var firstNoteOnTime = Number.MAX_SAFE_INTEGER;
	  var lastNoteOffTiming = 0; // 最後のノートオフのTick

	  var lastNoteOffTime = 0; // Midi Events (0x8n - 0xEn) parse

	  var _loop = function _loop(ch) {
	    var channel = channels[ch];
	    var dataEntry = 2;
	    var pitchBend = 0;
	    var pan = 64;
	    var expression = 127;
	    var velocity = 100;
	    var modulation = 0;
	    var hold = 0;
	    var reverb = _this.isTonyu2 ? 0 : 10;
	    var chorus = 0;
	    var nrpnLsb = 127;
	    var nrpnMsb = 127;
	    var rpnLsb = 127;
	    var rpnMsb = 127;
	    var instrument = 0;
	    var masterVolume = 127;
	    tempo = 120;
	    tempoCurTick = 0;
	    tempoCurTime = 0;
	    var nowNoteOnIdxAry = [];
	    var indIdx = channel.indicesHead;
	    var indices = channel.indices;
	    var nextNoteOnAry = new Array(128);

	    var _loop3 = function _loop3() {
	      var _this3 = this;

	      var tick = indices[indIdx];
	      var p = indices[indIdx + 2];
	      var nextIdx = indices[indIdx + 3];
	      var time = 60 / tempo / header.resolution * (tick - tempoCurTick) + tempoCurTime; // Events

	      var mes0 = smf[p] >> 4; // Math.floor(smf[p] / 0x10)

	      switch (mes0) {
	        case 0x8: // Note OFF - 8[ch], Pitch, Velocity

	        case 0x9:
	          // Note ON - 9[ch], Pitch, Velocity
	          if (mes0 == 0x9 && smf[p + 2] != 0) {
	            // ノートオン
	            // ノート情報が入ったオブジェクトを作成 //
	            var note = {
	              start: tick,
	              stop: null,
	              startTime: time,
	              stopTime: null,
	              pitch: smf[p + 1],
	              pitchBend: [{
	                timing: tick,
	                time: time,
	                value: pitchBend
	              }],
	              pan: [{
	                timing: tick,
	                time: time,
	                value: pan
	              }],
	              expression: [{
	                timing: tick,
	                time: time,
	                value: expression * (masterVolume / 127)
	              }],
	              velocity: smf[p + 2] / 127 * (velocity / 127),
	              modulation: [{
	                timing: tick,
	                time: time,
	                value: modulation
	              }],
	              holdBeforeStop: null,
	              reverb: [{
	                timing: tick,
	                time: time,
	                value: reverb
	              }],
	              chorus: [{
	                timing: tick,
	                time: time,
	                value: chorus
	              }],
	              instrument: instrument,
	              channel: ch,
	              nextSameNoteOnInterval: -1,
	              drumStopTime: 2 // 再生時に使う

	            }; // 前回鳴っていた同音ノートに次のノートオン時間を入れる //
	            // 同音ノートを二重再生したくない場合のために記録する //

	            var prevNote = nextNoteOnAry[smf[p + 1]];

	            if (prevNote) {
	              prevNote.nextSameNoteOnInterval = time - prevNote.startTime;
	            }

	            nextNoteOnAry[smf[p + 1]] = note; // 同音ノートがノートオン中の場合、ノートオフにする //

	            nowNoteOnIdxAry.some(function (idx, i) {
	              _newArrowCheck(this, _this3);

	              var note = channel.notes[idx];

	              if (note.pitch == smf[p + 1] && note.stop == null) {
	                note.stop = tick;
	                note.stopTime = time;
	                ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); を軽量化
	              }
	            }.bind(this)); // ノートオン中配列に入れる

	            nowNoteOnIdxAry.push(channel.notes.length); // notes一覧にnoteオブジェクトを入れる

	            channel.notes.push(note); // 最初のノートオン時間を記録 //

	            if (tick < firstNoteOnTiming) {
	              firstNoteOnTiming = tick;
	              firstNoteOnTime = time;
	            }
	          } else {
	            // ノートオフ
	            // ノートオン中配列から該当ノートを探し、ノートオフ処理をする //
	            nowNoteOnIdxAry.some(function (idx, i) {
	              _newArrowCheck(this, _this3);

	              var note = channel.notes[idx];

	              if (note.pitch == smf[p + 1] && note.stop == null) {
	                if (hold >= _this.settings.holdOnValue) {
	                  // ホールドが効いている場合
	                  if (note.holdBeforeStop == null) {
	                    note.holdBeforeStop = [{
	                      timing: tick,
	                      time: time,
	                      value: hold
	                    }];
	                  }
	                } else {
	                  // ホールドしていない場合
	                  note.stop = tick;
	                  note.stopTime = time;
	                  ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); を軽量化
	                } // 最後のノートオフ時間を記録 //


	                if (tick > lastNoteOffTiming) {
	                  lastNoteOffTiming = tick;
	                  lastNoteOffTime = time;
	                }

	                return true;
	              }
	            }.bind(this));
	          }

	          break;
	        // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?

	        case 0xA:
	          break;
	        // Control Change - B[ch],,

	        case 0xB:
	          switch (smf[p + 1]) {
	            case 1:
	              // modulation
	              modulation = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.modulation.push({
	                  timing: tick,
	                  time: time,
	                  value: modulation
	                });
	              }.bind(this));
	              break;

	            case 6:
	              if (rpnLsb == 0 && rpnMsb == 0) {
	                // RLSB=0 & RMSB=0 -> 6はピッチ
	                dataEntry = smf[p + 2];

	                if (dataEntry > 24) {
	                  dataEntry = 24;
	                }
	              }

	              break;

	            case 7:
	              velocity = smf[p + 2];
	              break;

	            case 10:
	              // Pan
	              pan = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.pan.push({
	                  timing: tick,
	                  time: time,
	                  value: pan
	                });
	              }.bind(this));
	              break;

	            case 11:
	              // Expression
	              expression = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.expression.push({
	                  timing: tick,
	                  time: time,
	                  value: expression * (masterVolume / 127)
	                });
	              }.bind(this));
	              break;

	            case 64:
	              // Hold1
	              hold = smf[p + 2];

	              if (hold < _this.settings.holdOnValue) {
	                for (var _i = nowNoteOnIdxAry.length - 1; _i >= 0; _i--) {
	                  var idx = nowNoteOnIdxAry[_i];
	                  var _note = channel.notes[idx];

	                  if (_note.stop == null && _note.holdBeforeStop != null) {
	                    _note.stop = tick;
	                    _note.stopTime = time;
	                    ArrayUtil["delete"](nowNoteOnIdxAry, _i); // nowNoteOnIdxAry.splice(i, 1); を軽量化
	                  }
	                }
	              }

	              break;

	            case 91:
	              // reverb
	              reverb = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.reverb.push({
	                  timing: tick,
	                  time: time,
	                  value: reverb
	                });
	              }.bind(this));
	              break;

	            case 93:
	              // chorus
	              chorus = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.chorus.push({
	                  timing: tick,
	                  time: time,
	                  value: chorus
	                });
	              }.bind(this));
	              break;

	            case 98:
	              nrpnLsb = smf[p + 2];
	              break;

	            case 99:
	              nrpnMsb = smf[p + 2];
	              break;

	            case 100:
	              rpnLsb = smf[p + 2];
	              break;

	            case 101:
	              rpnMsb = smf[p + 2];
	              break;

	            case 111:
	              // RPGツクール用ループ(CC111)
	              if (cc111Tick == -1) {
	                cc111Tick = tick;
	                cc111Time = time;
	              }

	              break;
	          }

	          break;
	        // Program Change - C[ch],

	        case 0xC:
	          instrument = smf[p + 1];
	          break;
	        // Channel Pre - D[ch],

	        case 0xD:
	          break;
	        // PitchBend Change - E[ch],,

	        case 0xE:
	          pitchBend = (smf[p + 2] * 128 + smf[p + 1] - 8192) / 8192 * dataEntry;
	          nowNoteOnIdxAry.forEach(function (idx) {
	            _newArrowCheck(this, _this3);

	            var note = channel.notes[idx];
	            note.pitchBend.push({
	              timing: tick,
	              time: time,
	              value: pitchBend
	            });
	          }.bind(this));
	          break;

	        case 0xF:
	          //lastState = smf[p]; <- ランニングステートは無い
	          switch (smf[p]) {
	            case 0xF0:
	            case 0xF7:
	              // Master Volume
	              if (smf[p + 1] == 0x7f && smf[p + 2] == 0x7f && smf[p + 3] == 0x04 && smf[p + 4] == 0x01) {
	                var vol = smf[p + 6];
	                if (vol > 127) vol = 127;
	                masterVolume = vol;
	                nowNoteOnIdxAry.forEach(function (idx) {
	                  _newArrowCheck(this, _this3);

	                  var note = channel.notes[idx];
	                  note.expression.push({
	                    timing: tick,
	                    time: time,
	                    value: expression * (masterVolume / 127)
	                  });
	                }.bind(this));
	              }

	              break;

	            case 0xFF:
	              // Meta Events
	              switch (smf[p + 1]) {
	                case 0x51:
	                  // Tempo
	                  tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);
	                  tempoCurTick = tick;
	                  tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	                  break;
	              }

	              break;
	          }

	          break;

	        default:
	          {
	            return {
	              v: {
	                v: "Error parseSMF. "
	              }
	            };
	          }
	      }

	      indIdx = nextIdx;
	    };

	    while (indIdx != -1) {
	      var _ret2 = _loop3();

	      if (_typeof(_ret2) === "object") return _ret2.v;
	    }

	    channel.nowNoteOnIdxAry = nowNoteOnIdxAry;

	    if (!_this.debug) {
	      delete channel.indices;
	    }
	  };

	  for (var ch = 0; ch < 16; ch++) {
	    var _ret = _loop(ch);

	    if (_typeof(_ret) === "object") return _ret.v;
	  } // ホールドが効いてノートオンのままになったノートをノートオフする //


	  for (var _ch = 0; _ch < 16; _ch++) {
	    var channel = channels[_ch];
	    var nowNoteOnIdxAry = channel.nowNoteOnIdxAry;

	    var _loop2 = function _loop2(i) {
	      var _this2 = this;

	      var note = channel.notes[nowNoteOnIdxAry[i]];

	      if (note.stop == null) {
	        note.stop = lastNoteOffTiming;
	        note.stopTime = lastNoteOffTime; // If (note.cc[x].timing > lastNoteOffTiming), delete note.cc[x]

	        var nameAry = ["pitchBend", "pan", "expression", "modulation", "reverb", "chorus"];
	        nameAry.forEach(function (name) {
	          _newArrowCheck(this, _this2);

	          var ccAry = note[name];

	          for (var i2 = ccAry.length - 1; i2 >= 1; i2--) {
	            var obj = ccAry[i2];

	            if (obj.timing > lastNoteOffTiming) {
	              ArrayUtil["delete"](ccAry, i2); // ccAry.splice(i2, 1); を軽量化
	            }
	          }
	        }.bind(this));
	        ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); を軽量化
	      }
	    };

	    for (var i = nowNoteOnIdxAry.length - 1; i >= 0; i--) {
	      _loop2(i);
	    }

	    delete channel.nowNoteOnIdxAry;
	  }

	  if (this.settings.isSkipEnding) songLength = lastNoteOffTiming;
	  tempoTrack.push({
	    timing: songLength,
	    time: 60 / tempo / header.resolution * (songLength - tempoCurTick) + tempoCurTime,
	    value: 120
	  }); // WebMIDI用のMIDIメッセージを作成 //

	  var messages = [];

	  if (this.settings.isWebMIDI) {
	    var _channel = channels[16];
	    var _tempo = 120;
	    var _tempoCurTick = 0;
	    var _tempoCurTime = 0;
	    var indIdx = _channel.indicesHead;
	    var indices = _channel.indices;

	    while (indIdx != -1) {
	      var tick = indices[indIdx];
	      var pLen = indices[indIdx + 1];
	      var p = indices[indIdx + 2];
	      var nextIdx = indices[indIdx + 3];
	      var time = 60 / _tempo / header.resolution * (tick - _tempoCurTick) + _tempoCurTime; // Events

	      switch (smf[p]) {
	        case 0xFF:
	          // Meta Events
	          switch (smf[p + 1]) {
	            case 0x51:
	              // Tempo
	              _tempoCurTime += 60 / _tempo / header.resolution * (tick - _tempoCurTick);
	              _tempoCurTick = tick;
	              _tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	              break;
	          }

	      }

	      messages.push({
	        time: time,
	        tick: tick,
	        smfPtr: p,
	        smfPtrLen: pLen
	      });
	      indIdx = nextIdx;
	    }
	  } // 関数呼び出し元にデータを返す //


	  info.songLength = songLength;
	  info.cc111Tick = cc111Tick;
	  info.cc111Time = cc111Time;
	  info.firstNoteOnTiming = firstNoteOnTiming;
	  info.firstNoteOnTime = firstNoteOnTime;
	  info.lastNoteOffTiming = lastNoteOffTiming;
	  info.lastNoteOffTime = lastNoteOffTime;

	  if (this.settings.isWebMIDI) {
	    info.messages = messages;
	    info.smfData = new Uint8Array(smf); // lastStateを上書きしたsmfをコピー
	  }

	  return info;
	}

	function parseSMF(_smf) {
	  if (this.debug) {
	    console.log(_smf);
	    var syoriTimeS1 = performance.now();
	  } // smf配列はデータ上書きするので_smfをディープコピーする


	  var smf = new Uint8Array(_smf); // SMFのフォーマットかどうかチェック //
	  // "MThd"

	  if (smf[0] != 77 || smf[1] != 84 || smf[2] != 104 || smf[3] != 100) return "Not Sandard MIDI File."; // 関数間でデータをやり取りするためのObject //

	  var info = {};
	  info.smf = smf; // ヘッダー解析 //

	  parseHeader.call(this, info);

	  if (this.debug) {
	    var syoriTimeS2 = performance.now();
	  } // トラック解析 //


	  parseTrack.call(this, info);

	  if (this.debug) {
	    var syoriTimeS3 = performance.now();
	  } // MIDIイベント解析 //


	  parseEvent.call(this, info); // return用のオブジェクトに情報を代入 //

	  var data = {};
	  data.header = info.header;
	  data.tempoTrack = info.tempoTrack;
	  data.beatTrack = info.beatTrack;
	  data.channels = info.channels;
	  data.songLength = info.songLength;
	  data.cc111Tick = info.cc111Tick;
	  data.cc111Time = info.cc111Time;
	  data.firstNoteOnTiming = info.firstNoteOnTiming;
	  data.firstNoteOnTime = info.firstNoteOnTime;
	  data.lastNoteOffTiming = info.lastNoteOffTiming;
	  data.lastNoteOffTime = info.lastNoteOffTime;

	  if (this.settings.isWebMIDI) {
	    data.messages = info.messages;
	    data.smfData = new Uint8Array(smf); // lastStateを上書きしたsmfをコピー
	  }

	  if (this.debug) {
	    var syoriTimeE = performance.now();
	    console.log("parseSMF time", syoriTimeE - syoriTimeS1);
	    console.log("parseSMF(0/2) time", syoriTimeS2 - syoriTimeS1);
	    console.log("parseSMF(1/2) time", syoriTimeS3 - syoriTimeS2);
	    console.log("parseSMF(2/2) time", syoriTimeE - syoriTimeS3);
	    console.log(data);
	  }

	  return data;
	}

	function startWebMIDI() {
	  var _this = this;

	  var outputs;
	  if (!navigator.requestMIDIAccess) return; // 1回目：ブラウザにMIDIデバイスのフルコントロールを要求する(SysExの使用を要求)
	  // 2回目：MIDIデバイスのフルコントロールがブロックされたら、SysEx無しでMIDIアクセスを要求する

	  var sysEx = this.settings.WebMIDIPortSysEx;

	  var midiAccessSuccess = function midiAccessSuccess(midiAccess) {
	    var _this2 = this;

	    _newArrowCheck(this, _this);

	    outputs = midiAccess.outputs;
	    this.settings.WebMIDIPortOutputs = outputs;
	    var output;

	    if (this.settings.WebMIDIPort == -1) {
	      this.settings.WebMIDIPortOutputs.forEach(function (o) {
	        _newArrowCheck(this, _this2);

	        if (!output) output = o;
	      }.bind(this));
	    } else {
	      output = this.settings.WebMIDIPortOutputs.get(settings.WebMIDIPort);
	    }

	    this.settings.WebMIDIPortOutput = output;
	    this.settings.WebMIDIPortSysEx = sysEx;

	    if (output) {
	      output.open();
	      this.initStatus(); // リセットイベント（GMシステム・オン等）を送るため呼び出す
	    }

	    return outputs;
	  }.bind(this);

	  var _midiAccessFailure = function midiAccessFailure(err) {
	    _newArrowCheck(this, _this);

	    console.log(err);

	    if (sysEx) {
	      sysEx = false;
	      navigator.requestMIDIAccess({
	        sysex: sysEx
	      }).then(midiAccessSuccess)["catch"](_midiAccessFailure);
	    }
	  }.bind(this);

	  navigator.requestMIDIAccess({
	    sysex: sysEx
	  }).then(midiAccessSuccess)["catch"](_midiAccessFailure); // 終了時に鳴らしている音を切る

	  window.addEventListener('unload', function (e) {
	    _newArrowCheck(this, _this);

	    for (var t = 0; t < 16; t++) {
	      this.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);

	      for (var i = 0; i < 128; i++) {
	        this.settings.WebMIDIPortOutput.send([0x80 + t, i, 0]);
	      }
	    }
	  }.bind(this));
	}

	var PicoAudio = /*#__PURE__*/function () {
	  /**
	   * PicoAudioクラスのコンストラクタ
	   * @param {AudioContext} audioContext 
	   * @param {PicoAudio} picoAudio 
	   */
	  function PicoAudio(audioContext, picoAudio) {
	    _classCallCheck(this, PicoAudio);

	    picoAudioConstructor.call(this, audioContext, picoAudio);
	  }
	  /**
	   * 初期化・準備
	   * @param {AudioContext} audioContext 
	   * @param {PicoAudio} picoAudio 
	   */


	  _createClass(PicoAudio, [{
	    key: "init",
	    value: function init$1(audioContext, picoAudio) {
	      return init.call(this, audioContext, picoAudio);
	    }
	    /**
	     * MIDIファイル(SMF)を解析する
	     * @param {Uint8Array} smf MIDIファイルの内容が入ったUint8Arrayオブジェクト
	     * @returns {Object} 再生用の情報が入ったオブジェクト
	     */

	  }, {
	    key: "parseSMF",
	    value: function parseSMF$1(smf) {
	      return parseSMF.call(this, smf);
	    }
	    /**
	     * 再生用のデータをセットする
	     * @param {Object} data PicoAudio.parseSMF()で返されたオブジェクト
	     */

	  }, {
	    key: "setData",
	    value: function setData$1(data) {
	      return setData.call(this, data);
	    }
	    /**
	     * 再生
	     * @param {boolean} _isSongLooping PicoAudio内部で使う引数
	     */

	  }, {
	    key: "play",
	    value: function play$1(_isSongLooping) {
	      return play.call(this, _isSongLooping);
	    }
	    /**
	     * 停止
	     * @param {boolean} _isSongLooping PicoAudio内部で使う引数
	     */

	  }, {
	    key: "stop",
	    value: function stop$1(_isSongLooping) {
	      return stop.call(this, _isSongLooping);
	    }
	    /**
	     * リセット
	     * @param {boolean} _isSongLooping PicoAudio内部で使う引数
	     * @param {boolean} _isLight PicoAudio内部で使う引数
	     */

	  }, {
	    key: "initStatus",
	    value: function initStatus$1(_isSongLooping, _isLight) {
	      return initStatus.call(this, _isSongLooping, _isLight);
	    } // 時関関係 //

	    /**
	     * tickからtime(秒)を求める
	     * @param {number} tick
	     * @returns {number} time(秒)
	     */

	  }, {
	    key: "getTime",
	    value: function getTime(tick) {
	      return getTime$1.call(this, tick);
	    }
	    /**
	     * time(秒)からtickを求める
	     * @param {number} time
	     * @returns {number} tick
	     */

	  }, {
	    key: "getTiming",
	    value: function getTiming$1(time) {
	      return getTiming.call(this, time);
	    } // 再生・音源関係 //

	    /**
	     * 再生処理（Web Audio API の oscillator等で音を鳴らす）
	     * @param {Object} option 
	     * @param {boolean} isDrum 
	     * @param {boolean} isExpression 
	     * @param {boolean} nonChannel 
	     * @param {boolean} nonStop 
	     * @returns {Object} AudioNodeやパラメータを返す
	     */

	  }, {
	    key: "createBaseNote",
	    value: function createBaseNote$1(option, isDrum, isExpression, nonChannel, nonStop) {
	      return createBaseNote.call(this, option, isDrum, isExpression, nonChannel, nonStop);
	    }
	    /**
	     * 音源（パーカッション以外）
	     * @param {Object} option 
	     * @returns {Object} 音をストップさせる関数を返す
	     */

	  }, {
	    key: "createNote",
	    value: function createNote$1(option) {
	      return createNote.call(this, option);
	    }
	    /**
	     * パーカッション音源
	     * @param {Object} option 
	     * @returns {Object} 音をストップさせる関数を返す
	     */

	  }, {
	    key: "createPercussionNote",
	    value: function createPercussionNote$1(option) {
	      return createPercussionNote.call(this, option);
	    } // 停止管理関係 //

	    /**
	     * 各々のNoteの音停止処理
	     * @param {Object} tar 
	     * @param {number} time 
	     * @param {Object} stopGainNode 
	     * @param {boolean} isNoiseCut 
	     */

	  }, {
	    key: "stopAudioNode",
	    value: function stopAudioNode$1(tar, time, stopGainNode, isNoiseCut) {
	      return stopAudioNode.call(this, tar, time, stopGainNode, isNoiseCut);
	    }
	    /**
	     * stop()するときに実行するコールバック等を登録
	     * @param {Object} tar 
	     */

	  }, {
	    key: "pushFunc",
	    value: function pushFunc$1(tar) {
	      return pushFunc.call(this, tar);
	    }
	    /**
	     * pushFunc()で予約したコールバック等を削除する
	     * @param {Object} tar1 
	     * @param {Object} tar2 
	     */

	  }, {
	    key: "clearFunc",
	    value: function clearFunc$1(tar1, tar2) {
	      return clearFunc.call(this, tar1, tar2);
	    }
	    /**
	     * Web MIDI API
	     */

	  }, {
	    key: "startWebMIDI",
	    value: function startWebMIDI$1() {
	      return startWebMIDI.call(this);
	    }
	    /**
	     * パフォーマンス計測
	     */

	  }, {
	    key: "measurePerformanceReverb",
	    value: function measurePerformanceReverb() {
	      return PerformanceUtil.measureReverb.call(this);
	    } // インターフェース関係 //

	  }, {
	    key: "addEventListener",
	    value: function addEventListener(type, func) {
	      // type = EventName (play, stop, noteOn...)
	      this.events.push({
	        type: type,
	        func: func
	      });
	    }
	  }, {
	    key: "fireEvent",
	    value: function fireEvent(type, option) {
	      var _this = this;

	      this.events.forEach(function (event) {
	        _newArrowCheck(this, _this);

	        if (event.type == type) {
	          try {
	            event.func(option);
	          } catch (e) {
	            console.log(e);
	          }
	        }
	      }.bind(this));
	    }
	  }, {
	    key: "getChannels",
	    value: function getChannels() {
	      return this.channels;
	    }
	  }, {
	    key: "setChannels",
	    value: function setChannels(channels) {
	      var _this2 = this;

	      channels.forEach(function (channel, idx) {
	        _newArrowCheck(this, _this2);

	        this.channels[idx] = channel;
	      }.bind(this));
	    }
	  }, {
	    key: "initChannels",
	    value: function initChannels() {
	      for (var i = 0; i < 16; i++) {
	        this.channels[i] = [0, 0, 1];
	      }
	    }
	  }, {
	    key: "getMasterVolume",
	    value: function getMasterVolume() {
	      return this.settings.masterVolume;
	    }
	  }, {
	    key: "setMasterVolume",
	    value: function setMasterVolume(volume) {
	      this.settings.masterVolume = volume;

	      if (this.isStarted) {
	        this.masterGainNode.gain.value = this.settings.masterVolume;
	      }
	    }
	  }, {
	    key: "isLoop",
	    value: function isLoop() {
	      return this.settings.loop;
	    }
	  }, {
	    key: "setLoop",
	    value: function setLoop(loop) {
	      this.settings.loop = loop;
	    }
	  }, {
	    key: "isWebMIDI",
	    value: function isWebMIDI() {
	      return this.settings.isWebMIDI;
	    }
	  }, {
	    key: "setWebMIDI",
	    value: function setWebMIDI(enable) {
	      this.settings.isWebMIDI = enable;
	    }
	  }, {
	    key: "isCC111",
	    value: function isCC111() {
	      return this.settings.isCC111;
	    }
	  }, {
	    key: "setCC111",
	    value: function setCC111(enable) {
	      this.settings.isCC111 = enable;
	    }
	  }, {
	    key: "setStartTime",
	    value: function setStartTime(offset) {
	      this.states.startTime -= offset;
	    }
	  }, {
	    key: "setOnSongEndListener",
	    value: function setOnSongEndListener(listener) {
	      this.onSongEndListener = listener;
	    }
	  }, {
	    key: "onSongEnd",
	    value: function onSongEnd() {
	      if (this.onSongEndListener) {
	        var isStopFunc = this.onSongEndListener();
	        if (isStopFunc) return;
	      }

	      if (this.settings.loop) {
	        this.initStatus(true);

	        if (this.settings.isCC111 && this.cc111Time != -1) {
	          this.setStartTime(this.cc111Time);
	        }

	        this.play(true);
	      }
	    }
	  }, {
	    key: "isReverb",
	    value: function isReverb() {
	      return this.settings.isReverb;
	    }
	  }, {
	    key: "setReverb",
	    value: function setReverb(enable) {
	      this.settings.isReverb = enable;
	    }
	  }, {
	    key: "getReverbVolume",
	    value: function getReverbVolume() {
	      return this.settings.reverbVolume;
	    }
	  }, {
	    key: "setReverbVolume",
	    value: function setReverbVolume(volume) {
	      this.settings.reverbVolume = volume;
	    }
	  }, {
	    key: "isChorus",
	    value: function isChorus() {
	      return this.settings.isChorus;
	    }
	  }, {
	    key: "setChorus",
	    value: function setChorus(enable) {
	      this.settings.isChorus = enable;
	    }
	  }, {
	    key: "getChorusVolume",
	    value: function getChorusVolume() {
	      return this.settings.chorusVolume;
	    }
	  }, {
	    key: "setChorusVolume",
	    value: function setChorusVolume(volume) {
	      this.settings.chorusVolume = volume;
	    }
	  }]);

	  return PicoAudio;
	}(); // // PicoAudioをグローバル変数に登録
	// window.PicoAudio = PicoAudio;

	return PicoAudio;

})));
