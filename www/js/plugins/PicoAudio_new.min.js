(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PicoAudio = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


	var global_1 = // eslint-disable-next-line no-undef
	check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
	Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, {
	    get: function () {
	      return 7;
	    }
	  })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
	  1: 2
	}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;
	var objectPropertyIsEnumerable = {
	  f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string

	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () {
	      return 7;
	    }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) {
	    /* empty */
	  }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};
	var objectGetOwnPropertyDescriptor = {
	  f: f$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  }

	  return it;
	};

	var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty

	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) {
	    /* empty */
	  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var objectDefineProperty = {
	  f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  }

	  return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store;

	var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap = global_1.WeakMap;
	var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

	var shared = createCommonjsModule(function (module) {
	  (module.exports = function (key, value) {
	    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	  })('versions', []).push({
	    version: '3.6.5',
	    mode:  'global',
	    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	  });
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$1 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;

	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    }

	    return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$1();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;

	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };

	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;

	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };

	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	  var getInternalState = internalState.get;
	  var enforceInternalState = internalState.enforce;
	  var TEMPLATE = String(String).split('String');
	  (module.exports = function (O, key, value, options) {
	    var unsafe = options ? !!options.unsafe : false;
	    var simple = options ? !!options.enumerable : false;
	    var noTargetGet = options ? !!options.noTargetGet : false;

	    if (typeof value == 'function') {
	      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	    }

	    if (O === global_1) {
	      if (simple) O[key] = value;else setGlobal(key, value);
	      return;
	    } else if (!unsafe) {
	      delete O[key];
	    } else if (!noTargetGet && O[key]) {
	      simple = true;
	    }

	    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	  })(Function.prototype, 'toString', function toString() {
	    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	  });
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor; // `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger

	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min; // `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength

	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min; // Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value; // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare

	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++]; // eslint-disable-next-line no-self-compare

	      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    }
	    return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;

	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }

	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
	  f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;
	var objectGetOwnPropertySymbols = {
	  f: f$4
	};

	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/

	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }

	  if (target) for (key in source) {
	    sourceProperty = source[key];

	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];

	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    } // add a flag to not completely full polyfills


	    if (options.sham || targetProperty && targetProperty.sham) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    } // extend global


	    redefine(target, key, sourceProperty, options);
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  }

	  return it;
	};

	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;

	  switch (length) {
	    case 0:
	      return function () {
	        return fn.call(that);
	      };

	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };

	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };

	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }

	  return function ()
	  /* ...args */
	  {
	    return fn.apply(that, arguments);
	  };
	};

	// https://tc39.github.io/ecma262/#sec-toobject

	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// https://tc39.github.io/ecma262/#sec-isarray

	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
	&& !Symbol.sham // eslint-disable-next-line no-undef
	&& typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  }

	  return WellKnownSymbolsStore[name];
	};

	var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

	var arraySpeciesCreate = function (originalArray, length) {
	  var C;

	  if (isArray(originalArray)) {
	    C = originalArray.constructor; // cross-realm fallback

	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }

	  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;

	    for (; length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);

	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	            case 3:
	              return true;
	            // some

	            case 5:
	              return value;
	            // find

	            case 6:
	              return index;
	            // findIndex

	            case 2:
	              push.call(target, value);
	            // filter
	          } else if (IS_EVERY) return false; // every
	      }
	    }

	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () {
	      throw 1;
	    }, 1);
	  });
	};

	var defineProperty = Object.defineProperty;
	var cache = {};

	var thrower = function (it) {
	  throw it;
	};

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;
	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = {
	      length: -1
	    };
	    if (ACCESSORS) defineProperty(O, 1, {
	      enumerable: true,
	      get: thrower
	    });else O[1] = 1;
	    method.call(O, argument0, argument1);
	  });
	};

	var $forEach = arrayIteration.forEach;
	var STRICT_METHOD = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

	var arrayForEach = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn
	/* , thisArg */
	) {
	  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach


	_export({
	  target: 'Array',
	  proto: true,
	  forced: [].forEach != arrayForEach
	}, {
	  forEach: arrayForEach
	});

	var slice = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  }

	  return factories[argsLength](C, args);
	}; // `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind


	var functionBind = Function.bind || function bind(that
	/* , ...args */
	) {
	  var fn = aFunction$1(this);
	  var partArgs = slice.call(arguments, 1);

	  var boundFunction = function bound()
	  /* args... */
	  {
	    var args = partArgs.concat(slice.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };

	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// https://tc39.github.io/ecma262/#sec-function.prototype.bind

	_export({
	  target: 'Function',
	  proto: true
	}, {
	  bind: functionBind
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _newArrowCheck(innerThis, boundThis) {
	  if (innerThis !== boundThis) {
	    throw new TypeError("Cannot instantiate an arrow function");
	  }
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  return function () {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (_isNativeReflectConstruct()) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	// https://tc39.github.io/ecma262/#sec-date.now

	_export({
	  target: 'Date',
	  stat: true
	}, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var DatePrototype = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var nativeDateToString = DatePrototype[TO_STRING];
	var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DatePrototype, TO_STRING, function toString() {
	    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

	    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
	  });
	}

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  }

	  return it;
	};

	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.

	/* eslint-disable no-proto */

	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;

	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {
	    /* empty */
	  }

	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if ( // it can work only with native `setPrototypeOf`
	  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	// https://tc39.github.io/ecma262/#sec-object.keys

	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// https://tc39.github.io/ecma262/#sec-object.defineproperties

	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;

	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);

	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () {
	  /* empty */
	};

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak

	  return temp;
	}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	}; // Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug


	var activeXDocument;

	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) {
	    /* ignore */
	  }

	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;

	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];

	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true; // `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create

	var objectCreate = Object.create || function create(O, Properties) {
	  var result;

	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();

	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

	var createMethod$2 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$2(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$2(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$2(3)
	};

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$1 = objectDefineProperty.f;
	var trim = stringTrim.trim;
	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

	var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber

	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;

	  if (typeof it == 'string' && it.length > 2) {
	    it = trim(it);
	    first = it.charCodeAt(0);

	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:
	        case 98:
	          radix = 2;
	          maxCode = 49;
	          break;
	        // fast equal of /^0b[01]+$/i

	        case 79:
	        case 111:
	          radix = 8;
	          maxCode = 55;
	          break;
	        // fast equal of /^0o[0-7]+$/i

	        default:
	          return +it;
	      }

	      digits = it.slice(2);
	      length = digits.length;

	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols

	        if (code < 48 || code > maxCode) return NaN;
	      }

	      return parseInt(digits, radix);
	    }
	  }

	  return +it;
	}; // `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor


	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
	    && (BROKEN_CLASSOF ? fails(function () {
	      NumberPrototype.valueOf.call(dummy);
	    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };

	  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
	    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
	      defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
	    }
	  }

	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer

	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	function picoAudioConstructor(_audioContext, _picoAudio) {
	  var _this = this;

	  this.debug = true;
	  this.isStarted = false;
	  this.isPlayed = false;
	  this.isTonyu2 = true;
	  this.settings = {
	    masterVolume: 1,
	    generateVolume: 0.15,
	    tempo: 120,
	    basePitch: 440,
	    resolution: 480,
	    isWebMIDI: false,
	    WebMIDIPortOutputs: null,
	    WebMIDIPortOutput: null,
	    WebMIDIPort: -1,
	    // -1:auto
	    WebMIDIPortSysEx: true,
	    // MIDIããã¤ã¹ã®ãã«ã³ã³ãã­ã¼ã«ããããã©ããï¼SysExãä½¿ããã©ããï¼(httpsãããªãã¨ä½¿ããªã)
	    isReverb: true,
	    // ãªãã¼ãONã«ããã
	    reverbVolume: 1.5,
	    isChorus: true,
	    chorusVolume: 0.5,
	    isCC111: true,
	    loop: false,
	    isSkipBeginning: this.isTonyu2,
	    // åé ­ã®ä½ç½ãã¹ã­ãã(Tonyu2ã¯true)
	    isSkipEnding: true,
	    // æ«å°¾ã®ç©ºç½ãã¹ã­ãã
	    holdOnValue: 64,
	    maxPoly: -1,
	    // åæçºé³æ° -1:infinity
	    maxPercPoly: -1,
	    // åæçºé³æ°(ãã¼ã«ãã·ã§ã³) -1:infinity
	    isOfflineRendering: false,
	    // TODO æ¼å¥ãã¼ã¿ãä½æãã¦ããæ¼å¥ãã
	    isSameDrumSoundOverlap: false // åããã©ã ã®é³ãéãªããã¨ãè¨±å®¹ããã

	  };
	  this.events = [];
	  this.trigger = {
	    isNoteTrigger: true,
	    play: function play() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    stop: function stop() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    noteOn: function noteOn() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    noteOff: function noteOff() {
	      _newArrowCheck(this, _this);
	    }.bind(this),
	    songEnd: function songEnd() {
	      _newArrowCheck(this, _this);
	    }.bind(this)
	  };
	  this.states = {
	    isPlaying: false,
	    startTime: 0,
	    stopTime: 0,
	    stopFuncs: [],
	    webMIDIWaitState: null,
	    webMIDIStopTime: 0,
	    playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	    updateBufTime: 100,
	    updateBufMaxTime: 350,
	    updateIntervalTime: 0,
	    latencyLimitTime: 0
	  };
	  this.hashedDataList = [];
	  this.hashedMessageList = [];
	  this.playData = null;
	  this.channels = [];
	  this.tempoTrack = [{
	    timing: 0,
	    value: 120
	  }, {
	    timing: 0,
	    value: 120
	  }];
	  this.cc111Time = -1;
	  this.onSongEndListener = null; // ãã£ã³ãã«ã®è¨­å®å¤ï¼é³è², æ¸è¡°, é³éï¼ //

	  for (var i = 0; i < 17; i++) {
	    this.channels.push([0, 0, 1]);
	  } // AudioContextãããå ´åã¯ãã®ã¾ã¾åæåããªããã°AudioContextãç¨ããåæåãinit()ã§


	  if (_audioContext) {
	    this.init(_audioContext, _picoAudio);
	  } // Fallback
	  // Unsupport performance.now()


	  if (typeof performance === "undefined") {
	    window.performance = {};
	  }

	  if (!performance.now) {
	    performance.now = function () {
	      _newArrowCheck(this, _this);

	      return Date.now();
	    }.bind(this);
	  } // Unsupport Number.MAX_SAFE_INTEGER


	  if (!Number.MAX_SAFE_INTEGER) {
	    Number.MAX_SAFE_INTEGER = 9007199254740991;
	  }
	}

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	} // add a key to Array.prototype[@@unscopables]


	var addToUnscopables = function (key) {
	  ArrayPrototype[UNSCOPABLES][key] = true;
	};

	var iterators = {};

	var correctPrototypeGetter = !fails(function () {
	  function F() {
	    /* empty */
	  }

	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof

	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }

	  return O instanceof Object ? ObjectPrototype : null;
	};

	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () {
	  return this;
	}; // `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

	if ( !has(IteratorPrototype, ITERATOR)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var defineProperty$2 = objectDefineProperty.f;
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$2(it, TO_STRING_TAG, {
	      configurable: true,
	      value: TAG
	    });
	  }
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

	var returnThis$1 = function () {
	  return this;
	};

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
	    next: createPropertyDescriptor(1, next)
	  });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () {
	  return this;
	};

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

	    switch (KIND) {
	      case KEYS:
	        return function keys() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case VALUES:
	        return function values() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case ENTRIES:
	        return function entries() {
	          return new IteratorConstructor(this, KIND);
	        };
	    }

	    return function () {
	      return new IteratorConstructor(this);
	    };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY; // fix native

	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
	        }
	      } // Set @@toStringTag to native iterators


	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  } // fix Array#{values, @@iterator}.name in V8 / FF


	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;

	    defaultIterator = function values() {
	      return nativeIterator.call(this);
	    };
	  } // define iterator


	  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
	  }

	  iterators[NAME] = defaultIterator; // export additional methods

	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({
	      target: NAME,
	      proto: true,
	      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
	    }, methods);
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator

	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    // target
	    index: 0,
	    // next index
	    kind: kind // kind

	  }); // `%ArrayIteratorPrototype%.next` method
	  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;

	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return {
	      value: undefined,
	      done: true
	    };
	  }

	  if (kind == 'keys') return {
	    value: index,
	    done: false
	  };
	  if (kind == 'values') return {
	    value: target[index],
	    done: false
	  };
	  return {
	    value: [index, target[index]],
	    done: false
	  };
	}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

	iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);

	  return target;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  }

	  return it;
	};

	// https://tc39.github.io/ecma262/#sec-toindex

	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = 1 / 0;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor$1 = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = new Array(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs(number); // eslint-disable-next-line no-self-compare

	  if (number != number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$1(log(number) / LN2);

	    if (number * (c = pow(2, -exponent)) < 1) {
	      exponent--;
	      c *= 2;
	    }

	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow(2, 1 - eBias);
	    }

	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }

	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
	      exponent = 0;
	    }
	  }

	  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);

	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;

	  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);

	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;

	  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);

	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;

	  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);

	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity : Infinity;
	  } else {
	    mantissa = mantissa + pow(2, mantissaLength);
	    exponent = exponent - eBias;
	  }

	  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	// https://tc39.github.io/ecma262/#sec-array.prototype.fill


	var arrayFill = function fill(value
	/* , start = 0, end = @length */
	) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

	  while (endPos > index) O[index++] = value;

	  return O;
	};

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var defineProperty$3 = objectDefineProperty.f;
	var getInternalState$1 = internalState.get;
	var setInternalState$1 = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$1 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var $DataView = global_1[DATA_VIEW];
	var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$1];
	var ObjectPrototype$1 = Object.prototype;
	var RangeError$1 = global_1.RangeError;
	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$3(Constructor[PROTOTYPE$1], key, {
	    get: function () {
	      return getInternalState$1(this)[key];
	    }
	  });
	};

	var get$1 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$1(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$1(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = bytes.slice(start, start + count);
	  return isLittleEndian ? pack : pack.reverse();
	};

	var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$1(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$1(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);

	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    setInternalState$1(this, {
	      bytes: arrayFill.call(new Array(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = getInternalState$1(buffer).byteLength;
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState$1(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });

	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll($DataView[PROTOTYPE$1], {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new NativeArrayBuffer(); // eslint-disable-line no-new

	    new NativeArrayBuffer(1.5); // eslint-disable-line no-new

	    new NativeArrayBuffer(NaN); // eslint-disable-line no-new

	    return NativeArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new NativeArrayBuffer(toIndex(length));
	    };

	    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1] = NativeArrayBuffer[PROTOTYPE$1];

	    for (var keys$2 = getOwnPropertyNames$1(NativeArrayBuffer), j$1 = 0, key$1; keys$2.length > j$1;) {
	      if (!((key$1 = keys$2[j$1++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
	      }
	    }

	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  } // WebKit bug - the same parent prototype for typed arrays and data view


	  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$1) {
	    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$1);
	  } // iOS Safari 7.x bug


	  var testView = new $DataView(new $ArrayBuffer(2));
	  var nativeSetInt8 = $DataViewPrototype.setInt8;
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, {
	    unsafe: true
	  });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var SPECIES$1 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor

	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var ArrayBuffer$1 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var nativeArrayBufferSlice = ArrayBuffer$1.prototype.slice;
	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$1(2).slice(1, undefined).byteLength;
	}); // `ArrayBuffer.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

	_export({
	  target: 'ArrayBuffer',
	  proto: true,
	  unsafe: true,
	  forced: INCORRECT_SLICE
	}, {
	  slice: function slice(start, end) {
	    if (nativeArrayBufferSlice !== undefined && end === undefined) {
	      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
	    }

	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$1))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;

	    while (first < fin) {
	      viewTarget.setUint8(index++, viewSource.getUint8(first++));
	    }

	    return result;
	  }
	});

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG$1] = 'z';
	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag'); // ES3 wrong here

	var CORRECT_ARGUMENTS = classofRaw(function () {
	  return arguments;
	}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) {
	    /* empty */
	  }
	}; // getting tag from ES6+ `Object.prototype.toString`


	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
	  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
	  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, {
	    unsafe: true
	  });
	}

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return {
	        done: !!called++
	      };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };

	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  }; // eslint-disable-next-line no-throw-literal


	  Array.from(iteratorWithReturn, function () {
	    throw 2;
	  });
	} catch (error) {
	  /* empty */
	}

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;

	  try {
	    var object = {};

	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return {
	            done: ITERATION_SUPPORT = true
	          };
	        }
	      };
	    };

	    exec(object);
	  } catch (error) {
	    /* empty */
	  }

	  return ITERATION_SUPPORT;
	};

	var defineProperty$4 = objectDefineProperty.f;
	var Int8Array$1 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$2 = Object.prototype;
	var isPrototypeOf = ObjectPrototype$2.isPrototypeOf;
	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME;
	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var isView = function isView(it) {
	  var klass = classof(it);
	  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
	};

	var isTypedArray = function (it) {
	  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
	};

	var aTypedArray = function (it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError('Target is not a typed array');
	};

	var aTypedArrayConstructor = function (C) {
	  if (objectSetPrototypeOf) {
	    if (isPrototypeOf.call(TypedArray, C)) return C;
	  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
	    var TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
	      return C;
	    }
	  }

	  throw TypeError('Target is not a typed array constructor');
	};

	var exportTypedArrayMethod = function (KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
	      delete TypedArrayConstructor.prototype[KEY];
	    }
	  }

	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;

	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];

	      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
	        delete TypedArrayConstructor[KEY];
	      }
	    }

	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
	      } catch (error) {
	        /* empty */
	      }
	    } else return;
	  }

	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME in TypedArrayConstructorsList) {
	  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
	} // WebKit bug - typed arrays constructors prototype is Object.prototype


	if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow
	  TypedArray = function TypedArray() {
	    throw TypeError('Incorrect invocation');
	  };

	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
	  }
	} // WebKit bug - one more object in Uint8ClampedArray prototype chain


	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}

	if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$4(TypedArrayPrototype, TO_STRING_TAG$3, {
	    get: function () {
	      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
	    }
	  });

	  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
	    createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	/* eslint-disable no-new */

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var ArrayBuffer$2 = global_1.ArrayBuffer;
	var Int8Array$2 = global_1.Int8Array;
	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
	  Int8Array$2(1);
	}) || !fails(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$2(2), 1, undefined).length !== 1;
	});

	var toPositiveInteger = function (it) {
	  var result = toInteger(it);
	  if (result < 0) throw RangeError("The argument can't be less than 0");
	  return result;
	};

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError('Wrong offset');
	  return offset;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || iterators[classof(it)];
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$4] === it);
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source
	/* , mapfn, thisArg */
	) {
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;

	  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    O = [];

	    while (!(step = next.call(iterator)).done) {
	      O.push(step.value);
	    }
	  }

	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2], 2);
	  }

	  length = toLength(O.length);
	  result = new (aTypedArrayConstructor$1(this))(length);

	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }

	  return result;
	};

	var SPECIES$2 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$2]) {
	    defineProperty(Constructor, SPECIES$2, {
	      configurable: true,
	      get: function () {
	        return this;
	      }
	    });
	  }
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {

	  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	  var forEach = arrayIteration.forEach;
	  var getInternalState = internalState.get;
	  var setInternalState = internalState.set;
	  var nativeDefineProperty = objectDefineProperty.f;
	  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  var round = Math.round;
	  var RangeError = global_1.RangeError;
	  var ArrayBuffer = arrayBuffer.ArrayBuffer;
	  var DataView = arrayBuffer.DataView;
	  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	  var TypedArray = arrayBufferViewCore.TypedArray;
	  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	  var isTypedArray = arrayBufferViewCore.isTypedArray;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var WRONG_LENGTH = 'Wrong length';

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = new (aTypedArrayConstructor(C))(length);

	    while (length > index) result[index] = list[index++];

	    return result;
	  };

	  var addGetter = function (it, key) {
	    nativeDefineProperty(it, key, {
	      get: function () {
	        return getInternalState(this)[key];
	      }
	    });
	  };

	  var isArrayBuffer = function (it) {
	    var klass;
	    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	  };

	  var isTypedArrayIndex = function (target, key) {
	    return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
	  };

	  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
	  };

	  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
	      target[key] = descriptor.value;
	      return target;
	    }

	    return nativeDefineProperty(target, key, descriptor);
	  };

	  if (descriptors) {
	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	      objectDefineProperty.f = wrappedDefineProperty;
	      addGetter(TypedArrayPrototype, 'buffer');
	      addGetter(TypedArrayPrototype, 'byteOffset');
	      addGetter(TypedArrayPrototype, 'byteLength');
	      addGetter(TypedArrayPrototype, 'length');
	    }

	    _export({
	      target: 'Object',
	      stat: true,
	      forced: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, {
	      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	      defineProperty: wrappedDefineProperty
	    });

	    module.exports = function (TYPE, wrapper, CLAMPED) {
	      var BYTES = TYPE.match(/\d+$/)[0] / 8;
	      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	      var GETTER = 'get' + TYPE;
	      var SETTER = 'set' + TYPE;
	      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	      var TypedArrayConstructor = NativeTypedArrayConstructor;
	      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	      var exported = {};

	      var getter = function (that, index) {
	        var data = getInternalState(that);
	        return data.view[GETTER](index * BYTES + data.byteOffset, true);
	      };

	      var setter = function (that, index, value) {
	        var data = getInternalState(that);
	        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	      };

	      var addElement = function (that, index) {
	        nativeDefineProperty(that, index, {
	          get: function () {
	            return getter(this, index);
	          },
	          set: function (value) {
	            return setter(this, index, value);
	          },
	          enumerable: true
	        });
	      };

	      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
	          var index = 0;
	          var byteOffset = 0;
	          var buffer, byteLength, length;

	          if (!isObject(data)) {
	            length = toIndex(data);
	            byteLength = length * BYTES;
	            buffer = new ArrayBuffer(byteLength);
	          } else if (isArrayBuffer(data)) {
	            buffer = data;
	            byteOffset = toOffset(offset, BYTES);
	            var $len = data.byteLength;

	            if ($length === undefined) {
	              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	              byteLength = $len - byteOffset;
	              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	            } else {
	              byteLength = toLength($length) * BYTES;
	              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	            }

	            length = byteLength / BYTES;
	          } else if (isTypedArray(data)) {
	            return fromList(TypedArrayConstructor, data);
	          } else {
	            return typedArrayFrom.call(TypedArrayConstructor, data);
	          }

	          setInternalState(that, {
	            buffer: buffer,
	            byteOffset: byteOffset,
	            byteLength: byteLength,
	            length: length,
	            view: new DataView(buffer)
	          });

	          while (index < length) addElement(that, index++);
	        });
	        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	      } else if (typedArrayConstructorsRequireWrappers) {
	        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
	          return inheritIfRequired(function () {
	            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	            if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
	            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	            return typedArrayFrom.call(TypedArrayConstructor, data);
	          }(), dummy, TypedArrayConstructor);
	        });
	        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	          if (!(key in TypedArrayConstructor)) {
	            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	          }
	        });
	        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	      }

	      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	      }

	      if (TYPED_ARRAY_TAG) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	      }

	      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
	      _export({
	        global: true,
	        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
	        sham: !NATIVE_ARRAY_BUFFER_VIEWS
	      }, exported);

	      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	      }

	      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	      }

	      setSpecies(CONSTRUCTOR_NAME);
	    };
	  } else module.exports = function () {
	    /* empty */
	  };
	});

	// https://tc39.github.io/ecma262/#sec-typedarray-objects

	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var min$2 = Math.min; // `Array.prototype.copyWithin` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

	var arrayCopyWithin = [].copyWithin || function copyWithin(target
	/* = 0 */
	, start
	/* = 0, end = @length */
	) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;

	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }

	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }

	  return O;
	};

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

	exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start
	/* , end */
	) {
	  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every = arrayIteration.every;
	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

	exportTypedArrayMethod$2('every', function every(callbackfn
	/* , thisArg */
	) {
	  return $every(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$3('fill', function fill(value
	/* , start, end */
	) {
	  return arrayFill.apply(aTypedArray$3(this), arguments);
	});

	var $filter = arrayIteration.filter;
	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

	exportTypedArrayMethod$4('filter', function filter(callbackfn
	/* , thisArg */
	) {
	  var list = $filter(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$2(C))(length);

	  while (length > index) result[index] = list[index++];

	  return result;
	});

	var $find = arrayIteration.find;
	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

	exportTypedArrayMethod$5('find', function find(predicate
	/* , thisArg */
	) {
	  return $find(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex = arrayIteration.findIndex;
	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

	exportTypedArrayMethod$6('findIndex', function findIndex(predicate
	/* , thisArg */
	) {
	  return $findIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$1 = arrayIteration.forEach;
	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

	exportTypedArrayMethod$7('forEach', function forEach(callbackfn
	/* , thisArg */
	) {
	  $forEach$1(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $includes = arrayIncludes.includes;
	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

	exportTypedArrayMethod$8('includes', function includes(searchElement
	/* , fromIndex */
	) {
	  return $includes(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf = arrayIncludes.indexOf;
	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

	exportTypedArrayMethod$9('indexOf', function indexOf(searchElement
	/* , fromIndex */
	) {
	  return $indexOf(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var Uint8Array$1 = global_1.Uint8Array;
	var arrayValues = es_array_iterator.values;
	var arrayKeys = es_array_iterator.keys;
	var arrayEntries = es_array_iterator.entries;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
	var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$5];
	var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

	var typedArrayValues = function values() {
	  return arrayValues.call(aTypedArray$a(this));
	}; // `%TypedArray%.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


	exportTypedArrayMethod$a('entries', function entries() {
	  return arrayEntries.call(aTypedArray$a(this));
	}); // `%TypedArray%.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

	exportTypedArrayMethod$a('keys', function keys() {
	  return arrayKeys.call(aTypedArray$a(this));
	}); // `%TypedArray%.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

	exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

	exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = [].join; // `%TypedArray%.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$b('join', function join(separator) {
	  return $join.apply(aTypedArray$b(this), arguments);
	});

	var min$3 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$1 = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('indexOf', {
	  ACCESSORS: true,
	  1: 0
	});
	var FORCED = NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$1; // `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

	var arrayLastIndexOf = FORCED ? function lastIndexOf(searchElement
	/* , fromIndex = @[*-1] */
	) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
	  if (index < 0) index = length + index;

	  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;

	  return -1;
	} : nativeLastIndexOf;

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
	// eslint-disable-next-line no-unused-vars

	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement
	/* , fromIndex */
	) {
	  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
	});

	var $map = arrayIteration.map;
	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

	exportTypedArrayMethod$d('map', function map(mapfn
	/* , thisArg */
	) {
	  return $map(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
	  });
	});

	var createMethod$3 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }

	      index += i;

	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }

	    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }

	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$3(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$3(true)
	};

	var $reduce = arrayReduce.left;
	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

	exportTypedArrayMethod$e('reduce', function reduce(callbackfn
	/* , initialValue */
	) {
	  return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight = arrayReduce.right;
	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

	exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn
	/* , initialValue */
	) {
	  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$2 = Math.floor; // `%TypedArray%.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

	exportTypedArrayMethod$g('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$2(length / 2);
	  var index = 0;
	  var value;

	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  }

	  return that;
	});

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
	var FORCED$1 = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).set({});
	}); // `%TypedArray%.prototype.set` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

	exportTypedArrayMethod$h('set', function set(arrayLike
	/* , offset */
	) {
	  aTypedArray$h(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var length = this.length;
	  var src = toObject(arrayLike);
	  var len = toLength(src.length);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');

	  while (index < len) this[offset + index] = src[index++];
	}, FORCED$1);

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
	var $slice = [].slice;
	var FORCED$2 = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).slice();
	}); // `%TypedArray%.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

	exportTypedArrayMethod$i('slice', function slice(start, end) {
	  var list = $slice.call(aTypedArray$i(this), start, end);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$4(C))(length);

	  while (length > index) result[index] = list[index++];

	  return result;
	}, FORCED$2);

	var $some = arrayIteration.some;
	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

	exportTypedArrayMethod$j('some', function some(callbackfn
	/* , thisArg */
	) {
	  return $some(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
	var $sort = [].sort; // `%TypedArray%.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

	exportTypedArrayMethod$k('sort', function sort(comparefn) {
	  return $sort.call(aTypedArray$k(this), comparefn);
	});

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

	exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
	  var O = aTypedArray$l(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
	});

	var Int8Array$3 = global_1.Int8Array;
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;
	var $slice$1 = [].slice; // iOS Safari 6.x fails here

	var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
	  $toLocaleString.call(new Int8Array$3(1));
	});
	var FORCED$3 = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$3.prototype.toLocaleString.call([1, 2]);
	}); // `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

	exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
	  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
	}, FORCED$3);

	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;
	var Uint8Array$2 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
	var arrayToString = [].toString;
	var arrayJoin = [].join;

	if (fails(function () {
	  arrayToString.call({});
	})) {
	  arrayToString = function toString() {
	    return arrayJoin.call(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring

	exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	/**
	 * åºå®ãã¿ã¼ã³ã®ä¹±æ°ãæä¾ããã¯ã©ã¹
	 */
	var RandomUtil = /*#__PURE__*/function () {
	  function RandomUtil() {
	    _classCallCheck(this, RandomUtil);
	  }

	  _createClass(RandomUtil, null, [{
	    key: "resetSeed",

	    /**
	     * ä¹±æ°ã®ã·ã¼ãå¤ããªã»ãããã
	     */
	    value: function resetSeed() {
	      this.init = true;
	      this.x = 123456789;
	      this.y = 362436069;
	      this.z = 521288629;
	      this.w = 8867512;
	    }
	    /**
	     * ä¹±æ°ãè¿ã
	     * 
	     *     Math.random() ã¨éããæ¯ååºå®ãã¿ã¼ã³ã§ä¹±æ°ãè¿ããã
	     * Xorshiftã¢ã«ã´ãªãºã 
	     * @returns {number} ä¹±æ°
	     */

	  }, {
	    key: "random",
	    value: function random() {
	      if (!this.init) this.resetSeed();
	      var t = this.x ^ this.x << 11;
	      this.x = this.y;
	      this.y = this.z;
	      this.z = this.w;
	      var r = this.w = this.w ^ this.w >>> 19 ^ (t ^ t >>> 8);
	      r = Math.abs(r) / 2147483648 % 2;
	      return r;
	    }
	  }]);

	  return RandomUtil;
	}();

	var ceil$1 = Math.ceil;
	var floor$3 = Math.floor; // `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc

	_export({
	  target: 'Math',
	  stat: true
	}, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$3 : ceil$1)(it);
	  }
	});

	/**
	 * è£éãæä¾ããã¯ã©ã¹
	 */
	var InterpolationUtil = /*#__PURE__*/function () {
	  function InterpolationUtil() {
	    _classCallCheck(this, InterpolationUtil);
	  }

	  _createClass(InterpolationUtil, null, [{
	    key: "lerpWave",

	    /**
	     * æ³¢å½¢ãç·å½¢è£éãã
	     * @param {AudioBuffer} buffer è£éçµæãå¥ããAudioBuffer
	     * @param {Array} vtBufs ä»®æ³é³æºã®éå([Float32Array, Float32Array])
	     */
	    value: function lerpWave(buffer, vtBufs) {
	      // ä»®æ³ãµã³ãã«ã¬ã¼ãé³æºãæ¬çªé³æºã«å¤æãã //
	      var bufferSize = buffer.getChannelData(0).length;
	      var vtBufsSize = vtBufs[0].length;

	      if (bufferSize == vtBufsSize) {
	        // ç·å½¢è£éã®å¿è¦ãªã //
	        for (var ch = 0; ch < 2; ch++) {
	          var data = buffer.getChannelData(ch);
	          var vtBuf = vtBufs[ch];

	          for (var i = 0; i < bufferSize; i++) {
	            data[i] = vtBuf[i];
	          }
	        }
	      } else {
	        // ç·å½¢è£é //
	        var ratio = vtBufsSize / bufferSize;

	        for (var _ch = 0; _ch < 2; _ch++) {
	          var _data = buffer.getChannelData(_ch);

	          var _vtBuf = vtBufs[_ch];

	          for (var _i = 0; _i < bufferSize; _i++) {
	            // ç·å½¢è£éããªããæ³¢å½¢ãä½æ //
	            // TODO é³ãã¾ã å°ãéåæããã®ã§ãã¹ãã©ã¤ã³è£æ­£ã«å¤æ´ããæ¹ããããã //
	            var idxF = _i * ratio;
	            var idx1 = Math.trunc(idxF);
	            var idx2 = (idx1 + 1) % vtBufsSize;
	            var idxR = idxF - idx1;
	            var w = _vtBuf[idx1] * (1 - idxR) + _vtBuf[idx2] * idxR;
	            _data[_i] = w;
	          }
	        }
	      }
	    }
	  }]);

	  return InterpolationUtil;
	}();

	function init(_audioContext, _picoAudio) {
	  if (this.isStarted) return;
	  this.isStarted = true; // AudioContextãçæ //

	  var AudioContext = window.AudioContext || window.webkitAudioContext;
	  this.context = _audioContext ? _audioContext : new AudioContext(); // ãã¹ã¿ã¼ããªã¥ã¼ã  //
	  // ãªã¢ã«ã¿ã¤ã ã§é³éå¤æ´ããããã«destinationåã«gainNodeãä¸ã¤åã¾ãã

	  this.masterGainNode = this.context.createGain();
	  this.masterGainNode.gain.value = this.settings.masterVolume; // ä»®æ³ãµã³ãã«ã¬ã¼ã //

	  var sampleRate = this.context.sampleRate;
	  var sampleRateVT = sampleRate >= 48000 ? 48000 : sampleRate; // ãã¯ã¤ããã¤ãº //

	  if (_picoAudio && _picoAudio.whitenoise) {
	    // ä½¿ãã¾ãã
	    this.whitenoise = _picoAudio.whitenoise;
	  } else {
	    RandomUtil.resetSeed(); // ä¹±æ°ãã¿ã¼ã³ãåºå®ã«ããï¼Math.random()ãä½¿ããªãï¼
	    // åçç°å¢ã®ãµã³ãã«ã¬ã¼ãã«ãã£ã¦é³ãå¤ãã£ã¦ãã¾ãã®ã§ //
	    // ä¸æ¦ä»®æ³ãµã³ãã«ã¬ã¼ãã§é³æºãä½æãã //

	    var seLength = 1;
	    var sampleLength = sampleRate * seLength;
	    var sampleLengthVT = sampleRateVT * seLength;
	    var vtBufs = [];

	    for (var ch = 0; ch < 2; ch++) {
	      vtBufs.push(new Float32Array(sampleLengthVT));
	      var vtBuf = vtBufs[ch];

	      for (var i = 0; i < sampleLengthVT; i++) {
	        var r = RandomUtil.random();
	        vtBuf[i] = r * 2 - 1;
	      }
	    } // ä»®æ³ãµã³ãã«ã¬ã¼ãé³æºãæ¬çªé³æºã«å¤æãã //


	    this.whitenoise = this.context.createBuffer(2, sampleLength, sampleRate);
	    InterpolationUtil.lerpWave(this.whitenoise, vtBufs);
	  } // ãªãã¼ãç¨ã®ã¤ã³ãã«ã¹å¿ç­é³å£°ãã¼ã¿ä½æï¼ã¦ãã¨ãï¼ //


	  if (_picoAudio && _picoAudio.impulseResponse) {
	    // ä½¿ãã¾ãã
	    this.impulseResponse = _picoAudio.impulseResponse;
	  } else {
	    RandomUtil.resetSeed(); // ä¹±æ°ãã¿ã¼ã³ãåºå®ã«ããï¼Math.random()ãä½¿ããªãï¼
	    // åçç°å¢ã®ãµã³ãã«ã¬ã¼ãã«ãã£ã¦é³ãå¤ãã£ã¦ãã¾ãã®ã§ //
	    // ä¸æ¦ä»®æ³ãµã³ãã«ã¬ã¼ãã§é³æºãä½æãã //

	    var _seLength = 3.5;

	    var _sampleLength = sampleRate * _seLength;

	    var _sampleLengthVT = sampleRateVT * _seLength;

	    var _vtBufs = [];

	    for (var _ch = 0; _ch < 2; _ch++) {
	      _vtBufs.push(new Float32Array(_sampleLengthVT));

	      var _vtBuf = _vtBufs[_ch];

	      for (var _i = 0; _i < _sampleLengthVT; _i++) {
	        var v = (_sampleLengthVT - _i) / _sampleLengthVT;
	        var s = _i / sampleRateVT;
	        var d = (s < 0.030 ? 0 : v) * (s >= 0.030 && s < 0.031 ? v * 2 : v) * (s >= 0.040 && s < 0.042 ? v * 1.5 : v) * (s >= 0.050 && s < 0.054 ? v * 1.25 : v) * RandomUtil.random() * 0.2 * Math.pow(v - 0.030, 4);
	        _vtBuf[_i] = d;
	      }
	    } // ä»®æ³ãµã³ãã«ã¬ã¼ãé³æºãæ¬çªé³æºã«å¤æãã //


	    this.impulseResponse = this.context.createBuffer(2, _sampleLength, this.context.sampleRate);
	    InterpolationUtil.lerpWave(this.impulseResponse, _vtBufs);
	  } // ãªãã¼ãç¨ã®AudioNodeä½æã»æ¥ç¶ //


	  this.convolver = this.context.createConvolver();
	  this.convolver.buffer = this.impulseResponse;
	  this.convolver.normalize = true;
	  this.convolverGainNode = this.context.createGain();
	  this.convolverGainNode.gain.value = this.settings.reverbVolume;
	  this.convolver.connect(this.convolverGainNode);
	  this.convolverGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(this.context.destination); // ã³ã¼ã©ã¹ç¨ã®AudioNodeä½æã»æ¥ç¶ //

	  this.chorusDelayNode = this.context.createDelay();
	  this.chorusGainNode = this.context.createGain();
	  this.chorusOscillator = this.context.createOscillator();
	  this.chorusLfoGainNode = this.context.createGain();
	  this.chorusDelayNode.delayTime.value = 0.025;
	  this.chorusLfoGainNode.gain.value = 0.010;
	  this.chorusOscillator.frequency.value = 0.05;
	  this.chorusGainNode.gain.value = this.settings.chorusVolume;
	  this.chorusOscillator.connect(this.chorusLfoGainNode);
	  this.chorusLfoGainNode.connect(this.chorusDelayNode.delayTime);
	  this.chorusDelayNode.connect(this.chorusGainNode);
	  this.chorusGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(this.context.destination);
	  this.chorusOscillator.start(0); // ãªãã¼ãON/OFFè¨­å®ãå¼ãç¶ããæªè¨­å®ãªãããã©ã¼ãã³ã¹è¨æ¸¬ãã(Tonyu2ç¨)

	  if (this.isTonyu2) {
	    if (_picoAudio) {
	      this.settings.isReverb = _picoAudio.settings.isReverb;
	    } else {
	      this.settings.isReverb = this.measurePerformanceReverb();
	    }
	  }
	}

	function setData(data) {
	  if (this.debug) {
	    var syoriTimeS = performance.now();
	  }

	  if (this.states.isPlaying) this.stop();
	  this.playData = data;
	  this.settings.resolution = data.header.resolution;
	  this.settings.tempo = data.tempo || 120;
	  this.tempoTrack = data.tempoTrack;
	  this.cc111Time = data.cc111Time;
	  this.firstNoteOnTiming = data.firstNoteOnTiming;
	  this.lastNoteOffTiming = data.lastNoteOffTiming;
	  this.firstNoteOnTime = data.firstNoteOnTime;
	  this.lastNoteOffTime = data.lastNoteOffTime;
	  this.initStatus();

	  if (this.debug) {
	    var syoriTimeE = performance.now();
	    console.log("setData time", syoriTimeE - syoriTimeS);
	  }

	  return this;
	}

	function initStatus(isSongLooping, isLight) {
	  // WebMIDIä½¿ç¨ä¸­ã®å ´åãinitStatus()é£æã®å¯¾ç­ //
	  if (this.settings.isWebMIDI) {
	    if (this.states.webMIDIWaitState != null) return;
	  } // æ¼å¥ä¸­ã®å ´åãåæ­¢ãã //


	  this.stop(isSongLooping); // statesãåæå //

	  this.states = {
	    isPlaying: false,
	    startTime: 0,
	    stopTime: 0,
	    stopFuncs: [],
	    webMIDIWaitState: null,
	    webMIDIStopTime: this.states.webMIDIStopTime,
	    playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	    updateBufTime: this.states.updateBufTime,
	    updateBufMaxTime: this.states.updateBufMaxTime,
	    updateIntervalTime: this.states.updateIntervalTime,
	    latencyLimitTime: this.states.latencyLimitTime,
	    noteOnAry: [],
	    noteOffAry: []
	  }; // WebMIDIã®åæåã»ãªã»ããã¡ãã»ã¼ã¸éä¿¡ //

	  if (this.settings.isWebMIDI && !isLight) {
	    if (isSongLooping) return;

	    if (this.settings.WebMIDIPortOutput == null) {
	      this.startWebMIDI();
	      return;
	    }

	    if (this.settings.WebMIDIPortSysEx) {
	      // GM1ã·ã¹ãã ã»ãªã³
	      this.settings.WebMIDIPortOutput.send([0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7]);
	    } else {
	      // SysExã®ä½¿ç¨ãæå¦ããã¦ããã®ã§ãã§ããéãè¨­å®å¤ãåæå¤ã«æ»ã
	      for (var t = 0; t < 16; t++) {
	        this.settings.WebMIDIPortOutput.send([0xC0 + t, 0]);
	        this.settings.WebMIDIPortOutput.send([0xE0 + t, 0, 64]); // ããããããã®ãããã²ã©ããªãå ´åããã ããããããªã

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 101, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 6, 2]); //pitchbend

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 1]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 96, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 97, 64]); //tuning?

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 7, 100]); // volume

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 10, 64]); // pan

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 11, 127]); // expression
	        //this.settings.WebMIDIPortOutput.send([0xB0+t, 91, 40]); // ãªãã¼ãä»¥å¤ã®ã¨ãã§ã¯ãã«è¨­å®ãããå ´åããããããªã®ã§ã³ã¡ã³ãã¢ã¦ã
	        //this.settings.WebMIDIPortOutput.send([0xB0+t, 93, 0]); // ã³ã¼ã©ã¹ä»¥å¤ã®ã¨ãã§ã¯ãã«è¨­å®ãããã®ãé³ãåºãªããªãå ´åãããã®ã§ã³ã¡ã³ãã¢ã¦ã

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 98, 0]);
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 99, 0]); //this.settings.WebMIDIPortOutput.send([0xB0+t, 121, 0]);

	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 122, 0]);
	      }
	    }
	  }
	}

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var slice$1 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap = function (scheduler) {
	  return function (handler, timeout
	  /* , ...arguments */
	  ) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	}; // ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


	_export({
	  global: true,
	  bind: true,
	  forced: MSIE
	}, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	});

	// https://tc39.github.io/ecma262/#sec-typedarray-objects

	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
	};

	var process = global_1.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);

	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	var SPECIES$3 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};

	    constructor[SPECIES$3] = function () {
	      return {
	        foo: 1
	      };
	    };

	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$2 = arrayMethodUsesToLength('splice', {
	  ACCESSORS: true,
	  0: 0,
	  1: 2
	});
	var max$1 = Math.max;
	var min$4 = Math.min;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$2
	}, {
	  splice: function splice(start, deleteCount
	  /* , ...items */
	  ) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;

	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$4(max$1(toInteger(deleteCount), 0), len - actualStart);
	    }

	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }

	    A = arraySpeciesCreate(O, actualDeleteCount);

	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }

	    A.length = actualDeleteCount;

	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }

	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }
	    }

	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }

	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var ArrayUtil = /*#__PURE__*/function (_Array) {
	  _inherits(ArrayUtil, _Array);

	  var _super = _createSuper(ArrayUtil);

	  function ArrayUtil() {
	    _classCallCheck(this, ArrayUtil);

	    return _super.apply(this, arguments);
	  }

	  _createClass(ArrayUtil, null, [{
	    key: "delete",

	    /**
	     * éåããè¦ç´ ï¼ã¤ãåé¤ãã
	     * 
	     *     Array.splice(index, 1); ãé«éåãã
	     *     ç¹ã«éåæ«å°¾ãåã¯éååé ­ãåé¤ããã¨ãã«é«éå¦çãæå¾ã§ãã
	     * @param {Array} array éå
	     * @param {number} index æ·»ãå­
	     */
	    value: function _delete(array, index) {
	      if (index == array.length - 1) array.pop(); // éåæ«å°¾ãArray.pop()ã§åé¤ããã¨é«éåãã
	      else if (index == 0) array.shift(); // éååé ­ãArray.shift()ã§åé¤ããã¨é«éåããï¼ãã¾ãå¤ãããªãç°å¢ãããï¼
	        else array.splice(index, 1); // éååé ­ã»æ«å°¾ä»¥å¤ãåé¤ããå ´åã¯Array.splice()ã§åé¤ãã
	    }
	  }]);

	  return ArrayUtil;
	}( /*#__PURE__*/_wrapNativeSuper(Array));

	var ParseUtil = /*#__PURE__*/function () {
	  function ParseUtil() {
	    _classCallCheck(this, ParseUtil);
	  }

	  _createClass(ParseUtil, null, [{
	    key: "getInt",

	    /**
	     * ãã¤ãéååã«å«ã¾ãã"ãã¼ã¿é·"ãæ°å¤ã«å¤æãã
	     * @param {Uint8Array} arr ãã¤ãéå
	     * @param {number} startIdx ãã¼ã¿é·ã®å§ç¹ã®å ´æ(index)
	     * @param {number} endIdx ãã¼ã¿é·ã®çµç¹ã®å ´æ(index) - 1
	     * @returns {number} ãã¼ã¿é·
	     */
	    value: function getInt(arr, startIdx, endIdx) {
	      var value = 0;

	      for (var i = startIdx; i < endIdx; i++) {
	        value = (value << 8) + arr[i];
	      }

	      return value;
	    }
	    /**
	     * ãã¤ãéååã«å«ã¾ãã"å¯å¤é·ã®ãã¼ã¿é·"ãæ°å¤ã«å¤æãã
	     * @param {Uint8Array} arr ãã¤ãéå
	     * @param {number} startIdx ãã¼ã¿é·ã®å§ç¹ã®å ´æ(index)
	     * @param {number} endIdx ãã¼ã¿é·ã®çµç¹ã®å ´æ(index) - 1 (çµç¹ã®å ´æã¯å¤ãã¦ããã¾ããªã)
	     * @returns {Array} [ãã¼ã¿é·, "å¯å¤é·ã®ãã¼ã¿é·"ã®ãã¤ãæ°]
	     */

	  }, {
	    key: "variableLengthToInt",
	    value: function variableLengthToInt(arr, startIdx, endIdx) {
	      var i = startIdx;
	      var value = 0;

	      while (i < endIdx - 1 && arr[i] >= 0x80) {
	        if (i < startIdx + 4) value = (value << 7) + (arr[i] - 0x80);
	        i++;
	      }

	      value = (value << 7) + arr[i];
	      i++;
	      return [value, i - startIdx];
	    }
	    /**
	     * ãã«ã¿ã¿ã¤ã ã®é çªã«ãªãããã«éåã«æ¿å¥
	     * @param {PicoAudio} that PicoAudioã¤ã³ã¹ã¿ã³ã¹
	     * @param {number} ch ãã£ã³ãã«çªå·
	     * @param {number} time ãã«ã¿ã¿ã¤ã 
	     * @param {number} p å¯¾è±¡ã®MIDIã¤ãã³ãã®å ´æ(SMFãã¼ã¿åã®ä½ç½®)
	     * @param {number} len MIDIã¤ãã³ãã®é·ã
	     */

	  }, {
	    key: "chIndicesInsert",
	    value: function chIndicesInsert(that, ch, time, p, len) {
	      var indices = ch.indices; // ãã«ã¿ã¿ã¤ã ã®é çªã«ãªãããã«ãªã¹ãéåã«æ¿å¥ //

	      if (ch.indicesLength >= 4 && time < indices[ch.indicesFoot]) {
	        // Insert //
	        while (ch.indicesCur != -1) {
	          if (time < indices[ch.indicesCur]) {
	            if (ch.indicesCur == ch.indicesHead) {
	              ch.indicesHead = ch.indicesLength;
	            } else {
	              indices[ch.indicesPre + 3] = ch.indicesLength;
	            }

	            indices[ch.indicesLength] = time;
	            indices[ch.indicesLength + 1] = len;
	            indices[ch.indicesLength + 2] = p;
	            indices[ch.indicesLength + 3] = ch.indicesCur;
	            ch.indicesPre = ch.indicesLength;
	            ch.indicesLength += 4;
	            break;
	          }

	          ch.indicesPre = ch.indicesCur;
	          ch.indicesCur = indices[ch.indicesCur + 3];
	        }
	      } else {
	        // Push //
	        if (ch.indicesLength >= 4) {
	          indices[ch.indicesFoot + 3] = ch.indicesLength;
	        } else {
	          ch.indicesHead = 0;
	        }

	        ch.indicesFoot = ch.indicesLength;
	        indices[ch.indicesLength] = time;
	        indices[ch.indicesLength + 1] = len;
	        indices[ch.indicesLength + 2] = p;
	        indices[ch.indicesLength + 3] = -1;
	        ch.indicesLength += 4;
	      }
	    }
	  }]);

	  return ParseUtil;
	}();

	var UpdateNote = /*#__PURE__*/function () {
	  function UpdateNote() {
	    _classCallCheck(this, UpdateNote);
	  }

	  _createClass(UpdateNote, null, [{
	    key: "init",

	    /**
	     * 1msæ¯å¦çç¨ã®å¤æ°ãåæå
	     */
	    value: function init(picoAudio, currentTime) {
	      this.updatePreTime = performance.now();
	      this.pPreTime = performance.now();
	      this.cPreTime = picoAudio.context.currentTime * 1000;
	      this.pTimeSum = 0;
	      this.cTimeSum = 0;
	      this.cnt = 0;
	      this.initCurrentTime = currentTime;
	    }
	    /**
	     * åçä¸­ã1msæ¯ã«å¼ã°ããã³ã¼ã«ããã¯
	     * ï¼ãã©ã¦ã¶ã®å¶éã§å®éã¯æç­4msæ¯ã«å¼ã°ããï¼
	     * @returns {number} ç¾å¨ã®æé
	     */

	  }, {
	    key: "update",
	    value: function update(picoAudio) {
	      var _this = this;

	      var context = picoAudio.context;
	      var settings = picoAudio.settings;
	      var states = picoAudio.states;
	      var updateNowTime = performance.now();
	      var updatePreTime = this.updatePreTime;
	      var pPreTime = this.pPreTime;
	      var cPreTime = this.cPreTime;
	      var pTimeSum = this.pTimeSum;
	      var cTimeSum = this.cTimeSum;
	      var cnt = this.cnt; // ãµã¦ã³ããéããªããç£è¦ï¼ããªã¼ãºå¯¾ç­ï¼ //
	      //   performance.now()ã¨AudioContext.currentTimeã®æéå·®ãè¨ç®ã
	      //   AudioContext.currentTimeãéãã¦ãããå¦çè½ã¡ãã¦ããã¨å¤æ­ãã

	      var updateBufTime = updateNowTime - updatePreTime;
	      var pTime = updateNowTime;
	      var cTime = context.currentTime * 1000;
	      pTimeSum += pTime - pPreTime;
	      cTimeSum += cTime - cPreTime;
	      pPreTime = pTime;
	      cPreTime = cTime;
	      var latencyTime = pTimeSum - cTimeSum;
	      states.latencyTime = latencyTime; // ãµã¦ã³ããéãå ´åãè² è·è»½æ¸å¦çãçºåãããªããããä¸ãã¦ãã //

	      if (latencyTime >= 100) {
	        // currentTimeãéãï¼ãµã¦ã³ããéãï¼
	        states.latencyLimitTime += latencyTime;
	        cTimeSum += 100;
	      } else if (latencyTime <= -100) {
	        // currentTimeãéãï¼èª¤å·®ï¼
	        cTimeSum = pTimeSum;
	      } else {
	        if (states.latencyLimitTime > 0) {
	          // currentTimeãä¸åº¦ãã
	          states.latencyLimitTime -= updateBufTime * 0.003;
	          if (states.latencyLimitTime < 0) states.latencyLimitTime = 0;
	        }
	      } // ãã¼ããåèª­ã¿åº¦åããèªåèª¿æ´ï¼äºç´ããããã¨éããªãï¼ //


	      states.updateIntervalTime = updateBufTime;

	      if (states.updateBufTime < updateBufTime) {
	        // åèª­ã¿éãã¦ããå ´å
	        states.updateBufTime = updateBufTime;
	      } else {
	        // åèª­ã¿éã«ä½è£ãããå ´å
	        // åèª­ã¿éãå°ããã¤æ¸ãã //
	        if (states.updateBufMaxTime > 350) {
	          states.updateBufMaxTime -= states.updateBufMaxTime * 0.002;
	        } // åèª­ã¿éãå°ããã¤å¢ãã //


	        if (states.updateBufTime < 20) {
	          states.updateBufTime += states.updateBufTime * 0.0005;
	        }

	        if (states.updateBufMaxTime >= 10 && states.updateBufMaxTime < 340) {
	          states.updateBufMaxTime += states.updateBufMaxTime * 0.002;
	        }
	      } // åèª­ã¿éãè¶³ããªããªã£ãå ´å


	      if (states.updateBufTime > states.updateBufMaxTime) {
	        if (updateBufTime >= 900 && states.latencyLimitTime <= 150) {
	          // ããã¯ã°ã©ã¦ã³ãã£ã½ãã¦éããªãå ´åãããã¯ã°ã©ã¦ã³ãåç
	          states.updateBufMaxTime += updateBufTime;
	        } else {
	          // éå¸¸
	          var tempTime = updateBufTime - states.updateBufMaxTime;
	          states.updateBufTime = states.updateBufMaxTime; // åèª­ã¿éãå°ããå ´åå¤§ãããã

	          if (states.updateBufMaxTime < 10) {
	            states.updateBufTime = states.updateBufMaxTime;
	            states.updateBufMaxTime *= 1.25;
	          } else {
	            states.updateBufMaxTime += tempTime / 2;
	          }
	        }

	        if (states.updateBufMaxTime > 1100) states.updateBufMaxTime = 1100;
	      } // ãµã¦ã³ããéãããå ´åãåèª­ã¿åº¦åããå°ãããã¦è² è·è»½æ¸ //


	      if (states.latencyLimitTime > 150) {
	        cTimeSum = pTimeSum;
	        states.latencyLimitTime -= 5;
	        if (states.latencyLimitTime > 1000) states.latencyLimitTime = 1000; // ãã¼ãåèª­ã¿ãããªãå°ããããï¼ããªã¼ãºå¯¾ç­ï¼

	        states.updateBufMaxTime = 1;
	        states.updateBufTime = 1;
	        updateBufTime = 1;
	      } // åçå¦ç //


	      for (var ch = 0; ch < 16; ch++) {
	        var notes = picoAudio.playData.channels[ch].notes;
	        var idx = states.playIndices[ch];

	        var _loop2 = function _loop2() {
	          var _this2 = this;

	          var note = notes[idx];
	          var curTime = cnt == 0 ? _this.initCurrentTime - states.startTime : context.currentTime - states.startTime; // çµãã£ããã¼ãã¯æ¼å¥ããã«ã¹ã­ãã

	          if (curTime >= note.stopTime) return "continue"; // ï¼ã·ã¼ã¯ãã¼ã§éä¸­ããåçæï¼startTimeãéãããã®ã¯é³´ãããªã

	          if (cnt == 0 && curTime > note.startTime + 0.05) return "continue"; // AudioParam.setValueAtTime()ç­ã§ãã¤ãã¹ãå¥ãã¨ã¨ã©ã¼ã«ãªãã®ã§å¯¾ç­

	          if (curTime + note.startTime < 0) return "continue"; // æ¼å¥éå§æé - åèª­ã¿æé(ãã¼ãäºç´) ã«ãªãã¨æ¼å¥äºç´oræ¼å¥éå§

	          if (curTime < note.startTime - states.updateBufTime / 1000) return "break"; // PicoAudioé³æºã®åçå¦ç //

	          if (!settings.isWebMIDI) {
	            // äºç´ãã¼ãæ°ãæ¥æ¿ã«å¢ããããªæãåèª­ã¿éãå°ãããã¦ãã //
	            if (states.stopFuncs.length >= 350 && states.updateBufTime < 1000) {
	              states.updateBufTime = 12;
	              states.updateBufMaxTime = states.updateBufTime;
	            } // ã¬ãã­ã¢ã¼ãï¼åé³å¶éã¢ã¼ãï¼ //


	            if (settings.maxPoly != -1 || settings.maxPercPoly != -1) {
	              var polyCnt = 0;
	              var percCnt = 0;
	              states.stopFuncs.forEach(function (tar) {
	                _newArrowCheck(this, _this2);

	                if (!tar.note) return;

	                if (tar.note.channel != 9) {
	                  if (note.start >= tar.note.start && note.start < tar.note.stop) {
	                    polyCnt++;
	                  }
	                } else {
	                  if (note.start == tar.note.start) {
	                    percCnt++;
	                  }
	                }
	              }.bind(this));

	              if (note.channel != 9 && polyCnt >= settings.maxPoly || note.channel == 9 && percCnt >= settings.maxPercPoly) {
	                return "continue";
	              }
	            } // ï¼ãã¼ãåã®åçå¦çï¼WebAudioã§åçï¼ //


	            var stopFunc = note.channel != 9 ? picoAudio.createNote(note) : picoAudio.createPercussionNote(note);
	            if (!stopFunc) return "continue"; // ç¡é³ã®å ´åãå¦çããªã

	            picoAudio.pushFunc({
	              note: note,
	              stopFunc: stopFunc
	            });
	          }

	          states.noteOnAry.push(note);
	        };

	        _loop: for (; idx < notes.length; idx++) {
	          var _ret = _loop2();

	          switch (_ret) {
	            case "continue":
	              continue;

	            case "break":
	              break _loop;
	          }
	        } // notesã®ã©ãã¾ã§åçããããè¨æ¶ãã¦ãæ¬¡åã³ã¼ã«ããã¯æã«ããããå¦çãå§ãã


	        states.playIndices[ch] = idx;
	      } // noteOnã®æéã«ãªã£ããç£è¦ //


	      this.checkNoteOn(picoAudio); // noteOffã®æéã«ãªã£ããç£è¦ //

	      this.checkNoteOff(picoAudio); // WebMIDIã®åçå¦ç //

	      if (settings.isWebMIDI && settings.WebMIDIPortOutput != null) {
	        var messages = picoAudio.playData.messages;
	        var smfData = picoAudio.playData.smfData;
	        var _idx = states.playIndices[16]; // 17chã¯WebMIDIç¨

	        for (; _idx < messages.length; _idx++) {
	          var message = messages[_idx];
	          var curTime = context.currentTime - states.startTime; // çµãã£ããã¼ãã¯æ¼å¥ããã«ã¹ã­ãã

	          if (curTime > message.time + 1) continue; // æ¼å¥éå§æé - åèª­ã¿æé(ãã¼ãäºç´) ã«ãªãã¨æ¼å¥äºç´oræ¼å¥éå§

	          if (curTime < message.time - 1) break; // WebMIDIã§MIDIã¡ãã»ã¼ã¸ãéä¿¡ããå¦ç //

	          var pLen = message.smfPtrLen;
	          var p = message.smfPtr;
	          var time = message.time;
	          var state = smfData[p];

	          if (state != 0xff) {
	            try {
	              if (state == 0xF0 || state == 0xF7) {
	                // sysExã®MIDIã¡ãã»ã¼ã¸
	                if (settings.WebMIDIPortSysEx) {
	                  // é·ãæå ±ãåãé¤ãã¦ç´ç²ãªSysExã¡ãã»ã¼ã¸ã«ãã
	                  var lengthAry = ParseUtil.variableLengthToInt(smfData, p + 1, p + 1 + 4);
	                  var sysExStartP = p + 1 + lengthAry[1];
	                  var sysExEndP = sysExStartP + lengthAry[0];
	                  var webMIDIMes = new Uint8Array(1 + lengthAry[0]);
	                  webMIDIMes[0] = state;
	                  var size = sysExEndP - sysExStartP;

	                  for (var i = 0; i < size; i++) {
	                    webMIDIMes[i + 1] = smfData[sysExStartP + i];
	                  }

	                  settings.WebMIDIPortOutput.send(webMIDIMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);
	                }
	              } else {
	                // sysExä»¥å¤ã®MIDIã¡ãã»ã¼ã¸
	                var sendMes = [];

	                for (var _i = 0; _i < pLen; _i++) {
	                  sendMes.push(smfData[p + _i]);
	                }

	                settings.WebMIDIPortOutput.send(sendMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);
	              }
	            } catch (e) {
	              console.log(e, p, pLen, time, state);
	            }
	          }
	        } // messagesã®ã©ãã¾ã§éä¿¡ããããè¨æ¶ãã¦ãæ¬¡åã³ã¼ã«ããã¯æã«ããããå¦çãå§ãã


	        states.playIndices[16] = _idx;
	      } // 1msã³ã¼ã«ããã¯ãå¼ã°ããåæ°ãã«ã¦ã³ã


	      cnt++; // å¤æ°ãåæ  //

	      this.updatePreTime = updateNowTime;
	      this.pPreTime = pPreTime;
	      this.cPreTime = cPreTime;
	      this.pTimeSum = pTimeSum;
	      this.cTimeSum = cTimeSum;
	      this.cnt = cnt;
	    }
	    /**
	     * noteOnã®æéã«ãªã£ããç£è¦
	     * @param {PicoAudio} picoAudio PicoAudioã¤ã³ã¹ã¿ã³ã¹
	     */

	  }, {
	    key: "checkNoteOn",
	    value: function checkNoteOn(picoAudio) {
	      var context = picoAudio.context;
	      var trigger = picoAudio.trigger;
	      var states = picoAudio.states;
	      var noteOnAry = picoAudio.states.noteOnAry;
	      var noteOffAry = picoAudio.states.noteOffAry;

	      for (var i = 0; i < noteOnAry.length; i++) {
	        var tempNote = noteOnAry[i];
	        var nowTime = context.currentTime - states.startTime;

	        if (tempNote.startTime - nowTime <= 0) {
	          ArrayUtil["delete"](noteOnAry, i); // noteOnAry.splice(i, 1); ã®é«éå

	          noteOffAry.push(tempNote); // ã¤ãã³ãçºç«

	          if (trigger.isNoteTrigger) trigger.noteOn(tempNote);
	          picoAudio.fireEvent('noteOn', tempNote);
	          i--;
	        }
	      }
	    }
	    /**
	     * noteOffã®æéã«ãªã£ããç£è¦
	     * @param {PicoAudio} picoAudio PicoAudioã¤ã³ã¹ã¿ã³ã¹
	     */

	  }, {
	    key: "checkNoteOff",
	    value: function checkNoteOff(picoAudio) {
	      var context = picoAudio.context;
	      var trigger = picoAudio.trigger;
	      var states = picoAudio.states;
	      var noteOffAry = picoAudio.states.noteOffAry;

	      for (var i = 0; i < noteOffAry.length; i++) {
	        var tempNote = noteOffAry[i];
	        var nowTime = context.currentTime - states.startTime;

	        if (tempNote.channel != 9 && tempNote.stopTime - nowTime <= 0 || tempNote.channel == 9 && tempNote.drumStopTime - nowTime <= 0) {
	          ArrayUtil["delete"](noteOffAry, i); // noteOffAry.splice(i, 1); ã®é«éå

	          picoAudio.clearFunc("note", tempNote); // ã¤ãã³ãçºç«

	          if (trigger.isNoteTrigger) trigger.noteOff(tempNote);
	          picoAudio.fireEvent('noteOff', tempNote);
	          i--;
	        }
	      }
	    }
	  }]);

	  return UpdateNote;
	}();

	function play(isSongLooping) {
	  var _this = this;

	  var context = this.context;
	  var settings = this.settings;
	  var trigger = this.trigger;
	  var states = this.states; // åçä¸­ã®å ´åãå¦çããªã //

	  if (states.isPlaying) return; // WebMIDIã®å ´åãå°ãå¾ã£ã¦ããåçãã //

	  if (settings.isWebMIDI && !isSongLooping) {
	    // Web MIDI APIä½¿ç¨æã¯stop()ãã800msç¨å¾æ©ããã¨é³ããã°ãã«ãã
	    if (states.webMIDIWaitState != "completed") {
	      if (states.webMIDIWaitState != "waiting") {
	        // play()é£æã®å¯¾ç­
	        // stop()ãã1000mså¾ã«play()ãå®è¡
	        states.webMIDIWaitState = "waiting";
	        var waitTime = 1000 - (context.currentTime - states.webMIDIStopTime) * 1000;
	        if (states.webMIDIStopTime == 0) waitTime = 1000; // MIDI Portãopenãã¦æåã«å¼ã³åºãã¨ããå°ãå¾ã¤

	        setTimeout(function () {
	          _newArrowCheck(this, _this);

	          states.webMIDIWaitState = "completed";
	          states.isPlaying = false;
	          this.play();
	        }.bind(this), waitTime);
	      }

	      return;
	    } else {
	      states.webMIDIWaitState = null;
	    }
	  } // å¤æ°ãç¨æ //


	  var currentTime = context.currentTime;
	  this.isPlayed = true;
	  states.isPlaying = true;
	  states.startTime = !states.startTime && !states.stopTime ? currentTime : states.startTime + currentTime - states.stopTime;
	  states.stopFuncs = []; // åé ­ã®ä½ç½ãã¹ã­ãã //

	  if (settings.isSkipBeginning) {
	    var firstNoteOnTime = this.firstNoteOnTime;

	    if (-states.startTime + currentTime < firstNoteOnTime) {
	      this.setStartTime(firstNoteOnTime + states.startTime - currentTime);
	    }
	  } // æ²çµäºã³ã¼ã«ããã¯ãäºç´ //


	  var reserveSongEnd;

	  var _reserveSongEndFunc = function reserveSongEndFunc() {
	    var _this2 = this;

	    _newArrowCheck(this, _this);

	    this.clearFunc("rootTimeout", reserveSongEnd);
	    var finishTime = settings.isCC111 && this.cc111Time != -1 ? this.lastNoteOffTime : this.getTime(Number.MAX_SAFE_INTEGER);

	    if (finishTime - context.currentTime + states.startTime <= 0) {
	      // äºå®ã®æéä»¥éã«æ²çµäº
	      trigger.songEnd();
	      this.onSongEnd();
	      this.fireEvent('songEnd');
	    } else {
	      // å¦çè½ã¡ããããã¦ã¾ã æ¼å¥ä¸­ã®å ´åã1mså¾ã«æ²çµäºã³ã¼ã«ããã¯ãå¼ã³åºãããäºç´
	      reserveSongEnd = setTimeout(_reserveSongEndFunc, 1);
	      this.pushFunc({
	        rootTimeout: reserveSongEnd,
	        stopFunc: function stopFunc() {
	          _newArrowCheck(this, _this2);

	          clearTimeout(reserveSongEnd);
	        }.bind(this)
	      });
	    }
	  }.bind(this);

	  var finishTime = settings.isCC111 && this.cc111Time != -1 ? this.lastNoteOffTime : this.getTime(Number.MAX_SAFE_INTEGER);
	  var reserveSongEndTime = (finishTime - context.currentTime + states.startTime) * 1000;
	  reserveSongEnd = setTimeout(_reserveSongEndFunc, reserveSongEndTime);
	  this.pushFunc({
	    rootTimeout: reserveSongEnd,
	    stopFunc: function stopFunc() {
	      _newArrowCheck(this, _this);

	      clearTimeout(reserveSongEnd);
	    }.bind(this)
	  }); // åçéå§ãã³ã¼ã«ããã¯ã«éç¥ //

	  trigger.play();
	  this.fireEvent('play'); // 1msæ¯ã³ã¼ã«ããã¯ã®æºå //

	  UpdateNote.init(this, currentTime); // 1msæ¯ã³ã¼ã«ããã¯ãéå§ //

	  var reserve = setInterval(function () {
	    _newArrowCheck(this, _this);

	    UpdateNote.update(this);
	  }.bind(this), 1);
	  this.pushFunc({
	    rootTimeout: reserve,
	    stopFunc: function stopFunc() {
	      _newArrowCheck(this, _this);

	      clearInterval(reserve);
	    }.bind(this)
	  });
	}

	function stop(isSongLooping) {
	  var _this = this;

	  var states = this.states; // åçãã¦ããªãå ´åãä½ãããªã //

	  if (states.isPlaying == false) return; // ã¹ãã¼ã¿ã¹ãåæ­¢ç¶æã«ããã»çµäºå¦çãå¼ã¶ //

	  states.isPlaying = false;
	  states.stopTime = this.context.currentTime;
	  states.stopFuncs.forEach(function (n) {
	    _newArrowCheck(this, _this);

	    // åçä¸­ã®é³ã®åæ­¢é¢æ°ãå¼ã¶
	    n.stopFunc();
	  }.bind(this));
	  states.stopFuncs = [];
	  states.playIndices.forEach(function (n, i, ary) {
	    _newArrowCheck(this, _this);

	    ary[i] = 0;
	  }.bind(this));
	  states.noteOnAry = [];
	  states.noteOffAry = []; // WebMIDIã§åçä¸­ã®å ´åãåæ­¢ã¡ãã»ã¼ã¸ãéä¿¡ //

	  if (this.settings.isWebMIDI) {
	    if (isSongLooping) return;
	    if (this.settings.WebMIDIPortOutput == null) return;
	    states.webMIDIStopTime = this.context.currentTime;
	    setTimeout(function () {
	      _newArrowCheck(this, _this);

	      for (var t = 0; t < 16; t++) {
	        this.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);
	      }
	    }.bind(this), 1000);
	  } // åæ­¢ãã³ã¼ã«ããã¯ã«éç¥ //


	  this.trigger.stop();
	  this.fireEvent('stop');
	}

	function createBaseNote(option, isDrum, isExpression, nonChannel, nonStop) {
	  var _this = this;

	  // æä½éã®å¤æ°ãæºåï¼ç¡é³ã®å ´åã¯å¦ççµäºããããï¼ //
	  var settings = this.settings;
	  var context = this.context;
	  var songStartTime = this.states.startTime;
	  var channel = nonChannel ? 0 : option.channel || 0;
	  var velocity = option.velocity * Number(nonChannel ? 1 : this.channels[channel][2] != null ? this.channels[channel][2] : 1) * settings.generateVolume;
	  var isGainValueZero = true; // ç¡é³ã®å ´åã¯å¦ççµäº //

	  if (velocity <= 0) return {
	    isGainValueZero: true
	  }; // é³éã®å¤åãè¨­å® //

	  var expGainValue = velocity * ((option.expression ? option.expression[0].value : 100) / 127);
	  var expGainNode = context.createGain();
	  expGainNode.gain.value = expGainValue;

	  if (isExpression) {
	    option.expression ? option.expression.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      var v = velocity * (p.value / 127);
	      if (v > 0) isGainValueZero = false;
	      expGainNode.gain.setValueAtTime(v, p.time + songStartTime);
	    }.bind(this)) : false;
	  } else {
	    if (expGainValue > 0) {
	      isGainValueZero = false;
	    }
	  } // ç¡é³ã®å ´åã¯å¦ççµäº //


	  if (isGainValueZero) {
	    // é³éãå¸¸ã«0ãªãé³ãé³´ãããªã
	    return {
	      isGainValueZero: true
	    };
	  } // å¨ã¦ã®å¤æ°ãæºå //


	  var start = option.startTime + songStartTime;
	  var stop = option.stopTime + songStartTime;
	  var pitch = settings.basePitch * Math.pow(Math.pow(2, 1 / 12), (option.pitch || 69) - 69);
	  var oscillator = !isDrum ? context.createOscillator() : context.createBufferSource();
	  var panNode = context.createStereoPanner ? context.createStereoPanner() : context.createPanner ? context.createPanner() : {
	    pan: {
	      setValueAtTime: function setValueAtTime() {
	        _newArrowCheck(this, _this);
	      }.bind(this)
	    }
	  };
	  var gainNode = context.createGain();
	  var stopGainNode = context.createGain(); // ãã©ã ã¯ãã¯ã¤ããã¤ãºããã©ã ä»¥å¤ã¯oscillatorãè¨­å® //
	  // oscillatorã¯ãããå¤åãè¨­å® //

	  if (!isDrum) {
	    oscillator.type = option.type || "sine";
	    oscillator.detune.value = 0;
	    oscillator.frequency.value = pitch;
	    option.pitchBend ? option.pitchBend.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      oscillator.frequency.setValueAtTime(settings.basePitch * Math.pow(Math.pow(2, 1 / 12), option.pitch - 69 + p.value), p.time + songStartTime);
	    }.bind(this)) : false;
	  } else {
	    oscillator.loop = true;
	    oscillator.buffer = this.whitenoise;
	  } // ãã³ã®åæå¤ãè¨­å® //


	  var panValue = option.pan && option.pan[0].value != 64 ? option.pan[0].value / 127 * 2 - 1 : 0;
	  initPanValue(context, panNode, panValue); // ãã³ã®å¤åãè¨­å® //

	  if (context.createStereoPanner || context.createPanner) {
	    // StereoPannerNode or PannerNode ãã©ã¡ããã§ãä½¿ãã
	    var firstNode = true;

	    if (context.createStereoPanner) {
	      // StereoPannerNode ãä½¿ãã
	      option.pan ? option.pan.forEach(function (p) {
	        _newArrowCheck(this, _this);

	        if (firstNode) {
	          firstNode = false;
	          return;
	        }

	        var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	        if (v > 1.0) v = 1.0;
	        panNode.pan.setValueAtTime(v, p.time + songStartTime);
	      }.bind(this)) : false;
	    } else if (context.createPanner) {
	      // StereoPannerNode ãæªãµãã¼ããPannerNode ãä½¿ãã
	      if (panNode.positionX) {
	        // setValueAtTimeãä½¿ãã
	        // Old Browser
	        option.pan ? option.pan.forEach(function (p) {
	          _newArrowCheck(this, _this);

	          if (firstPan) {
	            firstPan = false;
	            return;
	          }

	          var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	          var posObj = convPosition(v);
	          panNode.positionX.setValueAtTime(posObj.x, p.time + songStartTime);
	          panNode.positionY.setValueAtTime(posObj.y, p.time + songStartTime);
	          panNode.positionZ.setValueAtTime(posObj.z, p.time + songStartTime);
	        }.bind(this)) : false;
	      } else {
	        // iOS
	        // setValueAtTimeãä½¿ããªãããsetTimeoutã§ãã³ã®åçå¤æ´
	        option.pan ? option.pan.forEach(function (p) {
	          var _this2 = this;

	          _newArrowCheck(this, _this);

	          if (firstNode) {
	            firstNode = false;
	            return;
	          }

	          var reservePan = setTimeout(function () {
	            _newArrowCheck(this, _this2);

	            this.clearFunc("pan", reservePan);
	            var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;
	            if (v > 1.0) v = 1.0;
	            var posObj = convPosition(v);
	            panNode.setPosition(posObj.x, posObj.y, posObj.z);
	          }.bind(this), (p.time + songStartTime - context.currentTime) * 1000);
	          this.pushFunc({
	            pan: reservePan,
	            stopFunc: function stopFunc() {
	              _newArrowCheck(this, _this2);

	              clearTimeout(reservePan);
	            }.bind(this)
	          });
	        }.bind(this)) : false;
	      }
	    }

	    oscillator.connect(panNode);
	    panNode.connect(expGainNode);
	  } else {
	    // StereoPannerNodeãPannerNode ãæªãµãã¼ã
	    oscillator.connect(expGainNode);
	  } // AudioNodeãæ¥ç¶ //


	  expGainNode.connect(gainNode);
	  gainNode.connect(stopGainNode);
	  stopGainNode.connect(this.masterGainNode);
	  this.masterGainNode.connect(context.destination); // ã¢ã¸ã¥ã¬ã¼ã·ã§ã³ã®å¤åãè¨­å® //

	  var modulationOscillator;
	  var modulationGainNode;

	  if (!isDrum && option.modulation && (option.modulation.length >= 2 || option.modulation[0].value > 0)) {
	    modulationOscillator = context.createOscillator();
	    modulationGainNode = context.createGain();
	    var _firstNode = true;
	    option.modulation ? option.modulation.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode) {
	        _firstNode = false;
	        return;
	      }

	      var m = p.value / 127;
	      if (m > 1.0) m = 1.0;
	      modulationGainNode.gain.setValueAtTime(pitch * 10 / 440 * m, p.time + songStartTime);
	    }.bind(this)) : false;
	    var m = option.modulation ? option.modulation[0].value / 127 : 0;
	    if (m > 1.0) m = 1.0;
	    modulationGainNode.gain.value = pitch * 10 / 440 * m;
	    modulationOscillator.frequency.value = 6;
	    modulationOscillator.connect(modulationGainNode);
	    modulationGainNode.connect(oscillator.frequency);
	  } // ãªãã¼ãã®å¤åãè¨­å® //


	  if (this.settings.isReverb && option.reverb && (option.reverb.length >= 2 || option.reverb[0].value > 0)) {
	    var convolver = this.convolver;
	    var convolverGainNode = context.createGain();
	    var _firstNode2 = true;
	    option.reverb ? option.reverb.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode2) {
	        _firstNode2 = false;
	        return;
	      }

	      var r = p.value / 127;
	      if (r > 1.0) r = 1.0;
	      convolverGainNode.gain.setValueAtTime(r, p.time + songStartTime);
	    }.bind(this)) : false;
	    var r = option.reverb ? option.reverb[0].value / 127 : 0;
	    if (r > 1.0) r = 1.0;
	    convolverGainNode.gain.value = r;
	    gainNode.connect(stopGainNode);
	    stopGainNode.connect(convolverGainNode);
	    convolverGainNode.connect(convolver);
	  } // ã³ã¼ã©ã¹ã®å¤åãè¨­å® //


	  if (this.settings.isChorus && option.chorus && (option.chorus.length >= 2 || option.chorus[0].value > 0)) {
	    var chorusDelayNode = this.chorusDelayNode;
	    var chorusGainNode = context.createGain();
	    var _firstNode3 = true;
	    option.chorus ? option.chorus.forEach(function (p) {
	      _newArrowCheck(this, _this);

	      if (_firstNode3) {
	        _firstNode3 = false;
	        return;
	      }

	      var c = p.value / 127;
	      if (c > 1.0) c = 1.0;
	      chorusGainNode.gain.setValueAtTime(c, p.time + songStartTime);
	    }.bind(this)) : false;
	    var c = option.chorus ? option.chorus[0].value / 127 : 0;
	    if (c > 1.0) c = 1.0;
	    chorusGainNode.gain.value = c;
	    gainNode.connect(stopGainNode);
	    stopGainNode.connect(chorusGainNode);
	    chorusGainNode.connect(chorusDelayNode);
	  } // ã¢ã¸ã¥ã¬ã¼ã·ã§ã³ãã¹ã¿ã¼ã //


	  if (modulationOscillator) {
	    modulationOscillator.start(start);
	    this.stopAudioNode(modulationOscillator, stop, modulationGainNode);
	  } // oscillatoråã¯ãã¯ã¤ããã¤ãºãã¹ã¿ã¼ã //


	  oscillator.start(start);

	  if (!isDrum && !nonChannel && !nonStop) {
	    this.stopAudioNode(oscillator, stop, stopGainNode);
	  } // AudioNodeããã©ã¡ã¼ã¿ãè¿ã //


	  return {
	    start: start,
	    stop: stop,
	    pitch: pitch,
	    channel: channel,
	    velocity: velocity,
	    oscillator: oscillator,
	    panNode: panNode,
	    gainNode: gainNode,
	    stopGainNode: stopGainNode,
	    isGainValueZero: false
	  };
	}
	/**
	 * ãã³ã®åæå¤ãè¨­å®
	 * @param {PannerNode | StereoPannerNode} panNode 
	 * @param {number} panValue 
	 */

	function initPanValue(context, panNode, panValue) {
	  if (context.createStereoPanner) {
	    if (panValue > 1.0) panValue = 1.0;
	    panNode.pan.value = panValue;
	  } else if (context.createPanner) {
	    // iOS, Old Browser
	    var posObj = convPosition(panValue);
	    panNode.panningModel = "equalpower";
	    panNode.setPosition(posObj.x, posObj.y, posObj.z);
	  }
	}
	/**
	 * panå¤ãåºã«ãPannerNodeç¨ã®å¤ã{x, y, z}ã§è¿ã
	 * @param {number} panValue panã®å¤
	 * @returns Object{x, y, z}
	 */


	function convPosition(panValue) {
	  if (panValue > 1.0) panValue = 1.0;
	  var obj = {};
	  var panAngle = panValue * 90;
	  obj.x = Math.sin(panAngle * (Math.PI / 180));
	  obj.y = 0;
	  obj.z = -Math.cos(panAngle * (Math.PI / 180));
	  return obj;
	}

	function createNote(option) {
	  var _this = this;

	  var note = this.createBaseNote(option, false, true, false, true); // oscillatorã®stopã¯ãã¡ãã§å®è¡ããããæå®

	  if (note.isGainValueZero) return null;
	  var oscillator = note.oscillator;
	  var gainNode = note.gainNode;
	  var stopGainNode = note.stopGainNode;
	  var isPizzicato = false;
	  var isNoiseCut = false;
	  var note2; // é³è²ã®è¨­å® //

	  switch (this.channels[note.channel][0] * 1000 || option.instrument) {
	    // Sine
	    case 1000:
	    case 6:
	    case 15:
	    case 24:
	    case 26:
	    case 46:
	    case 50:
	    case 51:
	    case 52:
	    case 53:
	    case 54:
	    case 82:
	    case 85:
	    case 86:
	      {
	        oscillator.type = "sine";
	        gainNode.gain.value *= 1.5;
	        break;
	      }
	    // Square

	    case 2000:
	    case 4:
	    case 12:
	    case 13:
	    case 16:
	    case 19:
	    case 20:
	    case 32:
	    case 34:
	    case 45:
	    case 48:
	    case 49:
	    case 55:
	    case 56:
	    case 57:
	    case 61:
	    case 62:
	    case 63:
	    case 71:
	    case 72:
	    case 73:
	    case 74:
	    case 75:
	    case 76:
	    case 77:
	    case 78:
	    case 79:
	    case 80:
	    case 84:
	      {
	        oscillator.type = "square";
	        gainNode.gain.value *= 0.8;
	        break;
	      }
	    // Sawtooth

	    case 3000:
	    case 0:
	    case 1:
	    case 2:
	    case 3:
	    case 6:
	    case 7:
	    case 17:
	    case 18:
	    case 21:
	    case 22:
	    case 23:
	    case 27:
	    case 28:
	    case 29:
	    case 30:
	    case 36:
	    case 37:
	    case 38:
	    case 39:
	    case 40:
	    case 41:
	    case 42:
	    case 43:
	    case 44:
	    case 47:
	    case 59:
	    case 64:
	    case 65:
	    case 66:
	    case 67:
	    case 68:
	    case 69:
	    case 70:
	    case 71:
	    case 82:
	    case 87:
	      {
	        oscillator.type = "sawtooth";
	        break;
	      }
	    // Triangle

	    case 4000:
	    case 8:
	    case 9:
	    case 10:
	    case 11:
	    case 14:
	    case 25:
	    case 31:
	    case 33:
	    case 35:
	    case 58:
	    case 60:
	    case 83:
	    case 88:
	    case 89:
	    case 90:
	    case 91:
	    case 92:
	    case 93:
	    case 94:
	    case 95:
	      {
	        oscillator.type = "triangle";
	        gainNode.gain.value *= 1.5;
	        break;
	      }
	    // Other - Square

	    default:
	      {
	        oscillator.type = "square";
	      }
	  } // é³ã®çµããã®ãããããã¤ãºãæ°ã«ãªãã®ã§ãé³ã®çµããã«5msæ¸è¡°ãã¦ãã¤ãºè»½æ¸ //


	  if ((oscillator.type == "sine" || oscillator.type == "triangle") && !isPizzicato && note.stop - note.start > 0.01) {
	    isNoiseCut = true;
	  } // æ¸è¡°ã®è¨­å® //


	  switch (this.channels[note.channel][1] / 10 || option.instrument) {
	    // ãããã«ã¼ãç³»æ¸è¡°
	    case 0.2:
	    case 12:
	    case 13:
	    case 45:
	    case 55:
	      {
	        isPizzicato = true;
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 0.2);
	        this.stopAudioNode(oscillator, note.start + 0.2, stopGainNode);
	        break;
	      }
	    // ãã¢ãç¨åº¦ã«ä¼¸ã°ãç³»

	    case 0.3:
	    case 0:
	    case 1:
	    case 2:
	    case 3:
	    case 6:
	    case 9:
	    case 11:
	    case 14:
	    case 15:
	    case 32:
	    case 36:
	    case 37:
	    case 46:
	    case 47:
	      {
	        gainNode.gain.value *= 1.1;
	        var decay = (128 - option.pitch) / 128;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.85, note.start + decay * decay / 8);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.8, note.start + decay * decay / 4);
	        gainNode.gain.setTargetAtTime(0, note.start + decay * decay / 4, 5 * decay * decay);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }
	    // ã®ã¿ã¼ç³»

	    case 0.4:
	    case 24:
	    case 25:
	    case 26:
	    case 27:
	    case 28:
	    case 29:
	    case 30:
	    case 31:
	    case 34:
	      {
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 1.0 + note.velocity * 4);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }
	    // æ¸è¡°ãã¦ãããã©çµãããªãç³»

	    case 0.5:
	    case 4:
	    case 5:
	    case 7:
	    case 8:
	    case 10:
	    case 33:
	    case 35:
	      {
	        gainNode.gain.value *= 1.0;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);
	        gainNode.gain.setValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);
	        gainNode.gain.linearRampToValueAtTime(0.0, note.start + 2.0 + note.velocity * 10);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        break;
	      }

	    case 119:
	      // Reverse Cymbal
	      {
	        gainNode.gain.value = 0;
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	        note2 = this.createBaseNote(option, true, true);
	        if (note2.isGainValueZero) break;
	        note2.oscillator.playbackRate.setValueAtTime((option.pitch + 1) / 128, note.start);
	        note2.gainNode.gain.setValueAtTime(0, note.start);
	        note2.gainNode.gain.linearRampToValueAtTime(1.3, note.start + 2);
	        this.stopAudioNode(note2.oscillator, note.stop, note2.stopGainNode);
	        break;
	      }

	    default:
	      {
	        gainNode.gain.value *= 1.1;
	        gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);
	        this.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);
	      }
	  } // é³ãã¹ããããããé¢æ°ãè¿ã //


	  return function () {
	    _newArrowCheck(this, _this);

	    this.stopAudioNode(oscillator, 0, stopGainNode, true);
	    if (note2 && note2.oscillator) this.stopAudioNode(note2.oscillator, 0, note2.stopGainNode, true);
	  }.bind(this);
	}

	function createPercussionNote(option) {
	  var _this = this;

	  var note = this.createBaseNote(option, true, false);
	  if (note.isGainValueZero) return null;
	  var source = note.oscillator;
	  var gainNode = note.gainNode;
	  var stopGainNode = note.stopGainNode;
	  var start = note.start;
	  var velocity = 1; // ãã©ã å¨ä½ã®é³éèª¿æ´ç¨

	  var note2 = this.createBaseNote(option, false, false, true);
	  var oscillator = note2.oscillator;
	  var gainNode2 = note2.gainNode;
	  var stopGainNode2 = note2.stopGainNode;
	  var nextSameNoteOnInterval = option.nextSameNoteOnInterval; // oscillator.frequency.setValueAtTime()ãcurrentTimeããéããã¨å¨æ³¢æ°è¨­å®ããããªãã®ã§å¯¾ç­

	  if (start < this.context.currentTime) start = this.context.currentTime;
	  var stopAudioTime = 0;
	  var stopAudioTime2 = 0;

	  switch (option.pitch) {
	    // åãã®ãã¼ã«ãã·ã§ã³é³æº //
	    // Bass drum
	    case 35:
	    case 36:
	      // w
	      gainNode.gain.value = velocity * 0.6;
	      source.playbackRate.value = 0.02;
	      stopAudioTime = 0.07; // s

	      gainNode2.gain.value = velocity * 1.1;
	      oscillator.frequency.setValueAtTime(120, start);
	      oscillator.frequency.linearRampToValueAtTime(50, start + 0.07);
	      stopAudioTime2 = 0.07;
	      break;
	    // Snare

	    case 38:
	    case 40:
	      // w
	      source.playbackRate.value = 0.7;
	      stopAudioTime = 0.05; // s

	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.05);
	      oscillator.frequency.setValueAtTime(300, start);
	      oscillator.frequency.linearRampToValueAtTime(200, start + 0.05);
	      stopAudioTime2 = 0.05;
	      break;
	    // Toms

	    case 41:
	    case 43:
	    case 45:
	    case 47:
	    case 48:
	    case 50:
	      // w
	      source.playbackRate.value = 0.01;
	      stopAudioTime = 0.1; // s

	      oscillator.type = "square";
	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.01, start + 0.1);
	      oscillator.frequency.setValueAtTime(150 + 20 * (option.pitch - 40), start);
	      oscillator.frequency.linearRampToValueAtTime(50 + 20 * (option.pitch - 40), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // Close Hihat

	    case 42:
	    case 44:
	      source.playbackRate.value = 1.5;
	      stopAudioTime = 0.02;
	      stopAudioTime2 = 0;
	      break;
	    // Open Hihat

	    case 46:
	      source.playbackRate.value = 1.5;
	      stopAudioTime = 0.3;
	      gainNode.gain.setValueAtTime(velocity * 0.9, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal

	    case 49:
	    case 51:
	    case 52:
	    case 53:
	    case 55:
	    case 57:
	      source.playbackRate.value = 1.2;
	      stopAudioTime = 0.5;
	      gainNode.gain.setValueAtTime(velocity * 1, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.5);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal2

	    case 51:
	      source.playbackRate.value = 1.1;
	      stopAudioTime = 0.4;
	      gainNode.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.4);
	      stopAudioTime2 = 0;
	      break;
	    // Cymbal3

	    case 59:
	      source.playbackRate.value = 1.8;
	      stopAudioTime = 0.3;
	      gainNode.gain.setValueAtTime(velocity * 0.5, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      stopAudioTime2 = 0;
	      break;
	    // Bongo

	    case 60:
	    case 61:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(400 - 40 * (option.pitch - 60), start);
	      oscillator.frequency.linearRampToValueAtTime(450 - 40 * (option.pitch - 60), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // mute Conga

	    case 62:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.03);
	      oscillator.frequency.setValueAtTime(200, start);
	      oscillator.frequency.linearRampToValueAtTime(250, start + 0.03);
	      stopAudioTime2 = 0.03;
	      break;
	    // open Conga

	    case 63:
	    case 64:
	      // w
	      source.playbackRate.value = 0.03;
	      stopAudioTime = 0.03; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(200 - 30 * (option.pitch - 63), start);
	      oscillator.frequency.linearRampToValueAtTime(250 - 30 * (option.pitch - 63), start + 0.1);
	      stopAudioTime2 = 0.1;
	      break;
	    // Cowbell, Claves

	    case 56:
	    case 75:
	      // w
	      source.playbackRate.value = 0.01;
	      stopAudioTime = 0.1; // s

	      gainNode2.gain.setValueAtTime(velocity, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.1);
	      oscillator.frequency.setValueAtTime(1000 + 48 * (option.pitch - 56), start);
	      stopAudioTime2 = 0.1;
	      break;
	    // mute triangle

	    case 80:
	      // w
	      source.playbackRate.value = 5;
	      gainNode.gain.setValueAtTime(velocity * 0.5, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.2);
	      stopAudioTime = 0.05; // s

	      oscillator.type = "triangle";
	      gainNode2.gain.setValueAtTime(velocity * 0.7, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.2);
	      oscillator.frequency.setValueAtTime(6000, start);
	      stopAudioTime2 = 0.05;
	      break;
	    // open triangle

	    case 81:
	      // w
	      source.playbackRate.value = 5;
	      gainNode.gain.setValueAtTime(velocity * 0.9, start);
	      gainNode.gain.linearRampToValueAtTime(0.0, start + 0.5);
	      stopAudioTime = 0.5; // s

	      oscillator.type = "triangle";
	      gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	      gainNode2.gain.linearRampToValueAtTime(0.0, start + 0.3);
	      oscillator.frequency.setValueAtTime(6000, start);
	      stopAudioTime2 = 0.3;
	      break;
	    // æ°ãããã¼ã«ãã·ã§ã³é³æº //
	    //     æ§é³æºãåªåã§é³´ããä¸ã®ã½ã¼ã¹
	    //     æ§é³æºã§å®ç¾©ããã¦ããªãå ´åã¯ãæ°é³æºã§é³´ããä¸ã®ã½ã¼ã¹ //
	    // Bass Drum

	    case 35: // Acoustic Bass Drum

	    case 36:
	      // Bass Drum
	      {
	        // w
	        source.playbackRate.value = 0.25;
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.004);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.008);
	        stopAudioTime = 0.008; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 35 ? 90 : 160, start);
	        oscillator.frequency.linearRampToValueAtTime(40, start + 0.08);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.02);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime2 = 0.08;
	        break;
	      }
	    // Snare Drum

	    case 37:
	      // Side Stick
	      {
	        // w
	        source.playbackRate.value = 0.26;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.041);
	        stopAudioTime = 0.041; // s

	        oscillator.frequency.setValueAtTime(330, start);
	        oscillator.frequency.linearRampToValueAtTime(120, start + 0.02);
	        gainNode2.gain.setValueAtTime(velocity, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.02);
	        stopAudioTime2 = 0.02;
	        break;
	      }

	    case 38: // Acoustic Snare

	    case 40:
	      // Electric Snare
	      {
	        var len = option.pitch == 38 ? 0.25 : 0.2; // w

	        source.playbackRate.value = 0.7;
	        gainNode.gain.setValueAtTime(velocity, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + len);
	        stopAudioTime = len; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 38 ? 140 : 200, start);
	        oscillator.frequency.linearRampToValueAtTime(option.pitch == 38 ? 100 : 160, start + 0.1);
	        gainNode2.gain.setValueAtTime(velocity * 2, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.1);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 39:
	      // Hand Clap
	      {
	        // w
	        source.playbackRate.value = 0.5;
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0101);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0201);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.09);
	        stopAudioTime = 0.09; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(180, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0101);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0201);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.030);
	        stopAudioTime2 = 0.11;
	        break;
	      }
	    // Toms

	    case 41: // Low Floor Tom

	    case 43: // High Floor Tom

	    case 45: // Low Tom

	    case 47: // Low-Mid Tom

	    case 48: // High-Mid Tom

	    case 50:
	      // High Tom
	      {
	        var _len = option.pitch - 41 + (option.pitch >= 48 ? 1 : 0); // w


	        source.playbackRate.value = 0.3 + _len / 45;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.02);
	        stopAudioTime = 0.02; // s

	        oscillator.frequency.setValueAtTime(90 + 15 * _len, start);
	        oscillator.frequency.linearRampToValueAtTime(30 + 7.5 * _len, start + 0.5 - _len / 35);
	        gainNode2.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.5 - _len / 35);
	        stopAudioTime2 = 0.5 - _len / 35;
	        break;
	      }
	    // Hi-hat

	    case 42: // Closed High-Hat

	    case 44:
	      // Pedal High-Hat
	      {
	        // w
	        source.playbackRate.value = 1;

	        if (option.pitch == 42) {
	          gainNode.gain.setValueAtTime(velocity * 0.8, start);
	        } else {
	          gainNode.gain.setValueAtTime(0, start);
	          gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.014);
	        }

	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 46:
	      // Open Hihat
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.35, start);
	        source.playbackRate.linearRampToValueAtTime(0.6, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.3);
	        gainNode.gain.setValueAtTime(velocity * 1.1, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 1.5; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }
	    // Cymbal

	    case 49: // Crash Cymbal 1

	    case 57:
	      // Crash Cymbal 2
	      {
	        // w
	        var r = option.pitch == 49 ? 0.3 : 0.5;
	        var r2 = option.pitch == 49 ? 0.4 : 0.7;
	        source.playbackRate.setValueAtTime(r, start);
	        source.playbackRate.linearRampToValueAtTime(r2, start + 0.15);
	        source.playbackRate.linearRampToValueAtTime(0.9, start + 0.4);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 51: // Ride Cymbal 1

	    case 59:
	      // Ride Cymbal 2
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.9, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        var f = option.pitch == 51 ? 372 : 400;
	        oscillator.frequency.setValueAtTime(f, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.4, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 52:
	      // Chinese Cymbal
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.17, start);
	        source.playbackRate.linearRampToValueAtTime(0.25, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.6);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(382, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 53:
	      // Ride Bell
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.6, start);
	        gainNode.gain.setValueAtTime(velocity, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(377, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.35);
	        stopAudioTime2 = 2;
	        break;
	      }

	    case 55:
	      // Splash Cymbal
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.5, start);
	        source.playbackRate.linearRampToValueAtTime(0.8, start + 0.1);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.6);
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.3);
	        stopAudioTime = 1.75; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }
	    // Bell

	    case 54: // Tambourine

	    case 56:
	      // Cowbell
	      {
	        // w
	        source.playbackRate.setValueAtTime(1, start);
	        var v = option.pitch == 54 ? 1 : 0.4;

	        var _len2 = option.pitch == 54 ? 0.01 : 0;

	        gainNode.gain.setValueAtTime(velocity * v / 2, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * v, start + _len2);
	        gainNode.gain.setTargetAtTime(0, start + _len2, 0.05);
	        stopAudioTime = 0.3; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 54 ? 6000 : 495, start);
	        v = option.pitch == 54 ? 1 : 2;
	        gainNode2.gain.setValueAtTime(velocity * v / 2, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * v, start + _len2);
	        gainNode2.gain.setTargetAtTime(0, start + _len2, 0.05);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 58:
	      // Vibraslap
	      {
	        // w s
	        source.playbackRate.setValueAtTime(0.6, start);
	        source.playbackRate.linearRampToValueAtTime(1, start + 0.8);
	        var _len3 = 40;
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);

	        for (var i = 0; i < _len3; i++) {
	          gainNode.gain.linearRampToValueAtTime(velocity * 0.1 * (_len3 - i) / _len3, start + i / _len3 * 0.8);
	          gainNode.gain.linearRampToValueAtTime(velocity * 1.5 * (_len3 - (i + 1)) / _len3, start + (i + 0.99) / _len3 * 0.8);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.025 * (_len3 - i) / _len3, start + i / _len3 * 0.8);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.25 * (_len3 - (i + 1)) / _len3, start + (i + 0.99) / _len3 * 0.8);
	        }

	        gainNode.gain.linearRampToValueAtTime(0, start + 0.8);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.8);
	        stopAudioTime = 0.8; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(1000, start);
	        stopAudioTime2 = 0.8;
	        break;
	      }

	    case 80:
	      // Mute Triangle
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.015);
	        stopAudioTime = 0.2; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(6000, start);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.02);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 81:
	      // Open Triangle
	      {
	        // w
	        source.playbackRate.value = 5;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.08);
	        stopAudioTime = 0.75; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(6000, start);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.18);
	        stopAudioTime2 = 1;
	        break;
	      }
	    // Other Percussion

	    case 60: // High Bongo

	    case 61: // Low Bongo

	    case 62: // Mute High Conga

	    case 63: // Open High Conga

	    case 64:
	      // Low Conga
	      {
	        var p = option.pitch;

	        var _r = p == 60 ? 700 : p == 61 ? 282 : p == 62 ? 385 : p == 63 ? 295 : 210;

	        var _len4 = p == 60 ? 0.08 : p == 61 ? 0.1 : p == 62 ? 0.03 : p == 63 ? 0.12 : 0.15; // w


	        source.playbackRate.value = 0.03;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        stopAudioTime = 0.03; // s

	        oscillator.frequency.setValueAtTime(_r * 0.97, start);
	        oscillator.frequency.linearRampToValueAtTime(_r, start + _len4);
	        gainNode2.gain.setValueAtTime(velocity * 1.8, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + _len4);
	        stopAudioTime2 = _len4;
	        break;
	      }

	    case 65: // High Timbale

	    case 66:
	      // Low Timbale
	      {
	        var _len5 = option.pitch == 65 ? 0.22 : 0.25; // w


	        source.playbackRate.setValueAtTime(option.pitch == 65 ? 0.25 : 0.22, start);
	        source.playbackRate.linearRampToValueAtTime(option.pitch == 65 ? 0.2 : 0.18, start + _len5);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.2, start + _len5 / 3.5);
	        gainNode.gain.linearRampToValueAtTime(0, start + _len5);
	        stopAudioTime = _len5; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 65 ? 190 * 1.07 : 136 * 1.07, start);
	        oscillator.frequency.linearRampToValueAtTime(option.pitch == 65 ? 190 : 136, start + 0.1);
	        gainNode2.gain.setValueAtTime(velocity * 3.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.08);
	        stopAudioTime2 = 1;
	        break;
	      }

	    case 67: // High Agogo

	    case 68:
	      // Low Agogo
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + 0.02);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 67 ? 1430 : 1055, start);
	        gainNode2.gain.setValueAtTime(velocity * 2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.06);
	        stopAudioTime2 = 0.75;
	        break;
	      }

	    case 69:
	      // Cabasa
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.3, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.03);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime = 0.08; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 70:
	      // Maracas
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.06);
	        stopAudioTime = 0.06; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 71: // Short Whistle

	    case 72:
	      // Long Whistle
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        var _len6 = option.pitch == 71 ? 0.07 : 0.4;

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(option.pitch == 71 ? 2408 : 2105, start);
	        gainNode2.gain.setValueAtTime(0, start);

	        for (var _i = 0; _i < _len6 * 74; _i++) {
	          gainNode2.gain.linearRampToValueAtTime(velocity * 2.5, start + (_i + 0.2) / 75);
	          gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + (_i + 0.9) / 75);
	        }

	        gainNode2.gain.linearRampToValueAtTime(0, start + _len6);
	        stopAudioTime2 = _len6;
	        break;
	      }

	    case 73: // Short Guiro

	    case 74:
	      // Long Guiro
	      {
	        // w
	        var _len7 = option.pitch == 73 ? 0.05 : 0.35;

	        source.playbackRate.setValueAtTime(option.pitch == 73 ? 0.2 : 0.2, start);
	        source.playbackRate.linearRampToValueAtTime(option.pitch == 73 ? 0.7 : 0.5, start + _len7);
	        gainNode.gain.value = velocity * 0.2;

	        for (var _i2 = 0; _i2 < _len7 * 100; _i2++) {
	          gainNode.gain.setValueAtTime(velocity * 0.4, start + _i2 / 100);
	          gainNode.gain.setValueAtTime(velocity * 0.9, start + (_i2 + 0.7) / 100);
	        }

	        stopAudioTime = _len7; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 75:
	      // Claves
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        oscillator.frequency.setValueAtTime(2181, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.setValueAtTime(velocity * 2, start + 0.005);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1, start + 0.015);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.025);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 76: // High Wood Block

	    case 77:
	      // Low Wood Block
	      {
	        // w
	        source.playbackRate.value = 0.1;
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.015);
	        stopAudioTime = 0.015; // s

	        oscillator.frequency.setValueAtTime(option.pitch == 76 ? 800 : 600, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.005);
	        gainNode2.gain.setTargetAtTime(0, start + 0.005, 0.02);
	        stopAudioTime2 = 0.2;
	        break;
	      }

	    case 78: // Close Cuica

	    case 79:
	      // Open Cuica
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        var _len8 = 0.18;

	        var _f = option.pitch == 78 ? 750 : 270;

	        oscillator.frequency.setValueAtTime(_f, start);
	        oscillator.frequency.linearRampToValueAtTime(_f, start + _len8 / 3);
	        if (option.pitch == 78) oscillator.frequency.linearRampToValueAtTime(_f * 0.9, start + _len8);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.005);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + 0.02);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.04);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 2, start + _len8 / 4 * 3);
	        gainNode2.gain.linearRampToValueAtTime(0, start + _len8);
	        stopAudioTime2 = _len8;
	        break;
	      }
	    // GS, GM2

	    case 27:
	      // High Q
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.002);
	        stopAudioTime = 0.002; // s

	        oscillator.frequency.setValueAtTime(1500, start);
	        oscillator.frequency.linearRampToValueAtTime(280, start + 0.015);
	        oscillator.frequency.linearRampToValueAtTime(0, start + 0.07);
	        gainNode2.gain.setValueAtTime(velocity * 1.9, start);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.07);
	        stopAudioTime2 = 0.07;
	        break;
	      }

	    case 28:
	      // Slap
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);
	        gainNode.gain.setValueAtTime(velocity * 1.1, start + 0.0101);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);
	        gainNode.gain.setValueAtTime(velocity * 0.9, start + 0.0201);
	        gainNode.gain.setTargetAtTime(0, start + 0.0201, 0.03);
	        stopAudioTime = 0.2; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 29: // Scratch Push

	    case 30:
	      // Scratch Pull
	      {
	        var t1 = option.pitch == 29 ? 0.05 : 0.07;
	        var t2 = option.pitch == 29 ? 0.06 : 0.09;
	        var t3 = option.pitch == 29 ? 0.07 : 0.11;
	        var t4 = option.pitch == 29 ? 0.1 : 0.15;
	        var t5 = option.pitch == 29 ? 0.25 : 0.4; // w

	        var r1 = option.pitch == 29 ? 0.1 : 0.06;

	        var _r2 = option.pitch == 29 ? 0.3 : 0.2;

	        var r3 = option.pitch == 29 ? 0.18 : 0.12;
	        source.playbackRate.setValueAtTime(r1, start);
	        source.playbackRate.linearRampToValueAtTime(_r2, start + t1);
	        source.playbackRate.linearRampToValueAtTime(0, start + t2);
	        source.playbackRate.linearRampToValueAtTime(_r2, start + t3);
	        source.playbackRate.linearRampToValueAtTime(r3, start + t4);
	        source.playbackRate.linearRampToValueAtTime(0, start + t5);
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.4, start + t1);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + t3);
	        gainNode.gain.linearRampToValueAtTime(velocity * 0.3, start + t4);
	        gainNode.gain.linearRampToValueAtTime(0, start + t5);
	        stopAudioTime = t5; // s

	        var r4 = option.pitch == 29 ? 500 : 400;
	        var r5 = option.pitch == 29 ? 1950 : 1200;
	        var r6 = option.pitch == 29 ? 430 : 250;
	        oscillator.frequency.setValueAtTime(r4, start);
	        oscillator.frequency.linearRampToValueAtTime(r5, start + t1);
	        oscillator.frequency.linearRampToValueAtTime(0, start + t2);
	        oscillator.frequency.linearRampToValueAtTime(r5, start + t3);
	        oscillator.frequency.linearRampToValueAtTime(r6, start + t4);
	        oscillator.frequency.linearRampToValueAtTime(0, start + t5);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + t1);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.2, start + t3);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.6, start + t4);
	        gainNode2.gain.linearRampToValueAtTime(0, start + t5);
	        stopAudioTime2 = t5;
	        break;
	      }

	    case 31:
	      // Sticks
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.4, start);
	        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.015);
	        gainNode.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.035);
	        stopAudioTime = 0.3; // s

	        oscillator.frequency.setValueAtTime(3140, start);
	        gainNode2.gain.setValueAtTime(velocity * 1.2, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.012);
	        stopAudioTime2 = 0.3;
	        break;
	      }

	    case 32:
	      // Square Click
	      {
	        // w
	        gainNode.gain.value = 0;
	        stopAudioTime = 0; // s

	        oscillator.type = "square";
	        oscillator.frequency.setValueAtTime(333, start);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 4, start + 0.0016);
	        gainNode2.gain.linearRampToValueAtTime(0, start + 0.0032);
	        stopAudioTime2 = 0.0032;
	        break;
	      }

	    case 33: // Metronome Click

	    case 34:
	      // Metronome Bell
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.17, start);
	        source.playbackRate.linearRampToValueAtTime(0.22, start + 0.01);
	        gainNode.gain.setValueAtTime(velocity * 1.5, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.015);
	        stopAudioTime = 0.3; // s

	        if (option.pitch == 34) {
	          oscillator.frequency.setValueAtTime(2040, start);
	          gainNode2.gain.setValueAtTime(velocity * 1, start);
	          gainNode2.gain.setTargetAtTime(0, start, 0.12);
	          stopAudioTime2 = 1.1;
	        } else {
	          gainNode2.gain.value = 0;
	          stopAudioTime2 = 0;
	        }

	        break;
	      }

	    case 82:
	      // Shaker
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode.gain.linearRampToValueAtTime(velocity, start + 0.02);
	        gainNode.gain.linearRampToValueAtTime(0, start + 0.07);
	        stopAudioTime = 0.07; // s

	        gainNode2.gain.value = 0;
	        stopAudioTime2 = 0;
	        break;
	      }

	    case 83:
	      // Jingle Bell
	      {
	        // w
	        source.playbackRate.value = 1;
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 1.2, start + 0.015);
	        gainNode.gain.setTargetAtTime(0, start + 0.015, 0.06);
	        stopAudioTime = 0.5; // s

	        oscillator.type = "triangle";
	        oscillator.frequency.setValueAtTime(2709, start);
	        oscillator.frequency.linearRampToValueAtTime(2657, start + 0.3);
	        gainNode2.gain.setValueAtTime(0, start);
	        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.025);
	        gainNode2.gain.setTargetAtTime(0, start + 0.025, 0.07);
	        stopAudioTime2 = 0.5;
	        break;
	      }

	    case 84:
	      // Bell Tree
	      {
	        // w s
	        var invert = false;
	        source.playbackRate.value = 1;

	        for (var _i3 = 0; _i3 < 28; _i3++) {
	          gainNode.gain.setValueAtTime(velocity * 0.1, start + _i3 / 24 * 0.45);
	          gainNode.gain.setTargetAtTime(0, start + _i3 / 24 * 0.45, 0.01);
	          oscillator.frequency.setValueAtTime(1380 * (1 + (invert ? (24 - _i3) / 24 : _i3 / 24)), start + _i3 / 24 * 0.45);
	          gainNode2.gain.setValueAtTime(velocity * (0.2 + _i3 / 24), start + _i3 / 24 * 0.45);
	          gainNode2.gain.setTargetAtTime(0, start + _i3 / 24 * 0.45, _i3 == 27 ? 0.2 : 0.01);
	        }

	        stopAudioTime = 0.5;
	        stopAudioTime2 = 1.5;
	        break;
	      }

	    case 85:
	      // Castanets
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.35, start);
	        gainNode.gain.setValueAtTime(velocity * 1.3, start);
	        gainNode.gain.setTargetAtTime(0, start, 0.01);
	        stopAudioTime = 0.1; // s

	        oscillator.frequency.setValueAtTime(1730, start);
	        gainNode2.gain.setValueAtTime(velocity * 0.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, 0.01);
	        stopAudioTime2 = 0.1;
	        break;
	      }

	    case 86: // Mute Surdo

	    case 87:
	      // Open Surdo
	      {
	        // w
	        source.playbackRate.setValueAtTime(0.020, start);
	        source.playbackRate.linearRampToValueAtTime(0.015, start + 0.5);
	        gainNode.gain.setValueAtTime(0, start);
	        gainNode.gain.linearRampToValueAtTime(velocity * 2, start + 0.005);
	        gainNode.gain.setTargetAtTime(0, start + 0.005, option.pitch == 86 ? 0.03 : 0.06);
	        stopAudioTime = 0.5; // s

	        oscillator.frequency.setValueAtTime(88, start);
	        oscillator.frequency.linearRampToValueAtTime(86, start + 0.3);
	        gainNode2.gain.setValueAtTime(velocity * 2.5, start);
	        gainNode2.gain.setTargetAtTime(0, start, option.pitch == 86 ? 0.1 : 0.3);
	        stopAudioTime2 = option.pitch == 86 ? 0.5 : 1.5;
	        break;
	      }

	    default:
	      {
	        source.playbackRate.value = option.pitch / 69 * 2;
	        stopAudioTime = 0.05;
	        stopAudioTime2 = 0;
	        break;
	      }
	  } // åããã©ã ã®é³ãéãªããªãããã«ããæ©è½
	  // ãã©ã åçä¸­ã«æ¬¡ã®åããã©ã ãããé³´ãå ´åãæ¬¡ãé³´ãåã«æ­¢ãã¦é³ãéãªããªãããã«ããï¼åæçºé³æ°ã®å¢å ãè»½æ¸ããï¼


	  if (!this.settings.isSameDrumSoundOverlap && nextSameNoteOnInterval != -1) {
	    if (stopAudioTime > nextSameNoteOnInterval) {
	      stopAudioTime = nextSameNoteOnInterval;
	    }

	    if (stopAudioTime2 > nextSameNoteOnInterval) {
	      stopAudioTime2 = nextSameNoteOnInterval;
	    }
	  } // ãã©ã é³åæ­¢æéãè¨­å®


	  this.stopAudioNode(source, start + stopAudioTime, stopGainNode);
	  this.stopAudioNode(oscillator, start + stopAudioTime2, stopGainNode2); // ãã©ã åæ­¢æéãè¨­å®

	  option.drumStopTime = option.startTime + (stopAudioTime >= stopAudioTime2 ? stopAudioTime : stopAudioTime2); // é³ãã¹ããããããé¢æ°ãè¿ã //

	  return function () {
	    _newArrowCheck(this, _this);

	    this.stopAudioNode(source, 0, stopGainNode, true);
	    this.stopAudioNode(oscillator, 0, stopGainNode2, true);
	  }.bind(this);
	}

	function stopAudioNode(tar, time, stopGainNode, isNoiseCut) {
	  var isImmed = time <= this.context.currentTime; // å³æã¹ããããï¼
	  // äºç´ã¹ããã //

	  var vol1Time = time - 0.005;
	  var stopTime = time; // æéè¨­å® //

	  if (isImmed) {
	    // å³æã¹ããã
	    if (!isNoiseCut) {
	      stopTime = this.context.currentTime;
	    } else {
	      // ãã¤ãºã«ãã
	      vol1Time = this.context.currentTime;
	      stopTime = this.context.currentTime + 0.005;
	    }
	  } // é³ã®åæ­¢ //


	  try {
	    // éå¸¸ã®é³åæ­¢å¦ç
	    if (!isNoiseCut) {
	      tar.stop(stopTime);
	    } else {
	      // ãã¤ãºã«ããï¼é³ã®çµããã«ç­ããã§ã¼ãã¢ã¦ããå¥ããï¼
	      tar.stop(stopTime);
	      stopGainNode.gain.cancelScheduledValues(0);
	      stopGainNode.gain.setValueAtTime(1, vol1Time);
	      stopGainNode.gain.linearRampToValueAtTime(0, stopTime);
	    }
	  } catch (e) {
	    // iOSç¨ (stopãï¼åä»¥ä¸ä½¿ããªãã®ã§ãä»£ããã«stopGainNodeã§ãã¥ã¼ãã«ãã)
	    stopGainNode.gain.cancelScheduledValues(0);

	    if (!isNoiseCut) {
	      stopGainNode.gain.setValueAtTime(0, stopTime);
	    } else {
	      // ãã¤ãºã«ããï¼é³ã®çµããã«ç­ããã§ã¼ãã¢ã¦ããå¥ããï¼
	      stopGainNode.gain.setValueAtTime(1, vol1Time);
	      stopGainNode.gain.linearRampToValueAtTime(0, stopTime);
	    }
	  }
	}

	function pushFunc(tar) {
	  if (!tar.note && !tar.rootTimeout && !tar.pan && !this.trigger.isNoteTrigger) {
	    return;
	  }

	  this.states.stopFuncs.push(tar);
	}

	var $some$1 = arrayIteration.some;
	var STRICT_METHOD$2 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$3 = arrayMethodUsesToLength('some'); // `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some

	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$3
	}, {
	  some: function some(callbackfn
	  /* , thisArg */
	  ) {
	    return $some$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	function clearFunc(tar1, tar2) {
	  var _this = this;

	  if (tar1 != "note" && tar1 != "rootTimeout" && tar1 != "pan" && !this.trigger.isNoteTrigger) {
	    return;
	  }

	  this.states.stopFuncs.some(function (n, i, ary) {
	    _newArrowCheck(this, _this);

	    if (n[tar1] == tar2) {
	      ArrayUtil["delete"](ary, i); // ary.splice(i, 1); ãé«éå

	      return true;
	    }
	  }.bind(this));
	}

	/**
	 * tickããtime(ç§)ãæ±ãã
	 * @param {number} tick
	 * @returns {number} time(ç§)
	 */
	function getTime$1(tick) {
	  var imid = -1; // tempoå¤æ´ãããå ´åãtickãæ¤ç´¢ãã //

	  if (this.tempoTrack && this.tempoTrack.length >= 1) {
	    // æå¾ã®tickãè¶ããå ´åãæå¾ã®timeãè¿ã //
	    if (tick >= this.tempoTrack[this.tempoTrack.length - 1].timing) {
	      return this.tempoTrack[this.tempoTrack.length - 1].time;
	    } // äºåæ¢ç´¢ã§tickãæ¢ã //


	    var imin = 0;
	    var imax = this.tempoTrack.length - 1;

	    while (true) {
	      imid = Math.floor(imin + (imax - imin) / 2);
	      var tempTiming = this.tempoTrack[imid].timing;

	      if (tick < tempTiming) {
	        imax = imid - 1;
	      } else if (tick > tempTiming) {
	        imin = imid + 1;
	      } else {
	        break;
	      }

	      if (imin > imax) {
	        if (tick < tempTiming) imid--;
	        break;
	      }
	    }
	  }

	  var time = 0;
	  var baseTiming = 0;
	  var tempo = 120;

	  if (imid >= 0) {
	    // tickãæ¢ç´¢ãã¦è¦ã¤ãã£ãå ´å
	    // å¼æ°tickã«ä¸çªè¿ãtickãåå¾
	    var tempoObj = this.tempoTrack[imid];
	    time = tempoObj.time;
	    baseTiming = tempoObj.timing;
	    tempo = tempoObj.value;
	  } // tickããtimeãç®åºãã
	  // å¼æ°tickã«ä¸çªè¿ãtickã®time ï¼ å¼æ°tickããæ®ãã®timeãç®åº ï¼ ç¾å¨ã®time


	  time += 60 / tempo / this.settings.resolution * (tick - baseTiming);
	  return time;
	}

	/**
	 * time(ç§)ããtickãæ±ãã
	 * @param {number} time
	 * @returns {number} tick
	 */
	function getTiming(time) {
	  var imid = -1; // tempoå¤æ´ãããå ´åãtimeãæ¤ç´¢ãã //

	  if (this.tempoTrack && this.tempoTrack.length >= 1) {
	    // æå¾ã®timeãè¶ããå ´åãæå¾ã®tickãè¿ã
	    if (time >= this.tempoTrack[this.tempoTrack.length - 1].time) {
	      return this.tempoTrack[this.tempoTrack.length - 1].timing;
	    } // äºåæ¢ç´¢ã§timeãæ¢ã


	    var imin = 0;
	    var imax = this.tempoTrack.length - 1;

	    while (true) {
	      imid = Math.floor(imin + (imax - imin) / 2);
	      var tempTime = this.tempoTrack[imid].time;

	      if (time < tempTime) {
	        imax = imid - 1;
	      } else if (time > tempTime) {
	        imin = imid + 1;
	      } else {
	        break;
	      }

	      if (imin > imax) {
	        if (time < tempTime) imid--;
	        break;
	      }
	    }
	  }

	  var baseTime = 0;
	  var tick = 0;
	  var tempo = 120;

	  if (imid >= 0) {
	    // timeãæ¢ç´¢ãã¦è¦ã¤ãã£ãå ´å
	    // å¼æ°timeã«ä¸çªè¿ãtimeãåå¾
	    var tempoObj = this.tempoTrack[imid];
	    baseTime = tempoObj.time;
	    tick = tempoObj.timing;
	    tempo = tempoObj.value;
	  } // timeããtickãç®åºãã
	  // å¼æ°timeã«ä¸çªè¿ãtimeã®tick ï¼ ç¾å¨timeããæ®ãã®tickãç®åº ï¼ ç¾å¨ã®tick


	  tick += (time - baseTime) / (60 / tempo / this.settings.resolution);
	  return tick;
	}

	var PerformanceUtil = /*#__PURE__*/function () {
	  function PerformanceUtil() {
	    _classCallCheck(this, PerformanceUtil);
	  }

	  _createClass(PerformanceUtil, null, [{
	    key: "measureReverb",

	    /**
	     * 0.5ç§ããã©ã¼ãã³ã¹è¨æ¸¬ãã¦ããªãã¼ãONã§è¯ããããå¤æ­ãã
	     * @returns {boolean} ãªãã¼ãONã§è¯ããã
	     */
	    value: function measureReverb() {
	      var max = 500000; // 0.5ç§ä»¥åã«ããã¾ã§è¨ç®ã§ããã°ãªãã¼ãON

	      var startTime = performance.now();
	      var i = 0;

	      for (; i < max; i++) {
	        if (performance.now() - startTime >= 500) break;
	      }

	      if (this.debug) {
	        console.log("measureReverb", i, performance.now() - startTime);
	      }

	      if (i < max) return false;
	      return true;
	    }
	  }]);

	  return PerformanceUtil;
	}();

	function parseHeader(info) {
	  // é¢æ°å¼ã³åºãåãããã¼ã¿ãããã //
	  var smf = info.smf; // SMFã®ããããã£ã³ã¯ãè§£æ //

	  var p = 4;
	  var header = {};
	  header.size = ParseUtil.getInt(smf, 4, 8);
	  header.format = smf[9];
	  header.trackcount = ParseUtil.getInt(smf, 10, 12);
	  header.timemanage = smf[12];
	  header.resolution = ParseUtil.getInt(smf, 12, 14); // TODO 0é¤ç®é²æ­¢ã15bitç®1ã®ã¨ããhttps://sites.google.com/site/yyagisite/material/smfspec#ConductorTrack

	  p += 4 + header.size; // å¤æ°ãç¨æ //

	  var channels = [];
	  var chSize = this.settings.isWebMIDI ? 17 : 16; // WebMIDIç¨ã«17chã«å¨ã¦ã®ã¤ãã³ããå¥ãããã17chåä½ã

	  for (var i = 0; i < chSize; i++) {
	    var channel = {};
	    channels.push(channel); // smfãèª­ãé çªãè¨é²ããç´¢å¼éåãä½ã //
	    // åä»ãéåããªã¹ãæ§é ã®éåã®ããã«ä½¿ãï¼ãªã¹ãæ§é ã«ãããã¨ã§æ¿å¥å¦çãé«éåããï¼
	    // [tick, smfMesLength, smfPtr, nextIndicesPtr, ...]

	    channel.indices = [];
	    channel.indicesLength = 0;
	    channel.indicesHead = -1; // åé ­ã®ãã¤ã³ã¿

	    channel.indicesFoot = 0; // æ«å°¾ã®ãã¤ã³ã¿

	    channel.indicesCur = 0; // ç¾å¨ã®insertç¨ãã¤ã³ã¿

	    channel.indicesPre = 0; // ååã®insertç¨ãã¤ã³ã¿

	    channel.notes = [];
	  } // é¢æ°å¼ã³åºãåã«ãã¼ã¿ãè¿ã //


	  info.p = p;
	  info.header = header;
	  info.channels = channels;
	  return info;
	}

	function parseTrack(info) {
	  // é¢æ°å¼ã³åºãåãããã¼ã¿ãããã //
	  var smf = info.smf;
	  var p = info.p;
	  var header = info.header;
	  var channels = info.channels; // SMFã®ãã©ãã¯ãã£ã³ã¯ã®è§£æã»"SMFèª­ã¿è¾¼ã¿é åºéå"ãä½æ //
	  //   å¨ãã©ãã¯ãè§£æããªãããSMFãèª­ãé çªãè¨é²ããéåãä½æãã
	  //   èª­ã¿è¾¼ãé çªã¯ããã®è§£æã§ãã«ã¿ã¿ã¤ã é ã«ãªãããã½ã¼ããã¦ãã
	  //   SMFã®MIDIã¤ãã³ãè§£ææã¯ãä¸è¨éåãããæ¬¡ã¯MIDIãã¡ã¤ã«ã®ä½ãã¤ãç®ãè¦ããããåå¾ãã¦è§£æãã
	  //   ä¸è¨éåã¯ãªã¹ãæ§é ã®éåã®ããã«ä½¿ãï¼ãªã¹ãæ§é ã«ãããã¨ã§éåã®insertå¦çãé«éåããï¼
	  // 
	  // â éåã¤ã¡ã¼ã¸ï¼jsoné¢¨ï¼â 
	  // [
	  //     {
	  //         tick : ãã®MIDIã¤ãã³ãã®Tick,
	  //         smfMesLength : ï¼ã¤ã®MIDIã¤ãã³ãã®é·ã,
	  //         smfPtr : ãã®MIDIã¤ãã³ãã¯MIDIãã¡ã¤ã«ã®ä½ãã¤ãç®ã«ããã,
	  //         nextIndicesPtr : æ¬¡ã®ãªãã¸ã§ã¯ãã¯ãªã¹ãéåã®ä½çªç®ã«ããã
	  //     },
	  //     ...
	  // ]
	  // 
	  // â å®éã®éåã¤ã¡ã¼ã¸â 
	  // [tick, smfMesLength, smfPtr, nextIndicesPtr, ...]

	  var tempoTrack = [];
	  var beatTrack = [];
	  var songLength = 0;

	  for (var t = 0; t < header.trackcount; t++) {
	    // "MTrk"
	    if (smf[p] != 77 || smf[p + 1] != 84 || smf[p + 2] != 114 || smf[p + 3] != 107) return "Irregular SMF.";
	    p += 4;
	    var endPoint = p + 4 + ParseUtil.getInt(smf, p, p + 4);
	    p += 4;
	    var tick = 0;
	    var tempo = 120;
	    var tempoCurTick = 0;
	    var tempoCurTime = 0;
	    var lastState = 1;
	    var dt = void 0;

	    while (p < endPoint) {
	      // DeltaTime
	      if (lastState != null) {
	        var lengthAry = ParseUtil.variableLengthToInt(smf, p, p + 5);
	        dt = lengthAry[0];
	        tick += dt;
	        p += lengthAry[1];
	      }

	      var cashP = p; // WebMIDIç¨
	      // Events

	      var mes0 = smf[p] >> 4; // Math.floor(smf[p] / 0x10)

	      switch (mes0) {
	        case 0x8: // Note OFF - 8[ch], Pitch, Velocity

	        case 0x9: // Note ON - 9[ch], Pitch, Velocity

	        case 0xA: // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?

	        case 0xB: // Control Change - B[ch],,

	        case 0xE:
	          // PitchBend Change - E[ch],,
	          {
	            // ãã£ã³ãã«æ¯ã«ä»åããå¾ã«è§£æãã
	            lastState = smf[p];
	            var ch = channels[lastState & 0x0F];
	            ParseUtil.chIndicesInsert(this, ch, tick, p, 3);
	            p += 3;
	            break;
	          }

	        case 0xC: // Program Change - C[ch],

	        case 0xD:
	          // Channel Pre - D[ch],
	          {
	            // ãã£ã³ãã«æ¯ã«ä»åããå¾ã«è§£æãã
	            lastState = smf[p];
	            var _ch = channels[lastState & 0x0F];
	            ParseUtil.chIndicesInsert(this, _ch, tick, p, 2);
	            p += 2;
	            break;
	          }
	        // SysEx Events or Meta Events - F[ch], ...

	        case 0xF:
	          {
	            //lastState = smf[p]; <- ã©ã³ãã³ã°ã¹ãã¼ãã¯ç¡ã
	            switch (smf[p]) {
	              case 0xF0:
	              case 0xF7:
	                {
	                  // SysEx Events
	                  var _lengthAry = ParseUtil.variableLengthToInt(smf, p + 1, p + 1 + 4); // Master Volume
	                  // 0xF0, size, 0x7f, 0x7f, 0x04, 0x01, 0xNN, volume, 0xF7


	                  if (_lengthAry[0] >= 7 && smf[p + 2] == 0x7f && smf[p + 3] == 0x7f && smf[p + 4] == 0x04 && smf[p + 5] == 0x01) {
	                    // å¨ãã£ã³ãã«ã«MasterVolumeã¤ãã³ããæ¿å¥ãã
	                    for (var i = 0; i < 16; i++) {
	                      var _ch2 = channels[i];
	                      ParseUtil.chIndicesInsert(this, _ch2, tick, p, _lengthAry[0]);
	                    }
	                  }

	                  p += 1 + _lengthAry[1] + _lengthAry[0];
	                  break;
	                }

	              case 0xF1:
	                p += 2;
	                break;

	              case 0xF2:
	                p += 3;
	                break;

	              case 0xF3:
	                p += 2;
	                break;

	              case 0xF6:
	              case 0xF8:
	              case 0xFA:
	              case 0xFB:
	              case 0xFC:
	              case 0xFE:
	                p += 1;
	                break;

	              case 0xFF:
	                {
	                  // Meta Events
	                  switch (smf[p + 1]) {
	                    case 0x00:
	                    case 0x01:
	                    case 0x02:
	                    case 0x03:
	                    case 0x04:
	                    case 0x05:
	                    case 0x06:
	                    case 0x07:
	                    case 0x20:
	                      break;

	                    case 0x2F:
	                      tick += (this.settings.isSkipEnding ? 0 : header.resolution) - dt;
	                      break;

	                    case 0x51:
	                      // Tempo
	                      // å¨ãã£ã³ãã«ã«Tempoã¤ãã³ããæ¿å¥ãã
	                      for (var _i = 0; _i < 16; _i++) {
	                        var _ch3 = channels[_i];
	                        ParseUtil.chIndicesInsert(this, _ch3, tick, p, 6);
	                      }

	                      tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);
	                      tempoCurTick = tick;
	                      tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	                      tempoTrack.push({
	                        timing: tick,
	                        time: tempoCurTime,
	                        value: tempo
	                      });
	                      break;

	                    case 0x54:
	                      break;

	                    case 0x58:
	                      // Beat
	                      beatTrack.push({
	                        timing: tick,
	                        value: [smf[p + 3], Math.pow(2, smf[p + 4])]
	                      });
	                      break;
	                  }

	                  var _lengthAry2 = ParseUtil.variableLengthToInt(smf, p + 2, p + 2 + 4);

	                  p += 2 + _lengthAry2[1] + _lengthAry2[0];
	                  break;
	                }
	            }

	            break;
	          }

	        default:
	          {
	            if (lastState == null) return "Irregular SMF. (" + p + " byte addr)";
	            p--;
	            smf[p] = lastState; // ä¸æ¸ã

	            lastState = null;
	          }
	      } // WebMIDIAPI


	      if (this.settings.isWebMIDI) {
	        if (lastState != null) {
	          // WebMIDIç¨ã«17chã«å¨ã¦ã®MIDIã¤ãã³ããå¥ãã
	          ParseUtil.chIndicesInsert(this, channels[16], tick, cashP, p - cashP);
	        }
	      }
	    }

	    if (!this.settings.isSkipEnding && songLength < tick) songLength = tick; // ãªã¹ãéåã®ãã¤ã³ã¿ãåæå

	    for (var _i2 = 0; _i2 < channels.length; _i2++) {
	      channels[_i2].indicesCur = channels[_i2].indicesHead;
	      channels[_i2].indicesPre = channels[_i2].indicesHead;
	    }
	  } // é¢æ°å¼ã³åºãåã«ãã¼ã¿ãè¿ã //


	  info.p = p;
	  info.tempoTrack = tempoTrack;
	  info.beatTrack = beatTrack;
	  info.songLength = songLength;
	  return info;
	}

	function parseEvent(info) {
	  var _this = this;

	  // é¢æ°å¼ã³åºãåãããã¼ã¿ãããã //
	  var smf = info.smf;
	  var header = info.header;
	  var channels = info.channels;
	  var tempoTrack = info.tempoTrack;
	  var songLength = info.songLength; // SMFã®MIDIã¤ãã³ãè§£æ //

	  var tempo;
	  var tempoCurTick;
	  var tempoCurTime;
	  var cc111Tick = -1;
	  var cc111Time = -1;
	  var firstNoteOnTiming = Number.MAX_SAFE_INTEGER; // æåã®ãã¼ããªã³ã®Tick

	  var firstNoteOnTime = Number.MAX_SAFE_INTEGER;
	  var lastNoteOffTiming = 0; // æå¾ã®ãã¼ããªãã®Tick

	  var lastNoteOffTime = 0; // Midi Events (0x8n - 0xEn) parse

	  var _loop = function _loop(ch) {
	    var channel = channels[ch];
	    var dataEntry = 2;
	    var pitchBend = 0;
	    var pan = 64;
	    var expression = 127;
	    var velocity = 100;
	    var modulation = 0;
	    var hold = 0;
	    var reverb = _this.isTonyu2 ? 0 : 10;
	    var chorus = 0;
	    var nrpnLsb = 127;
	    var nrpnMsb = 127;
	    var rpnLsb = 127;
	    var rpnMsb = 127;
	    var instrument = 0;
	    var masterVolume = 127;
	    tempo = 120;
	    tempoCurTick = 0;
	    tempoCurTime = 0;
	    var nowNoteOnIdxAry = [];
	    var indIdx = channel.indicesHead;
	    var indices = channel.indices;
	    var nextNoteOnAry = new Array(128);

	    var _loop3 = function _loop3() {
	      var _this3 = this;

	      var tick = indices[indIdx];
	      var p = indices[indIdx + 2];
	      var nextIdx = indices[indIdx + 3];
	      var time = 60 / tempo / header.resolution * (tick - tempoCurTick) + tempoCurTime; // Events

	      var mes0 = smf[p] >> 4; // Math.floor(smf[p] / 0x10)

	      switch (mes0) {
	        case 0x8: // Note OFF - 8[ch], Pitch, Velocity

	        case 0x9:
	          // Note ON - 9[ch], Pitch, Velocity
	          if (mes0 == 0x9 && smf[p + 2] != 0) {
	            // ãã¼ããªã³
	            // ãã¼ãæå ±ãå¥ã£ããªãã¸ã§ã¯ããä½æ //
	            var note = {
	              start: tick,
	              stop: null,
	              startTime: time,
	              stopTime: null,
	              pitch: smf[p + 1],
	              pitchBend: [{
	                timing: tick,
	                time: time,
	                value: pitchBend
	              }],
	              pan: [{
	                timing: tick,
	                time: time,
	                value: pan
	              }],
	              expression: [{
	                timing: tick,
	                time: time,
	                value: expression * (masterVolume / 127)
	              }],
	              velocity: smf[p + 2] / 127 * (velocity / 127),
	              modulation: [{
	                timing: tick,
	                time: time,
	                value: modulation
	              }],
	              holdBeforeStop: null,
	              reverb: [{
	                timing: tick,
	                time: time,
	                value: reverb
	              }],
	              chorus: [{
	                timing: tick,
	                time: time,
	                value: chorus
	              }],
	              instrument: instrument,
	              channel: ch,
	              nextSameNoteOnInterval: -1,
	              drumStopTime: 2 // åçæã«ä½¿ã

	            }; // ååé³´ã£ã¦ããåé³ãã¼ãã«æ¬¡ã®ãã¼ããªã³æéãå¥ãã //
	            // åé³ãã¼ããäºéåçããããªãå ´åã®ããã«è¨é²ãã //

	            var prevNote = nextNoteOnAry[smf[p + 1]];

	            if (prevNote) {
	              prevNote.nextSameNoteOnInterval = time - prevNote.startTime;
	            }

	            nextNoteOnAry[smf[p + 1]] = note; // åé³ãã¼ãããã¼ããªã³ä¸­ã®å ´åããã¼ããªãã«ãã //

	            nowNoteOnIdxAry.some(function (idx, i) {
	              _newArrowCheck(this, _this3);

	              var note = channel.notes[idx];

	              if (note.pitch == smf[p + 1] && note.stop == null) {
	                note.stop = tick;
	                note.stopTime = time;
	                ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); ãè»½éå
	              }
	            }.bind(this)); // ãã¼ããªã³ä¸­éåã«å¥ãã

	            nowNoteOnIdxAry.push(channel.notes.length); // notesä¸è¦§ã«noteãªãã¸ã§ã¯ããå¥ãã

	            channel.notes.push(note); // æåã®ãã¼ããªã³æéãè¨é² //

	            if (tick < firstNoteOnTiming) {
	              firstNoteOnTiming = tick;
	              firstNoteOnTime = time;
	            }
	          } else {
	            // ãã¼ããªã
	            // ãã¼ããªã³ä¸­éåããè©²å½ãã¼ããæ¢ãããã¼ããªãå¦çããã //
	            nowNoteOnIdxAry.some(function (idx, i) {
	              _newArrowCheck(this, _this3);

	              var note = channel.notes[idx];

	              if (note.pitch == smf[p + 1] && note.stop == null) {
	                if (hold >= _this.settings.holdOnValue) {
	                  // ãã¼ã«ããå¹ãã¦ããå ´å
	                  if (note.holdBeforeStop == null) {
	                    note.holdBeforeStop = [{
	                      timing: tick,
	                      time: time,
	                      value: hold
	                    }];
	                  }
	                } else {
	                  // ãã¼ã«ããã¦ããªãå ´å
	                  note.stop = tick;
	                  note.stopTime = time;
	                  ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); ãè»½éå
	                } // æå¾ã®ãã¼ããªãæéãè¨é² //


	                if (tick > lastNoteOffTiming) {
	                  lastNoteOffTiming = tick;
	                  lastNoteOffTime = time;
	                }

	                return true;
	              }
	            }.bind(this));
	          }

	          break;
	        // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?

	        case 0xA:
	          break;
	        // Control Change - B[ch],,

	        case 0xB:
	          switch (smf[p + 1]) {
	            case 1:
	              // modulation
	              modulation = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.modulation.push({
	                  timing: tick,
	                  time: time,
	                  value: modulation
	                });
	              }.bind(this));
	              break;

	            case 6:
	              if (rpnLsb == 0 && rpnMsb == 0) {
	                // RLSB=0 & RMSB=0 -> 6ã¯ããã
	                dataEntry = smf[p + 2];

	                if (dataEntry > 24) {
	                  dataEntry = 24;
	                }
	              }

	              break;

	            case 7:
	              velocity = smf[p + 2];
	              break;

	            case 10:
	              // Pan
	              pan = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.pan.push({
	                  timing: tick,
	                  time: time,
	                  value: pan
	                });
	              }.bind(this));
	              break;

	            case 11:
	              // Expression
	              expression = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.expression.push({
	                  timing: tick,
	                  time: time,
	                  value: expression * (masterVolume / 127)
	                });
	              }.bind(this));
	              break;

	            case 64:
	              // Hold1
	              hold = smf[p + 2];

	              if (hold < _this.settings.holdOnValue) {
	                for (var _i = nowNoteOnIdxAry.length - 1; _i >= 0; _i--) {
	                  var idx = nowNoteOnIdxAry[_i];
	                  var _note = channel.notes[idx];

	                  if (_note.stop == null && _note.holdBeforeStop != null) {
	                    _note.stop = tick;
	                    _note.stopTime = time;
	                    ArrayUtil["delete"](nowNoteOnIdxAry, _i); // nowNoteOnIdxAry.splice(i, 1); ãè»½éå
	                  }
	                }
	              }

	              break;

	            case 91:
	              // reverb
	              reverb = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.reverb.push({
	                  timing: tick,
	                  time: time,
	                  value: reverb
	                });
	              }.bind(this));
	              break;

	            case 93:
	              // chorus
	              chorus = smf[p + 2];
	              nowNoteOnIdxAry.forEach(function (idx) {
	                _newArrowCheck(this, _this3);

	                var note = channel.notes[idx];
	                note.chorus.push({
	                  timing: tick,
	                  time: time,
	                  value: chorus
	                });
	              }.bind(this));
	              break;

	            case 98:
	              nrpnLsb = smf[p + 2];
	              break;

	            case 99:
	              nrpnMsb = smf[p + 2];
	              break;

	            case 100:
	              rpnLsb = smf[p + 2];
	              break;

	            case 101:
	              rpnMsb = smf[p + 2];
	              break;

	            case 111:
	              // RPGãã¯ã¼ã«ç¨ã«ã¼ã(CC111)
	              if (cc111Tick == -1) {
	                cc111Tick = tick;
	                cc111Time = time;
	              }

	              break;
	          }

	          break;
	        // Program Change - C[ch],

	        case 0xC:
	          instrument = smf[p + 1];
	          break;
	        // Channel Pre - D[ch],

	        case 0xD:
	          break;
	        // PitchBend Change - E[ch],,

	        case 0xE:
	          pitchBend = (smf[p + 2] * 128 + smf[p + 1] - 8192) / 8192 * dataEntry;
	          nowNoteOnIdxAry.forEach(function (idx) {
	            _newArrowCheck(this, _this3);

	            var note = channel.notes[idx];
	            note.pitchBend.push({
	              timing: tick,
	              time: time,
	              value: pitchBend
	            });
	          }.bind(this));
	          break;

	        case 0xF:
	          //lastState = smf[p]; <- ã©ã³ãã³ã°ã¹ãã¼ãã¯ç¡ã
	          switch (smf[p]) {
	            case 0xF0:
	            case 0xF7:
	              // Master Volume
	              if (smf[p + 1] == 0x7f && smf[p + 2] == 0x7f && smf[p + 3] == 0x04 && smf[p + 4] == 0x01) {
	                var vol = smf[p + 6];
	                if (vol > 127) vol = 127;
	                masterVolume = vol;
	                nowNoteOnIdxAry.forEach(function (idx) {
	                  _newArrowCheck(this, _this3);

	                  var note = channel.notes[idx];
	                  note.expression.push({
	                    timing: tick,
	                    time: time,
	                    value: expression * (masterVolume / 127)
	                  });
	                }.bind(this));
	              }

	              break;

	            case 0xFF:
	              // Meta Events
	              switch (smf[p + 1]) {
	                case 0x51:
	                  // Tempo
	                  tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);
	                  tempoCurTick = tick;
	                  tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	                  break;
	              }

	              break;
	          }

	          break;

	        default:
	          {
	            return {
	              v: {
	                v: "Error parseSMF. "
	              }
	            };
	          }
	      }

	      indIdx = nextIdx;
	    };

	    while (indIdx != -1) {
	      var _ret2 = _loop3();

	      if (_typeof(_ret2) === "object") return _ret2.v;
	    }

	    channel.nowNoteOnIdxAry = nowNoteOnIdxAry;

	    if (!_this.debug) {
	      delete channel.indices;
	    }
	  };

	  for (var ch = 0; ch < 16; ch++) {
	    var _ret = _loop(ch);

	    if (_typeof(_ret) === "object") return _ret.v;
	  } // ãã¼ã«ããå¹ãã¦ãã¼ããªã³ã®ã¾ã¾ã«ãªã£ããã¼ãããã¼ããªããã //


	  for (var _ch = 0; _ch < 16; _ch++) {
	    var channel = channels[_ch];
	    var nowNoteOnIdxAry = channel.nowNoteOnIdxAry;

	    var _loop2 = function _loop2(i) {
	      var _this2 = this;

	      var note = channel.notes[nowNoteOnIdxAry[i]];

	      if (note.stop == null) {
	        note.stop = lastNoteOffTiming;
	        note.stopTime = lastNoteOffTime; // If (note.cc[x].timing > lastNoteOffTiming), delete note.cc[x]

	        var nameAry = ["pitchBend", "pan", "expression", "modulation", "reverb", "chorus"];
	        nameAry.forEach(function (name) {
	          _newArrowCheck(this, _this2);

	          var ccAry = note[name];

	          for (var i2 = ccAry.length - 1; i2 >= 1; i2--) {
	            var obj = ccAry[i2];

	            if (obj.timing > lastNoteOffTiming) {
	              ArrayUtil["delete"](ccAry, i2); // ccAry.splice(i2, 1); ãè»½éå
	            }
	          }
	        }.bind(this));
	        ArrayUtil["delete"](nowNoteOnIdxAry, i); // nowNoteOnIdxAry.splice(i, 1); ãè»½éå
	      }
	    };

	    for (var i = nowNoteOnIdxAry.length - 1; i >= 0; i--) {
	      _loop2(i);
	    }

	    delete channel.nowNoteOnIdxAry;
	  }

	  if (this.settings.isSkipEnding) songLength = lastNoteOffTiming;
	  tempoTrack.push({
	    timing: songLength,
	    time: 60 / tempo / header.resolution * (songLength - tempoCurTick) + tempoCurTime,
	    value: 120
	  }); // WebMIDIç¨ã®MIDIã¡ãã»ã¼ã¸ãä½æ //

	  var messages = [];

	  if (this.settings.isWebMIDI) {
	    var _channel = channels[16];
	    var _tempo = 120;
	    var _tempoCurTick = 0;
	    var _tempoCurTime = 0;
	    var indIdx = _channel.indicesHead;
	    var indices = _channel.indices;

	    while (indIdx != -1) {
	      var tick = indices[indIdx];
	      var pLen = indices[indIdx + 1];
	      var p = indices[indIdx + 2];
	      var nextIdx = indices[indIdx + 3];
	      var time = 60 / _tempo / header.resolution * (tick - _tempoCurTick) + _tempoCurTime; // Events

	      switch (smf[p]) {
	        case 0xFF:
	          // Meta Events
	          switch (smf[p + 1]) {
	            case 0x51:
	              // Tempo
	              _tempoCurTime += 60 / _tempo / header.resolution * (tick - _tempoCurTick);
	              _tempoCurTick = tick;
	              _tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);
	              break;
	          }

	      }

	      messages.push({
	        time: time,
	        tick: tick,
	        smfPtr: p,
	        smfPtrLen: pLen
	      });
	      indIdx = nextIdx;
	    }
	  } // é¢æ°å¼ã³åºãåã«ãã¼ã¿ãè¿ã //


	  info.songLength = songLength;
	  info.cc111Tick = cc111Tick;
	  info.cc111Time = cc111Time;
	  info.firstNoteOnTiming = firstNoteOnTiming;
	  info.firstNoteOnTime = firstNoteOnTime;
	  info.lastNoteOffTiming = lastNoteOffTiming;
	  info.lastNoteOffTime = lastNoteOffTime;

	  if (this.settings.isWebMIDI) {
	    info.messages = messages;
	    info.smfData = new Uint8Array(smf); // lastStateãä¸æ¸ãããsmfãã³ãã¼
	  }

	  return info;
	}

	function parseSMF(_smf) {
	  if (this.debug) {
	    console.log(_smf);
	    var syoriTimeS1 = performance.now();
	  } // smféåã¯ãã¼ã¿ä¸æ¸ãããã®ã§_smfããã£ã¼ãã³ãã¼ãã


	  var smf = new Uint8Array(_smf); // SMFã®ãã©ã¼ããããã©ãããã§ãã¯ //
	  // "MThd"

	  if (smf[0] != 77 || smf[1] != 84 || smf[2] != 104 || smf[3] != 100) return "Not Sandard MIDI File."; // é¢æ°éã§ãã¼ã¿ãããåãããããã®Object //

	  var info = {};
	  info.smf = smf; // ãããã¼è§£æ //

	  parseHeader.call(this, info);

	  if (this.debug) {
	    var syoriTimeS2 = performance.now();
	  } // ãã©ãã¯è§£æ //


	  parseTrack.call(this, info);

	  if (this.debug) {
	    var syoriTimeS3 = performance.now();
	  } // MIDIã¤ãã³ãè§£æ //


	  parseEvent.call(this, info); // returnç¨ã®ãªãã¸ã§ã¯ãã«æå ±ãä»£å¥ //

	  var data = {};
	  data.header = info.header;
	  data.tempoTrack = info.tempoTrack;
	  data.beatTrack = info.beatTrack;
	  data.channels = info.channels;
	  data.songLength = info.songLength;
	  data.cc111Tick = info.cc111Tick;
	  data.cc111Time = info.cc111Time;
	  data.firstNoteOnTiming = info.firstNoteOnTiming;
	  data.firstNoteOnTime = info.firstNoteOnTime;
	  data.lastNoteOffTiming = info.lastNoteOffTiming;
	  data.lastNoteOffTime = info.lastNoteOffTime;

	  if (this.settings.isWebMIDI) {
	    data.messages = info.messages;
	    data.smfData = new Uint8Array(smf); // lastStateãä¸æ¸ãããsmfãã³ãã¼
	  }

	  if (this.debug) {
	    var syoriTimeE = performance.now();
	    console.log("parseSMF time", syoriTimeE - syoriTimeS1);
	    console.log("parseSMF(0/2) time", syoriTimeS2 - syoriTimeS1);
	    console.log("parseSMF(1/2) time", syoriTimeS3 - syoriTimeS2);
	    console.log("parseSMF(2/2) time", syoriTimeE - syoriTimeS3);
	    console.log(data);
	  }

	  return data;
	}

	function startWebMIDI() {
	  var _this = this;

	  var outputs;
	  if (!navigator.requestMIDIAccess) return; // 1åç®ï¼ãã©ã¦ã¶ã«MIDIããã¤ã¹ã®ãã«ã³ã³ãã­ã¼ã«ãè¦æ±ãã(SysExã®ä½¿ç¨ãè¦æ±)
	  // 2åç®ï¼MIDIããã¤ã¹ã®ãã«ã³ã³ãã­ã¼ã«ããã­ãã¯ãããããSysExç¡ãã§MIDIã¢ã¯ã»ã¹ãè¦æ±ãã

	  var sysEx = this.settings.WebMIDIPortSysEx;

	  var midiAccessSuccess = function midiAccessSuccess(midiAccess) {
	    var _this2 = this;

	    _newArrowCheck(this, _this);

	    outputs = midiAccess.outputs;
	    this.settings.WebMIDIPortOutputs = outputs;
	    var output;

	    if (this.settings.WebMIDIPort == -1) {
	      this.settings.WebMIDIPortOutputs.forEach(function (o) {
	        _newArrowCheck(this, _this2);

	        if (!output) output = o;
	      }.bind(this));
	    } else {
	      output = this.settings.WebMIDIPortOutputs.get(settings.WebMIDIPort);
	    }

	    this.settings.WebMIDIPortOutput = output;
	    this.settings.WebMIDIPortSysEx = sysEx;

	    if (output) {
	      output.open();
	      this.initStatus(); // ãªã»ããã¤ãã³ãï¼GMã·ã¹ãã ã»ãªã³ç­ï¼ãéãããå¼ã³åºã
	    }

	    return outputs;
	  }.bind(this);

	  var _midiAccessFailure = function midiAccessFailure(err) {
	    _newArrowCheck(this, _this);

	    console.log(err);

	    if (sysEx) {
	      sysEx = false;
	      navigator.requestMIDIAccess({
	        sysex: sysEx
	      }).then(midiAccessSuccess)["catch"](_midiAccessFailure);
	    }
	  }.bind(this);

	  navigator.requestMIDIAccess({
	    sysex: sysEx
	  }).then(midiAccessSuccess)["catch"](_midiAccessFailure); // çµäºæã«é³´ããã¦ããé³ãåã

	  window.addEventListener('unload', function (e) {
	    _newArrowCheck(this, _this);

	    for (var t = 0; t < 16; t++) {
	      this.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);

	      for (var i = 0; i < 128; i++) {
	        this.settings.WebMIDIPortOutput.send([0x80 + t, i, 0]);
	      }
	    }
	  }.bind(this));
	}

	var PicoAudio = /*#__PURE__*/function () {
	  /**
	   * PicoAudioã¯ã©ã¹ã®ã³ã³ã¹ãã©ã¯ã¿
	   * @param {AudioContext} audioContext 
	   * @param {PicoAudio} picoAudio 
	   */
	  function PicoAudio(audioContext, picoAudio) {
	    _classCallCheck(this, PicoAudio);

	    picoAudioConstructor.call(this, audioContext, picoAudio);
	  }
	  /**
	   * åæåã»æºå
	   * @param {AudioContext} audioContext 
	   * @param {PicoAudio} picoAudio 
	   */


	  _createClass(PicoAudio, [{
	    key: "init",
	    value: function init$1(audioContext, picoAudio) {
	      return init.call(this, audioContext, picoAudio);
	    }
	    /**
	     * MIDIãã¡ã¤ã«(SMF)ãè§£æãã
	     * @param {Uint8Array} smf MIDIãã¡ã¤ã«ã®åå®¹ãå¥ã£ãUint8Arrayãªãã¸ã§ã¯ã
	     * @returns {Object} åçç¨ã®æå ±ãå¥ã£ããªãã¸ã§ã¯ã
	     */

	  }, {
	    key: "parseSMF",
	    value: function parseSMF$1(smf) {
	      return parseSMF.call(this, smf);
	    }
	    /**
	     * åçç¨ã®ãã¼ã¿ãã»ãããã
	     * @param {Object} data PicoAudio.parseSMF()ã§è¿ããããªãã¸ã§ã¯ã
	     */

	  }, {
	    key: "setData",
	    value: function setData$1(data) {
	      return setData.call(this, data);
	    }
	    /**
	     * åç
	     * @param {boolean} _isSongLooping PicoAudioåé¨ã§ä½¿ãå¼æ°
	     */

	  }, {
	    key: "play",
	    value: function play$1(_isSongLooping) {
	      return play.call(this, _isSongLooping);
	    }
	    /**
	     * åæ­¢
	     * @param {boolean} _isSongLooping PicoAudioåé¨ã§ä½¿ãå¼æ°
	     */

	  }, {
	    key: "stop",
	    value: function stop$1(_isSongLooping) {
	      return stop.call(this, _isSongLooping);
	    }
	    /**
	     * ãªã»ãã
	     * @param {boolean} _isSongLooping PicoAudioåé¨ã§ä½¿ãå¼æ°
	     * @param {boolean} _isLight PicoAudioåé¨ã§ä½¿ãå¼æ°
	     */

	  }, {
	    key: "initStatus",
	    value: function initStatus$1(_isSongLooping, _isLight) {
	      return initStatus.call(this, _isSongLooping, _isLight);
	    } // æé¢é¢ä¿ //

	    /**
	     * tickããtime(ç§)ãæ±ãã
	     * @param {number} tick
	     * @returns {number} time(ç§)
	     */

	  }, {
	    key: "getTime",
	    value: function getTime(tick) {
	      return getTime$1.call(this, tick);
	    }
	    /**
	     * time(ç§)ããtickãæ±ãã
	     * @param {number} time
	     * @returns {number} tick
	     */

	  }, {
	    key: "getTiming",
	    value: function getTiming$1(time) {
	      return getTiming.call(this, time);
	    } // åçã»é³æºé¢ä¿ //

	    /**
	     * åçå¦çï¼Web Audio API ã® oscillatorç­ã§é³ãé³´ããï¼
	     * @param {Object} option 
	     * @param {boolean} isDrum 
	     * @param {boolean} isExpression 
	     * @param {boolean} nonChannel 
	     * @param {boolean} nonStop 
	     * @returns {Object} AudioNodeããã©ã¡ã¼ã¿ãè¿ã
	     */

	  }, {
	    key: "createBaseNote",
	    value: function createBaseNote$1(option, isDrum, isExpression, nonChannel, nonStop) {
	      return createBaseNote.call(this, option, isDrum, isExpression, nonChannel, nonStop);
	    }
	    /**
	     * é³æºï¼ãã¼ã«ãã·ã§ã³ä»¥å¤ï¼
	     * @param {Object} option 
	     * @returns {Object} é³ãã¹ããããããé¢æ°ãè¿ã
	     */

	  }, {
	    key: "createNote",
	    value: function createNote$1(option) {
	      return createNote.call(this, option);
	    }
	    /**
	     * ãã¼ã«ãã·ã§ã³é³æº
	     * @param {Object} option 
	     * @returns {Object} é³ãã¹ããããããé¢æ°ãè¿ã
	     */

	  }, {
	    key: "createPercussionNote",
	    value: function createPercussionNote$1(option) {
	      return createPercussionNote.call(this, option);
	    } // åæ­¢ç®¡çé¢ä¿ //

	    /**
	     * åãã®Noteã®é³åæ­¢å¦ç
	     * @param {Object} tar 
	     * @param {number} time 
	     * @param {Object} stopGainNode 
	     * @param {boolean} isNoiseCut 
	     */

	  }, {
	    key: "stopAudioNode",
	    value: function stopAudioNode$1(tar, time, stopGainNode, isNoiseCut) {
	      return stopAudioNode.call(this, tar, time, stopGainNode, isNoiseCut);
	    }
	    /**
	     * stop()ããã¨ãã«å®è¡ããã³ã¼ã«ããã¯ç­ãç»é²
	     * @param {Object} tar 
	     */

	  }, {
	    key: "pushFunc",
	    value: function pushFunc$1(tar) {
	      return pushFunc.call(this, tar);
	    }
	    /**
	     * pushFunc()ã§äºç´ããã³ã¼ã«ããã¯ç­ãåé¤ãã
	     * @param {Object} tar1 
	     * @param {Object} tar2 
	     */

	  }, {
	    key: "clearFunc",
	    value: function clearFunc$1(tar1, tar2) {
	      return clearFunc.call(this, tar1, tar2);
	    }
	    /**
	     * Web MIDI API
	     */

	  }, {
	    key: "startWebMIDI",
	    value: function startWebMIDI$1() {
	      return startWebMIDI.call(this);
	    }
	    /**
	     * ããã©ã¼ãã³ã¹è¨æ¸¬
	     */

	  }, {
	    key: "measurePerformanceReverb",
	    value: function measurePerformanceReverb() {
	      return PerformanceUtil.measureReverb.call(this);
	    } // ã¤ã³ã¿ã¼ãã§ã¼ã¹é¢ä¿ //

	  }, {
	    key: "addEventListener",
	    value: function addEventListener(type, func) {
	      // type = EventName (play, stop, noteOn...)
	      this.events.push({
	        type: type,
	        func: func
	      });
	    }
	  }, {
	    key: "fireEvent",
	    value: function fireEvent(type, option) {
	      var _this = this;

	      this.events.forEach(function (event) {
	        _newArrowCheck(this, _this);

	        if (event.type == type) {
	          try {
	            event.func(option);
	          } catch (e) {
	            console.log(e);
	          }
	        }
	      }.bind(this));
	    }
	  }, {
	    key: "getChannels",
	    value: function getChannels() {
	      return this.channels;
	    }
	  }, {
	    key: "setChannels",
	    value: function setChannels(channels) {
	      var _this2 = this;

	      channels.forEach(function (channel, idx) {
	        _newArrowCheck(this, _this2);

	        this.channels[idx] = channel;
	      }.bind(this));
	    }
	  }, {
	    key: "initChannels",
	    value: function initChannels() {
	      for (var i = 0; i < 16; i++) {
	        this.channels[i] = [0, 0, 1];
	      }
	    }
	  }, {
	    key: "getMasterVolume",
	    value: function getMasterVolume() {
	      return this.settings.masterVolume;
	    }
	  }, {
	    key: "setMasterVolume",
	    value: function setMasterVolume(volume) {
	      this.settings.masterVolume = volume;

	      if (this.isStarted) {
	        this.masterGainNode.gain.value = this.settings.masterVolume;
	      }
	    }
	  }, {
	    key: "isLoop",
	    value: function isLoop() {
	      return this.settings.loop;
	    }
	  }, {
	    key: "setLoop",
	    value: function setLoop(loop) {
	      this.settings.loop = loop;
	    }
	  }, {
	    key: "isWebMIDI",
	    value: function isWebMIDI() {
	      return this.settings.isWebMIDI;
	    }
	  }, {
	    key: "setWebMIDI",
	    value: function setWebMIDI(enable) {
	      this.settings.isWebMIDI = enable;
	    }
	  }, {
	    key: "isCC111",
	    value: function isCC111() {
	      return this.settings.isCC111;
	    }
	  }, {
	    key: "setCC111",
	    value: function setCC111(enable) {
	      this.settings.isCC111 = enable;
	    }
	  }, {
	    key: "setStartTime",
	    value: function setStartTime(offset) {
	      this.states.startTime -= offset;
	    }
	  }, {
	    key: "setOnSongEndListener",
	    value: function setOnSongEndListener(listener) {
	      this.onSongEndListener = listener;
	    }
	  }, {
	    key: "onSongEnd",
	    value: function onSongEnd() {
	      if (this.onSongEndListener) {
	        var isStopFunc = this.onSongEndListener();
	        if (isStopFunc) return;
	      }

	      if (this.settings.loop) {
	        this.initStatus(true);

	        if (this.settings.isCC111 && this.cc111Time != -1) {
	          this.setStartTime(this.cc111Time);
	        }

	        this.play(true);
	      }
	    }
	  }, {
	    key: "isReverb",
	    value: function isReverb() {
	      return this.settings.isReverb;
	    }
	  }, {
	    key: "setReverb",
	    value: function setReverb(enable) {
	      this.settings.isReverb = enable;
	    }
	  }, {
	    key: "getReverbVolume",
	    value: function getReverbVolume() {
	      return this.settings.reverbVolume;
	    }
	  }, {
	    key: "setReverbVolume",
	    value: function setReverbVolume(volume) {
	      this.settings.reverbVolume = volume;
	    }
	  }, {
	    key: "isChorus",
	    value: function isChorus() {
	      return this.settings.isChorus;
	    }
	  }, {
	    key: "setChorus",
	    value: function setChorus(enable) {
	      this.settings.isChorus = enable;
	    }
	  }, {
	    key: "getChorusVolume",
	    value: function getChorusVolume() {
	      return this.settings.chorusVolume;
	    }
	  }, {
	    key: "setChorusVolume",
	    value: function setChorusVolume(volume) {
	      this.settings.chorusVolume = volume;
	    }
	  }]);

	  return PicoAudio;
	}(); // // PicoAudioãã°ã­ã¼ãã«å¤æ°ã«ç»é²
	// window.PicoAudio = PicoAudio;

	return PicoAudio;

})));
